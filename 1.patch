From 8e9df8eb43f238e9de8af31979db2fc5b9c34c63 Mon Sep 17 00:00:00 2001
From: TheWhisp <daavis.90@gmail.com>
Date: Mon, 23 Dec 2013 00:21:28 +0200
Subject: [PATCH] msm: camera: add support for legacy camera and sr300pc20
 sensor

---
 arch/arm/configs/cyanogenmod/jenad_defconfig     |    1 +
 arch/arm/mach-msm/include/mach/board.h           |    4 +
 arch/arm/mach-msm/include/mach/camera.h          |    4 +
 arch/arm/mach-msm/include/mach/camera_legacy.h   |  632 ++
 drivers/media/video/Kconfig                      |    8 +
 drivers/media/video/msm/Kconfig                  |    7 +
 drivers/media/video/msm/Makefile                 |   15 +-
 drivers/media/video/msm/flash_legacy.c           |  517 ++
 drivers/media/video/msm/io/Makefile              |    8 +-
 drivers/media/video/msm/io/msm_io_7x27a_legacy.c |  633 ++
 drivers/media/video/msm/msm_camera_legacy.c      | 4060 ++++++++++
 drivers/media/video/msm/msm_vfe7x27a_legacy.c    |  741 ++
 drivers/media/video/msm/sec_cam_pmic.c           |  197 +
 drivers/media/video/msm/sec_cam_pmic.h           |   34 +
 drivers/media/video/msm/sr300pc20.c              | 1877 +++++
 drivers/media/video/msm/sr300pc20.h              | 9090 +++++++++++++++++++++
 drivers/media/video/msm/sr300pc20_jena.h         | 9463 ++++++++++++++++++++++
 include/media/msm_camera.h                       |    4 +
 include/media/msm_camera_legacy.h                | 1400 ++++
 19 files changed, 28693 insertions(+), 2 deletions(-)
 create mode 100644 arch/arm/mach-msm/include/mach/camera_legacy.h
 create mode 100644 drivers/media/video/msm/flash_legacy.c
 create mode 100644 drivers/media/video/msm/io/msm_io_7x27a_legacy.c
 create mode 100644 drivers/media/video/msm/msm_camera_legacy.c
 create mode 100644 drivers/media/video/msm/msm_vfe7x27a_legacy.c
 create mode 100644 drivers/media/video/msm/sec_cam_pmic.c
 create mode 100644 drivers/media/video/msm/sec_cam_pmic.h
 create mode 100644 drivers/media/video/msm/sr300pc20.c
 create mode 100644 drivers/media/video/msm/sr300pc20.h
 create mode 100644 drivers/media/video/msm/sr300pc20_jena.h
 create mode 100644 include/media/msm_camera_legacy.h

diff --git a/arch/arm/configs/cyanogenmod/jenad_defconfig b/arch/arm/configs/cyanogenmod/jenad_defconfig
index 30d9b10..6d5b1a1 100644
--- a/arch/arm/configs/cyanogenmod/jenad_defconfig
+++ b/arch/arm/configs/cyanogenmod/jenad_defconfig
@@ -2134,6 +2134,7 @@ CONFIG_V4L_PLATFORM_DRIVERS=y
 # Qualcomm MSM Camera And Video
 #
 CONFIG_MSM_CAMERA=y
+CONFIG_MSM_CAMERA_LEGACY=y
 # CONFIG_MSM_CAMERA_DEBUG is not set
 # CONFIG_MSM_CAMERA_V4L2 is not set
 
diff --git a/arch/arm/mach-msm/include/mach/board.h b/arch/arm/mach-msm/include/mach/board.h
index c74b979..842e88c 100644
--- a/arch/arm/mach-msm/include/mach/board.h
+++ b/arch/arm/mach-msm/include/mach/board.h
@@ -168,12 +168,14 @@ struct msm_camera_sensor_strobe_flash_data {
 	int state;
 };
 
+#ifndef CONFIG_MSM_CAMERA_LEGACY
 enum msm_camera_type {
 	BACK_CAMERA_2D,
 	FRONT_CAMERA_2D,
 	BACK_CAMERA_3D,
 	BACK_CAMERA_INT_3D,
 };
+#endif
 
 enum msm_sensor_type {
 	BAYER_SENSOR,
@@ -289,7 +291,9 @@ struct msm_camera_sensor_info {
 	struct msm_camera_csi_params csi_params;
 	struct msm_camera_sensor_strobe_flash_data *strobe_flash_data;
 	char *eeprom_data;
+#ifndef CONFIG_MSM_CAMERA_LEGACY
 	enum msm_camera_type camera_type;
+#endif
 	enum msm_sensor_type sensor_type;
 	struct msm_actuator_info *actuator_info;
 	int pmic_gpio_enable;
diff --git a/arch/arm/mach-msm/include/mach/camera.h b/arch/arm/mach-msm/include/mach/camera.h
index 7aa112e..8210298 100644
--- a/arch/arm/mach-msm/include/mach/camera.h
+++ b/arch/arm/mach-msm/include/mach/camera.h
@@ -1,3 +1,6 @@
+#ifdef CONFIG_MSM_CAMERA_LEGACY
+#include "mach/camera_legacy.h"
+#else
 /* Copyright (c) 2009-2012, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -637,3 +640,4 @@ int msm_camera_config_gpio_table
 int msm_camera_request_gpio_table
 	(struct msm_camera_sensor_info *sinfo, int gpio_en);
 #endif
+#endif  /* CONFIG_MSM_CAMERA_LEGACY */
diff --git a/arch/arm/mach-msm/include/mach/camera_legacy.h b/arch/arm/mach-msm/include/mach/camera_legacy.h
new file mode 100644
index 0000000..ade0ad4
--- /dev/null
+++ b/arch/arm/mach-msm/include/mach/camera_legacy.h
@@ -0,0 +1,632 @@
+/* Copyright (c) 2009-2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __ASM__ARCH_CAMERA_H
+#define __ASM__ARCH_CAMERA_H
+
+#include <linux/list.h>
+#include <linux/poll.h>
+#include <linux/cdev.h>
+#include <linux/platform_device.h>
+#include <linux/pm_qos.h>
+#include "linux/types.h"
+
+#include <mach/board.h>
+#include <media/msm_camera.h>
+
+/*#define CONFIG_MSM_CAMERA_DEBUG*/
+#ifdef CONFIG_MSM_CAMERA_DEBUG
+#define CDBG(fmt, args...) printk(fmt, ##args)
+#else
+#define CDBG(fmt, args...) do { } while (0)
+#endif
+
+#define PAD_TO_2K(a, b) ((!b) ? a : (((a)+2047) & ~2047))
+
+#define MSM_CAMERA_MSG 0
+#define MSM_CAMERA_EVT 1
+#define NUM_WB_EXP_NEUTRAL_REGION_LINES 4
+#define NUM_WB_EXP_STAT_OUTPUT_BUFFERS  3
+#define NUM_AUTOFOCUS_MULTI_WINDOW_GRIDS 16
+#define NUM_STAT_OUTPUT_BUFFERS      3
+#define NUM_AF_STAT_OUTPUT_BUFFERS      3
+#define max_control_command_size 260
+#define CROP_LEN 36
+
+enum vfe_mode_of_operation{
+	VFE_MODE_OF_OPERATION_CONTINUOUS,
+	VFE_MODE_OF_OPERATION_SNAPSHOT,
+	VFE_MODE_OF_OPERATION_VIDEO,
+	VFE_MODE_OF_OPERATION_RAW_SNAPSHOT,
+	VFE_MODE_OF_OPERATION_ZSL,
+	VFE_LAST_MODE_OF_OPERATION_ENUM
+};
+
+enum msm_queue {
+	MSM_CAM_Q_CTRL,     /* control command or control command status */
+	MSM_CAM_Q_VFE_EVT,  /* adsp event */
+	MSM_CAM_Q_VFE_MSG,  /* adsp message */
+	MSM_CAM_Q_V4L2_REQ, /* v4l2 request */
+	MSM_CAM_Q_VPE_MSG,  /* vpe message */
+	MSM_CAM_Q_PP_MSG,  /* pp message */
+};
+
+enum vfe_resp_msg {
+	VFE_EVENT,
+	VFE_MSG_GENERAL,
+	VFE_MSG_SNAPSHOT,
+	VFE_MSG_OUTPUT_P,   /* preview (continuous mode ) */
+	VFE_MSG_OUTPUT_T,   /* thumbnail (snapshot mode )*/
+	VFE_MSG_OUTPUT_S,   /* main image (snapshot mode )*/
+	VFE_MSG_OUTPUT_V,   /* video   (continuous mode ) */
+	VFE_MSG_STATS_AEC,
+	VFE_MSG_STATS_AF,
+	VFE_MSG_STATS_AWB,
+	VFE_MSG_STATS_RS,
+	VFE_MSG_STATS_CS,
+	VFE_MSG_STATS_IHIST,
+	VFE_MSG_STATS_SKIN,
+	VFE_MSG_STATS_WE, /* AEC + AWB */
+	VFE_MSG_SYNC_TIMER0,
+	VFE_MSG_SYNC_TIMER1,
+	VFE_MSG_SYNC_TIMER2,
+	VFE_MSG_COMMON,
+};
+
+enum vpe_resp_msg {
+	VPE_MSG_GENERAL,
+	VPE_MSG_OUTPUT_V,   /* video   (continuous mode ) */
+	VPE_MSG_OUTPUT_ST_L,
+	VPE_MSG_OUTPUT_ST_R,
+};
+
+enum msm_camera_type {
+	BACK_CAMERA_2D,
+	FRONT_CAMERA_2D,
+	BACK_CAMERA_3D,
+};
+
+enum msm_stereo_state {
+	STEREO_VIDEO_IDLE,
+	STEREO_VIDEO_ACTIVE,
+	STEREO_SNAP_IDLE,
+	STEREO_SNAP_STARTED,
+	STEREO_SNAP_BUFFER1_PROCESSING,
+	STEREO_SNAP_BUFFER2_PROCESSING,
+	STEREO_RAW_SNAP_IDLE,
+	STEREO_RAW_SNAP_STARTED,
+};
+
+enum msm_ispif_intftype {
+	PIX0,
+	RDI0,
+	PIX1,
+	RDI1,
+	PIX2,
+	RDI2,
+};
+
+enum msm_ispif_vc {
+	VC0,
+	VC1,
+	VC2,
+	VC3,
+};
+
+enum msm_ispif_cid {
+	CID0,
+	CID1,
+	CID2,
+	CID3,
+	CID4,
+	CID5,
+	CID6,
+	CID7,
+	CID8,
+	CID9,
+	CID10,
+	CID11,
+	CID12,
+	CID13,
+	CID14,
+	CID15,
+};
+
+struct msm_ispif_params {
+	uint8_t intftype;
+	uint16_t cid_mask;
+	uint8_t csid;
+};
+struct msm_vpe_phy_info {
+	uint32_t sbuf_phy;
+	uint32_t y_phy;
+	uint32_t cbcr_phy;
+	uint8_t  output_id; /* VFE31_OUTPUT_MODE_PT/S/V */
+	uint32_t frame_id;
+};
+
+struct msm_camera_csid_vc_cfg {
+	uint8_t cid;
+	uint8_t dt;
+	uint8_t decode_format;
+};
+
+struct msm_camera_csid_lut_params {
+	uint8_t num_cid;
+	struct msm_camera_csid_vc_cfg *vc_cfg;
+};
+
+struct msm_camera_csid_params {
+	uint8_t lane_cnt;
+	uint8_t lane_assign;
+	struct msm_camera_csid_lut_params lut_params;
+};
+
+struct msm_camera_csiphy_params {
+	uint8_t lane_cnt;
+	uint8_t settle_cnt;
+};
+
+#define VFE31_OUTPUT_MODE_PT (0x1 << 0)
+#define VFE31_OUTPUT_MODE_S (0x1 << 1)
+#define VFE31_OUTPUT_MODE_V (0x1 << 2)
+#define VFE31_OUTPUT_MODE_P (0x1 << 3)
+#define VFE31_OUTPUT_MODE_T (0x1 << 4)
+
+#define CSI_EMBED_DATA 0x12
+#define CSI_RAW8    0x2A
+#define CSI_RAW10   0x2B
+#define CSI_RAW12   0x2C
+
+#define CSI_DECODE_6BIT 0
+#define CSI_DECODE_8BIT 1
+#define CSI_DECODE_10BIT 2
+#define VFE32_OUTPUT_MODE_PT (0x1 << 0)
+#define VFE32_OUTPUT_MODE_S (0x1 << 1)
+#define VFE32_OUTPUT_MODE_V (0x1 << 2)
+
+struct msm_vfe_phy_info {
+	uint32_t sbuf_phy;
+	uint32_t y_phy;
+	uint32_t cbcr_phy;
+	uint8_t  output_id; /* VFE31_OUTPUT_MODE_PT/S/V */
+	uint32_t frame_id;
+};
+
+struct msm_vfe_stats_msg {
+	uint32_t aec_buff;
+	uint32_t awb_buff;
+	uint32_t af_buff;
+	uint32_t ihist_buff;
+	uint32_t rs_buff;
+	uint32_t cs_buff;
+	uint32_t skin_buff;
+	uint32_t status_bits;
+	uint32_t frame_id;
+};
+
+struct video_crop_t{
+	uint32_t  in1_w;
+	uint32_t  out1_w;
+	uint32_t  in1_h;
+	uint32_t  out1_h;
+	uint32_t  in2_w;
+	uint32_t  out2_w;
+	uint32_t  in2_h;
+	uint32_t  out2_h;
+	uint8_t update_flag;
+};
+
+struct msm_vpe_buf_info {
+	uint32_t y_phy;
+	uint32_t cbcr_phy;
+	struct   timespec ts;
+	uint32_t frame_id;
+	struct	 video_crop_t vpe_crop;
+};
+
+struct msm_vfe_resp {
+	enum vfe_resp_msg type;
+	struct msm_cam_evt_msg evt_msg;
+	struct msm_vfe_phy_info phy;
+	struct msm_vfe_stats_msg stats_msg;
+	struct msm_vpe_buf_info vpe_bf;
+	void    *extdata;
+	int32_t extlen;
+};
+
+struct msm_vpe_resp {
+	enum vpe_resp_msg type;
+	struct msm_cam_evt_msg evt_msg;
+	struct msm_vpe_phy_info phy;
+	void    *extdata;
+	int32_t extlen;
+};
+
+struct msm_vpe_callback {
+	void (*vpe_resp)(struct msm_vpe_resp *,
+					enum msm_queue, void *syncdata,
+		void *time_stamp, gfp_t gfp);
+	void* (*vpe_alloc)(int, void *syncdata, gfp_t gfp);
+	void (*vpe_free)(void *ptr);
+};
+
+struct msm_vfe_callback {
+	void (*vfe_resp)(struct msm_vfe_resp *,
+		enum msm_queue, void *syncdata,
+		gfp_t gfp);
+	void* (*vfe_alloc)(int, void *syncdata, gfp_t gfp);
+	void (*vfe_free)(void *ptr);
+};
+
+struct msm_camvfe_fn {
+	int (*vfe_init)(struct msm_vfe_callback *,
+			struct platform_device *);
+	int (*vfe_enable)(struct camera_enable_cmd *);
+	int (*vfe_config)(struct msm_vfe_cfg_cmd *, void *);
+	int (*vfe_disable)(struct camera_enable_cmd *,
+			struct platform_device *dev);
+	void (*vfe_release)(struct platform_device *);
+	void (*vfe_stop)(void);
+};
+
+struct msm_camvfe_params {
+	struct msm_vfe_cfg_cmd *vfe_cfg;
+	void *data;
+};
+
+struct msm_camvpe_fn {
+	int (*vpe_reg)(struct msm_vpe_callback *);
+	int (*vpe_cfg_update) (void *);
+	void (*send_frame_to_vpe) (uint32_t y_phy, uint32_t cbcr_phy,
+		struct timespec *ts, int output_id);
+	int (*vpe_config)(struct msm_vpe_cfg_cmd *, void *);
+	void (*vpe_cfg_offset)(int frame_pack, uint32_t pyaddr,
+		uint32_t pcbcraddr, struct timespec *ts, int output_id,
+		struct msm_st_half st_half, int frameid);
+	int *dis;
+};
+
+struct msm_sensor_ctrl {
+	int (*s_init)(const struct msm_camera_sensor_info *);
+	int (*s_release)(void);
+	int (*s_config)(void __user *);
+        int (*s_ext_config)(void __user *); // add for dual camera interface
+	enum msm_camera_type s_camera_type;
+	uint32_t s_mount_angle;
+	enum msm_st_frame_packing s_video_packing;
+	enum msm_st_frame_packing s_snap_packing;
+};
+struct msm_strobe_flash_ctrl {
+	int (*strobe_flash_init)
+		(struct msm_camera_sensor_strobe_flash_data *);
+	int (*strobe_flash_release)
+		(struct msm_camera_sensor_strobe_flash_data *, int32_t);
+	int (*strobe_flash_charge)(int32_t, int32_t, uint32_t);
+};
+
+/* this structure is used in kernel */
+struct msm_queue_cmd {
+	struct list_head list_config;
+	struct list_head list_control;
+	struct list_head list_frame;
+	struct list_head list_pict;
+	struct list_head list_vpe_frame;
+	enum msm_queue type;
+	void *command;
+	atomic_t on_heap;
+	struct timespec ts;
+	uint32_t error_code;
+};
+
+struct msm_device_queue {
+	struct list_head list;
+	spinlock_t lock;
+	wait_queue_head_t wait;
+	int max;
+	int len;
+	const char *name;
+};
+
+struct msm_sync {
+	/* These two queues are accessed from a process context only
+	 * They contain pmem descriptors for the preview frames and the stats
+	 * coming from the camera sensor.
+	*/
+	struct hlist_head pmem_frames;
+	struct hlist_head pmem_stats;
+
+	/* The message queue is used by the control thread to send commands
+	 * to the config thread, and also by the DSP to send messages to the
+	 * config thread.  Thus it is the only queue that is accessed from
+	 * both interrupt and process context.
+	 */
+	struct msm_device_queue event_q;
+
+	/* This queue contains preview frames. It is accessed by the DSP (in
+	 * in interrupt context, and by the frame thread.
+	 */
+	struct msm_device_queue frame_q;
+	int unblock_poll_frame;
+	int unblock_poll_pic_frame;
+
+	/* This queue contains snapshot frames.  It is accessed by the DSP (in
+	 * interrupt context, and by the control thread.
+	 */
+	struct msm_device_queue pict_q;
+	int get_pic_abort;
+	struct msm_device_queue vpe_q;
+
+	struct msm_camera_sensor_info *sdata;
+	struct msm_camvfe_fn vfefn;
+	struct msm_camvpe_fn vpefn;
+	struct msm_sensor_ctrl sctrl;
+	struct msm_strobe_flash_ctrl sfctrl;
+	struct pm_qos_request idle_pm_qos;
+	struct platform_device *pdev;
+	int16_t ignore_qcmd_type;
+	uint8_t ignore_qcmd;
+	uint8_t opencnt;
+	void *cropinfo;
+	int  croplen;
+	int  core_powered_on;
+
+	struct fd_roi_info fdroiinfo;
+
+	atomic_t vpe_enable;
+	uint32_t pp_mask;
+	uint8_t pp_frame_avail;
+	struct msm_queue_cmd *pp_prev;
+	struct msm_queue_cmd *pp_snap;
+	struct msm_queue_cmd *pp_thumb;
+	int video_fd;
+
+	const char *apps_id;
+
+	struct mutex lock;
+	struct list_head list;
+	uint8_t liveshot_enabled;
+	struct msm_cam_v4l2_device *pcam_sync;
+
+	uint8_t stereocam_enabled;
+	struct msm_queue_cmd *pp_stereocam;
+	struct msm_queue_cmd *pp_stereocam2;
+	struct msm_queue_cmd *pp_stereosnap;
+	enum msm_stereo_state stereo_state;
+	int stcam_quality_ind;
+	uint32_t stcam_conv_value;
+
+	spinlock_t pmem_frame_spinlock;
+	spinlock_t pmem_stats_spinlock;
+	spinlock_t abort_pict_lock;
+	int snap_count;
+	int thumb_count;
+};
+
+#define MSM_APPS_ID_V4L2 "msm_v4l2"
+#define MSM_APPS_ID_PROP "msm_qct"
+
+struct msm_cam_device {
+	struct msm_sync *sync; /* most-frequently accessed */
+	struct device *device;
+	struct cdev cdev;
+	/* opened is meaningful only for the config and frame nodes,
+	 * which may be opened only once.
+	 */
+	atomic_t opened;
+};
+
+struct msm_control_device {
+	struct msm_cam_device *pmsm;
+
+	/* Used for MSM_CAM_IOCTL_CTRL_CMD_DONE responses */
+	uint8_t ctrl_data[max_control_command_size];
+	struct msm_ctrl_cmd ctrl;
+	struct msm_queue_cmd qcmd;
+
+	/* This queue used by the config thread to send responses back to the
+	 * control thread.  It is accessed only from a process context.
+	 */
+	struct msm_device_queue ctrl_q;
+};
+
+struct register_address_value_pair {
+	uint16_t register_address;
+	uint16_t register_value;
+};
+
+struct msm_pmem_region {
+	struct hlist_node list;
+	unsigned long paddr;
+	unsigned long len;
+	struct file *file;
+	struct msm_pmem_info info;
+};
+
+struct axidata {
+	uint32_t bufnum1;
+	uint32_t bufnum2;
+	uint32_t bufnum3;
+	struct msm_pmem_region *region;
+};
+
+#ifdef CONFIG_MSM_CAMERA_FLASH
+int msm_camera_flash_set_led_state(
+	struct msm_camera_sensor_flash_data *fdata,
+	unsigned led_state);
+int msm_strobe_flash_init(struct msm_sync *sync, uint32_t sftype);
+int msm_flash_ctrl(struct msm_camera_sensor_info *sdata,
+			struct flash_ctrl_data *flash_info);
+#else
+static inline int msm_camera_flash_set_led_state(
+	struct msm_camera_sensor_flash_data *fdata,
+	unsigned led_state)
+{
+	return -ENOTSUPP;
+}
+static inline int msm_strobe_flash_init(
+	struct msm_sync *sync, uint32_t sftype)
+{
+	return -ENOTSUPP;
+}
+static inline int msm_flash_ctrl(
+		struct msm_camera_sensor_info *sdata,
+		struct flash_ctrl_data *flash_info)
+{
+	return -ENOTSUPP;
+}
+#endif
+
+
+
+void msm_camvfe_init(void);
+int msm_camvfe_check(void *);
+void msm_camvfe_fn_init(struct msm_camvfe_fn *, void *);
+void msm_camvpe_fn_init(struct msm_camvpe_fn *, void *);
+int msm_camera_drv_start(struct platform_device *dev,
+		int (*sensor_probe)(const struct msm_camera_sensor_info *,
+					struct msm_sensor_ctrl *));
+
+enum msm_camio_clk_type {
+	CAMIO_VFE_MDC_CLK,
+	CAMIO_MDC_CLK,
+	CAMIO_VFE_CLK,
+	CAMIO_VFE_AXI_CLK,
+
+	CAMIO_VFE_CAMIF_CLK,
+	CAMIO_VFE_PBDG_CLK,
+	CAMIO_CAM_MCLK_CLK,
+	CAMIO_CAMIF_PAD_PBDG_CLK,
+
+	CAMIO_CSI0_VFE_CLK,
+	CAMIO_CSI1_VFE_CLK,
+	CAMIO_VFE_PCLK,
+
+	CAMIO_CSI_SRC_CLK,
+	CAMIO_CSI0_CLK,
+	CAMIO_CSI1_CLK,
+	CAMIO_CSI0_PCLK,
+	CAMIO_CSI1_PCLK,
+
+	CAMIO_CSI1_SRC_CLK,
+	CAMIO_CSI_PIX_CLK,
+	CAMIO_CSI_RDI_CLK,
+	CAMIO_CSIPHY0_TIMER_CLK,
+	CAMIO_CSIPHY1_TIMER_CLK,
+
+	CAMIO_JPEG_CLK,
+	CAMIO_JPEG_PCLK,
+	CAMIO_VPE_CLK,
+	CAMIO_VPE_PCLK,
+
+	CAMIO_CSI0_PHY_CLK,
+	CAMIO_CSI1_PHY_CLK,
+	CAMIO_CSIPHY_TIMER_SRC_CLK,
+
+	CAMIO_MAX_CLK
+};
+
+enum msm_camio_clk_src_type {
+	MSM_CAMIO_CLK_SRC_INTERNAL,
+	MSM_CAMIO_CLK_SRC_EXTERNAL,
+	MSM_CAMIO_CLK_SRC_MAX
+};
+
+enum msm_s_test_mode {
+	S_TEST_OFF,
+	S_TEST_1,
+	S_TEST_2,
+	S_TEST_3
+};
+
+enum msm_s_resolution {
+	S_QTR_SIZE,
+	S_FULL_SIZE,
+	S_INVALID_SIZE
+};
+
+enum msm_s_reg_update {
+	/* Sensor egisters that need to be updated during initialization */
+	S_REG_INIT,
+	/* Sensor egisters that needs periodic I2C writes */
+	S_UPDATE_PERIODIC,
+	/* All the sensor Registers will be updated */
+	S_UPDATE_ALL,
+	/* Not valid update */
+	S_UPDATE_INVALID
+};
+
+enum msm_s_setting {
+	S_RES_PREVIEW,
+	S_RES_CAPTURE
+};
+
+enum msm_bus_perf_setting {
+	S_INIT,
+	S_PREVIEW,
+	S_VIDEO,
+	S_CAPTURE,
+	S_ZSL,
+	S_STEREO_VIDEO,
+	S_STEREO_CAPTURE,
+	S_DEFAULT,
+	S_EXIT
+};
+
+int msm_camio_enable(struct platform_device *dev);
+int msm_camio_jpeg_clk_enable(void);
+int msm_camio_jpeg_clk_disable(void);
+int msm_camio_vpe_clk_enable(uint32_t);
+int msm_camio_vpe_clk_disable(void);
+
+int  msm_camio_clk_enable(enum msm_camio_clk_type clk);
+int  msm_camio_clk_disable(enum msm_camio_clk_type clk);
+int  msm_camio_clk_config(uint32_t freq);
+void msm_camio_clk_rate_set(int rate);
+void msm_camio_vfe_clk_rate_set(int rate);
+void msm_camio_clk_rate_set_2(struct clk *clk, int rate);
+void msm_camio_clk_set_min_rate(struct clk *clk, int rate);
+void msm_camio_clk_axi_rate_set(int rate);
+void msm_disable_io_gpio_clk(struct platform_device *);
+
+void msm_camio_camif_pad_reg_reset(void);
+void msm_camio_camif_pad_reg_reset_2(void);
+
+void msm_camio_vfe_blk_reset(void);
+
+void msm_camio_clk_sel(enum msm_camio_clk_src_type);
+void msm_camio_disable(struct platform_device *);
+int msm_camio_probe_on(struct platform_device *);
+int msm_camio_probe_off(struct platform_device *);
+int msm_camio_sensor_clk_off(struct platform_device *);
+int msm_camio_sensor_clk_on(struct platform_device *);
+int msm_camio_csi_config(struct msm_camera_csi_params *csi_params);
+int msm_camio_csiphy_config(struct msm_camera_csiphy_params *csiphy_params);
+int msm_camio_csid_config(struct msm_camera_csid_params *csid_params);
+void msm_io_read_interrupt(void);
+int add_axi_qos(void);
+int update_axi_qos(uint32_t freq);
+void release_axi_qos(void);
+void msm_io_w(u32 data, void __iomem *addr);
+void msm_io_w_mb(u32 data, void __iomem *addr);
+u32 msm_io_r(void __iomem *addr);
+u32 msm_io_r_mb(void __iomem *addr);
+void msm_io_dump(void __iomem *addr, int size);
+void msm_io_memcpy(void __iomem *dest_addr, void __iomem *src_addr, u32 len);
+void msm_camio_set_perf_lvl(enum msm_bus_perf_setting);
+
+void *msm_isp_sync_alloc(int size,
+	void *syncdata __attribute__((unused)), gfp_t gfp);
+
+void msm_isp_sync_free(void *ptr);
+#endif
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index ae020e8..bd51658 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -1188,6 +1188,14 @@ menuconfig MSM_CAMERA
 	  Say Y here to enable selecting the video adapters for
 	  Qualcomm msm camera and video encoding
 
+menuconfig MSM_CAMERA_LEGACY
+        bool "Qualcomm legacy MSM camera and video capture support"
+        depends on MSM_CAMERA
+        default y
+        help
+          Say Y here to enable camera suppor for legacy
+          Qualcomm msm camera and video encoding
+
 config MSM_CAMERA_DEBUG
 	bool "Qualcomm MSM camera debugging with printk"
 	depends on MSM_CAMERA
diff --git a/drivers/media/video/msm/Kconfig b/drivers/media/video/msm/Kconfig
index c23aaa1..08dbfab 100755
--- a/drivers/media/video/msm/Kconfig
+++ b/drivers/media/video/msm/Kconfig
@@ -192,6 +192,13 @@ config MSM_CAMERA_FLASH_TPS61310
 	  It is a Texas Instruments multiple LED Flash
 	  for camera flash and video light applications.
 
+config SR300PC20
+        bool "Sensor sr300pc20 (3M)"
+        depends on MSM_CAMERA_LEGACY && !ARCH_MSM8X60 && !MSM_CAMERA_V4L2
+        default n
+        ---help---
+          Siliconfile 3M Sensor with Autofocus
+
 config IMX072
 	bool "Sensor imx072 (Sony 5M)"
 	default n
diff --git a/drivers/media/video/msm/Makefile b/drivers/media/video/msm/Makefile
index 498b0e1..d5ff074 100644
--- a/drivers/media/video/msm/Makefile
+++ b/drivers/media/video/msm/Makefile
@@ -15,16 +15,28 @@ ifeq ($(CONFIG_MSM_CAMERA_V4L2),y)
   obj-$(CONFIG_MSM_CAMERA) += io/ eeprom/ sensors/ actuators/ csi/
 #  obj-$(CONFIG_MSM_CAMERA) += msm_gesture.o
 else
+ifeq ($(CONFIG_MSM_CAMERA_LEGACY),y)
+  obj-$(CONFIG_MSM_CAMERA) += msm_camera_legacy.o
+else
   obj-$(CONFIG_MSM_CAMERA) += msm_camera.o
 endif
+endif
 obj-$(CONFIG_MSM_CAMERA) += msm_axi_qos.o gemini/
-obj-$(CONFIG_MSM_CAMERA_FLASH) += flash.o
+ifeq ($(CONFIG_MSM_CAMERA_LEGACY),y)
+  obj-$(CONFIG_MSM_CAMERA_FLASH) += flash_legacy.o
+else
+  obj-$(CONFIG_MSM_CAMERA_FLASH) += flash.o
+endif
 obj-$(CONFIG_ARCH_MSM_ARM11) += msm_vfe7x.o
 ifeq ($(CONFIG_MSM_CAMERA_V4L2),y)
   obj-$(CONFIG_ARCH_MSM7X27A) += msm_vfe7x27a_v4l2.o
 else
+ifeq ($(CONFIG_MSM_CAMERA_LEGACY),y)
+  obj-$(CONFIG_ARCH_MSM7X27A) += msm_vfe7x27a_legacy.o
+else
   obj-$(CONFIG_ARCH_MSM7X27A) += msm_vfe7x27a.o
 endif
+endif
 obj-$(CONFIG_ARCH_QSD8X50) += msm_vfe8x.o msm_vfe8x_proc.o
 ifeq ($(CONFIG_MSM_CAMERA_V4L2),y)
   obj-$(CONFIG_ARCH_MSM8X60) += msm_vfe31_v4l2.o msm_vpe.o
@@ -57,6 +69,7 @@ obj-$(CONFIG_VB6801) += vb6801.o
 obj-$(CONFIG_IMX072) += imx072.o imx072_reg.o
 obj-$(CONFIG_OV5640) += ov5640.o
 obj-$(CONFIG_MT9D112) += mt9d112.o mt9d112_reg.o
+obj-$(CONFIG_SR300PC20) += sr300pc20.o sec_cam_pmic.o
 
 obj-$(CONFIG_MT9D113) += mt9d113.o mt9d113_reg.o
 obj-$(CONFIG_FB_MSM_WRITEBACK_MSM_PANEL) += wfd/
diff --git a/drivers/media/video/msm/flash_legacy.c b/drivers/media/video/msm/flash_legacy.c
new file mode 100644
index 0000000..970cc64
--- /dev/null
+++ b/drivers/media/video/msm/flash_legacy.c
@@ -0,0 +1,517 @@
+
+/* Copyright (c) 2009-2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/leds-pmic8058.h>
+#include <linux/pwm.h>
+#include <linux/pmic8058-pwm.h>
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <mach/pmic.h>
+#include <mach/camera.h>
+#include <mach/gpio.h>
+
+struct timer_list timer_flash;
+
+enum msm_cam_flash_stat{
+	MSM_CAM_FLASH_OFF,
+	MSM_CAM_FLASH_ON,
+};
+
+#if defined CONFIG_MSM_CAMERA_FLASH_SC628A
+static struct sc628a_work_t *sc628a_flash;
+static struct i2c_client *sc628a_client;
+static DECLARE_WAIT_QUEUE_HEAD(sc628a_wait_queue);
+
+struct sc628a_work_t {
+	struct work_struct work;
+};
+
+static const struct i2c_device_id sc628a_i2c_id[] = {
+	{"sc628a", 0},
+	{ }
+};
+
+static int32_t sc628a_i2c_txdata(unsigned short saddr,
+		unsigned char *txdata, int length)
+{
+	struct i2c_msg msg[] = {
+		{
+			.addr = saddr,
+			.flags = 0,
+			.len = length,
+			.buf = txdata,
+		},
+	};
+	if (i2c_transfer(sc628a_client->adapter, msg, 1) < 0) {
+		pr_err("sc628a_i2c_txdata faild 0x%x\n", saddr);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int32_t sc628a_i2c_write_b_flash(uint8_t waddr, uint8_t bdata)
+{
+	int32_t rc = -EFAULT;
+	unsigned char buf[2];
+
+	memset(buf, 0, sizeof(buf));
+	buf[0] = waddr;
+	buf[1] = bdata;
+
+	rc = sc628a_i2c_txdata(sc628a_client->addr, buf, 2);
+	if (rc < 0) {
+		pr_err("i2c_write_b failed, addr = 0x%x, val = 0x%x!\n",
+				waddr, bdata);
+	}
+	return rc;
+}
+
+static int sc628a_init_client(struct i2c_client *client)
+{
+	/* Initialize the MSM_CAMI2C Chip */
+	init_waitqueue_head(&sc628a_wait_queue);
+	return 0;
+}
+
+static int sc628a_i2c_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	int rc = 0;
+	CDBG("sc628a_probe called!\n");
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		pr_err("i2c_check_functionality failed\n");
+		goto probe_failure;
+	}
+
+	sc628a_flash = kzalloc(sizeof(struct sc628a_work_t), GFP_KERNEL);
+	if (!sc628a_flash) {
+		pr_err("kzalloc failed.\n");
+		rc = -ENOMEM;
+		goto probe_failure;
+	}
+
+	i2c_set_clientdata(client, sc628a_flash);
+	sc628a_init_client(client);
+	sc628a_client = client;
+
+	msleep(50);
+
+	CDBG("sc628a_probe successed! rc = %d\n", rc);
+	return 0;
+
+probe_failure:
+	pr_err("sc628a_probe failed! rc = %d\n", rc);
+	return rc;
+}
+
+static struct i2c_driver sc628a_i2c_driver = {
+	.id_table = sc628a_i2c_id,
+	.probe  = sc628a_i2c_probe,
+	.remove = __exit_p(sc628a_i2c_remove),
+	.driver = {
+		.name = "sc628a",
+	},
+};
+#endif
+
+static int config_flash_gpio_table(enum msm_cam_flash_stat stat,
+			struct msm_camera_sensor_strobe_flash_data *sfdata)
+{
+	int rc = 0, i = 0;
+	int msm_cam_flash_gpio_tbl[][2] = {
+		{sfdata->flash_trigger, 1},
+		{sfdata->flash_charge, 1},
+		{sfdata->flash_charge_done, 0}
+	};
+
+	if (stat == MSM_CAM_FLASH_ON) {
+		for (i = 0; i < ARRAY_SIZE(msm_cam_flash_gpio_tbl); i++) {
+			rc = gpio_request(msm_cam_flash_gpio_tbl[i][0],
+							  "CAM_FLASH_GPIO");
+			if (unlikely(rc < 0)) {
+				pr_err("%s not able to get gpio\n", __func__);
+				for (i--; i >= 0; i--)
+					gpio_free(msm_cam_flash_gpio_tbl[i][0]);
+				break;
+			}
+			if (msm_cam_flash_gpio_tbl[i][1])
+				gpio_direction_output(
+					msm_cam_flash_gpio_tbl[i][0], 0);
+			else
+				gpio_direction_input(
+					msm_cam_flash_gpio_tbl[i][0]);
+		}
+	} else {
+		for (i = 0; i < ARRAY_SIZE(msm_cam_flash_gpio_tbl); i++) {
+			gpio_direction_input(msm_cam_flash_gpio_tbl[i][0]);
+			gpio_free(msm_cam_flash_gpio_tbl[i][0]);
+		}
+	}
+	return rc;
+}
+
+int msm_camera_flash_current_driver(
+	struct msm_camera_sensor_flash_current_driver *current_driver,
+	unsigned led_state)
+{
+	int rc = 0;
+#if 1 // AAT1274RWO_T1
+
+	int i = 0;
+	int err = 0;
+	int curt = 5; //current = 100%
+	printk("%s, flash set is %d\n");
+
+	/* Evenly distribute current across all channels */
+	switch (led_state) {
+	case MSM_CAMERA_LED_OFF:
+		pr_err("[FLASH] FLASH OFF\n");
+		//flash off
+		gpio_set_value_cansleep(92, 0);	
+		gpio_set_value_cansleep(84, 0);
+		break;
+
+	case MSM_CAMERA_LED_LOW:
+	 	printk("[FLASH] FLASH MODE\n");
+		//movie mode
+		gpio_set_value_cansleep(92, 0);  //FLEN : LOW..EN
+
+	    for (i = curt; i > 1; i--) //Data
+		   {
+			//gpio on
+			gpio_set_value_cansleep(84, 1);
+			udelay(1);
+			//gpio off
+			gpio_set_value_cansleep(84, 0);
+			udelay(1);
+		}
+			gpio_set_value_cansleep(84, 1); 
+			msleep(2);
+	
+		break;
+
+	case MSM_CAMERA_LED_HIGH:
+	    //flash mode
+		printk("[FLASH] FLASH MOVIE MODE\n");
+		 //movie mode
+		gpio_set_value_cansleep(84, 1);
+		gpio_set_value_cansleep(92, 0);  //FLEN : LOW..EN
+	
+		break;
+
+	default:
+		rc = -EFAULT;
+		break;
+	}
+#endif
+
+	return rc;
+}
+
+
+static int msm_camera_flash_pwm(
+	struct msm_camera_sensor_flash_pwm *pwm,
+	unsigned led_state)
+{
+	int rc = 0;
+	int PWM_PERIOD = USEC_PER_SEC / pwm->freq;
+
+	static struct pwm_device *flash_pwm;
+
+	if (!flash_pwm) {
+		flash_pwm = pwm_request(pwm->channel, "camera-flash");
+		if (flash_pwm == NULL || IS_ERR(flash_pwm)) {
+			pr_err("%s: FAIL pwm_request(): flash_pwm=%p\n",
+			       __func__, flash_pwm);
+			flash_pwm = NULL;
+			return -ENXIO;
+		}
+	}
+
+	switch (led_state) {
+	case MSM_CAMERA_LED_LOW:
+		rc = pwm_config(flash_pwm,
+			(PWM_PERIOD/pwm->max_load)*pwm->low_load,
+			PWM_PERIOD);
+		if (rc >= 0)
+			rc = pwm_enable(flash_pwm);
+		break;
+
+	case MSM_CAMERA_LED_HIGH:
+		rc = pwm_config(flash_pwm,
+			(PWM_PERIOD/pwm->max_load)*pwm->high_load,
+			PWM_PERIOD);
+		if (rc >= 0)
+			rc = pwm_enable(flash_pwm);
+		break;
+
+	case MSM_CAMERA_LED_OFF:
+		pwm_disable(flash_pwm);
+		break;
+
+	default:
+		rc = -EFAULT;
+		break;
+	}
+
+	return rc;
+}
+
+int msm_camera_flash_pmic(
+	struct msm_camera_sensor_flash_pmic *pmic,
+	unsigned led_state)
+{
+	int rc = 0;
+
+	switch (led_state) {
+	case MSM_CAMERA_LED_OFF:
+		rc = pmic->pmic_set_current(pmic->led_src_1, 0);
+		if (pmic->num_of_src > 1)
+			rc = pmic->pmic_set_current(pmic->led_src_2, 0);
+		break;
+
+	case MSM_CAMERA_LED_LOW:
+		rc = pmic->pmic_set_current(pmic->led_src_1,
+				pmic->low_current);
+		if (pmic->num_of_src > 1)
+			rc = pmic->pmic_set_current(pmic->led_src_2, 0);
+		break;
+
+	case MSM_CAMERA_LED_HIGH:
+		rc = pmic->pmic_set_current(pmic->led_src_1,
+			pmic->high_current);
+		if (pmic->num_of_src > 1)
+			rc = pmic->pmic_set_current(pmic->led_src_2,
+				pmic->high_current);
+		break;
+
+	default:
+		rc = -EFAULT;
+		break;
+	}
+	CDBG("flash_set_led_state: return %d\n", rc);
+
+	return rc;
+}
+
+int32_t msm_camera_flash_set_led_state(
+	struct msm_camera_sensor_flash_data *fdata, unsigned led_state)
+{
+	int32_t rc;
+
+	CDBG("flash_set_led_state: %d flash_sr_type=%d\n", led_state,
+	    fdata->flash_src->flash_sr_type);
+
+	if (fdata->flash_type != MSM_CAMERA_FLASH_LED)
+		return -ENODEV;
+
+	switch (fdata->flash_src->flash_sr_type) {
+	case MSM_CAMERA_FLASH_SRC_PMIC:
+		rc = msm_camera_flash_pmic(&fdata->flash_src->_fsrc.pmic_src,
+			led_state);
+		break;
+
+	case MSM_CAMERA_FLASH_SRC_PWM:
+		rc = msm_camera_flash_pwm(&fdata->flash_src->_fsrc.pwm_src,
+			led_state);
+		break;
+
+	case MSM_CAMERA_FLASH_SRC_CURRENT_DRIVER:
+		rc = msm_camera_flash_current_driver(
+			&fdata->flash_src->_fsrc.current_driver_src,
+			led_state);
+		break;
+
+	default:
+		rc = -ENODEV;
+		break;
+	}
+
+	return rc;
+}
+
+static int msm_strobe_flash_xenon_charge(int32_t flash_charge,
+		int32_t charge_enable, uint32_t flash_recharge_duration)
+{
+	gpio_set_value_cansleep(flash_charge, charge_enable);
+	if (charge_enable) {
+		timer_flash.expires = jiffies +
+			msecs_to_jiffies(flash_recharge_duration);
+		/* add timer for the recharge */
+		if (!timer_pending(&timer_flash))
+			add_timer(&timer_flash);
+	} else
+		del_timer_sync(&timer_flash);
+	return 0;
+}
+
+static void strobe_flash_xenon_recharge_handler(unsigned long data)
+{
+	unsigned long flags;
+	struct msm_camera_sensor_strobe_flash_data *sfdata =
+		(struct msm_camera_sensor_strobe_flash_data *)data;
+
+	spin_lock_irqsave(&sfdata->timer_lock, flags);
+	msm_strobe_flash_xenon_charge(sfdata->flash_charge, 1,
+		sfdata->flash_recharge_duration);
+	spin_unlock_irqrestore(&sfdata->timer_lock, flags);
+
+	return;
+}
+
+static irqreturn_t strobe_flash_charge_ready_irq(int irq_num, void *data)
+{
+	struct msm_camera_sensor_strobe_flash_data *sfdata =
+		(struct msm_camera_sensor_strobe_flash_data *)data;
+
+	/* put the charge signal to low */
+	gpio_set_value_cansleep(sfdata->flash_charge, 0);
+
+	return IRQ_HANDLED;
+}
+
+static int msm_strobe_flash_xenon_init(
+	struct msm_camera_sensor_strobe_flash_data *sfdata)
+{
+	unsigned long flags;
+	int rc = 0;
+
+	spin_lock_irqsave(&sfdata->spin_lock, flags);
+	if (!sfdata->state) {
+
+		rc = config_flash_gpio_table(MSM_CAM_FLASH_ON, sfdata);
+		if (rc < 0) {
+			pr_err("%s: gpio_request failed\n", __func__);
+			goto go_out;
+		}
+		rc = request_irq(sfdata->irq, strobe_flash_charge_ready_irq,
+			IRQF_TRIGGER_RISING, "charge_ready", sfdata);
+		if (rc < 0) {
+			pr_err("%s: request_irq failed %d\n", __func__, rc);
+			goto go_out;
+		}
+
+		spin_lock_init(&sfdata->timer_lock);
+		/* setup timer */
+		init_timer(&timer_flash);
+		timer_flash.function = strobe_flash_xenon_recharge_handler;
+		timer_flash.data = (unsigned long)sfdata;
+	}
+	sfdata->state++;
+go_out:
+	spin_unlock_irqrestore(&sfdata->spin_lock, flags);
+
+	return rc;
+}
+
+static int msm_strobe_flash_xenon_release
+(struct msm_camera_sensor_strobe_flash_data *sfdata, int32_t final_release)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&sfdata->spin_lock, flags);
+	if (sfdata->state > 0) {
+		if (final_release)
+			sfdata->state = 0;
+		else
+			sfdata->state--;
+
+		if (!sfdata->state) {
+			free_irq(sfdata->irq, sfdata);
+			config_flash_gpio_table(MSM_CAM_FLASH_OFF, sfdata);
+			if (timer_pending(&timer_flash))
+				del_timer_sync(&timer_flash);
+		}
+	}
+	spin_unlock_irqrestore(&sfdata->spin_lock, flags);
+	return 0;
+}
+
+static void msm_strobe_flash_xenon_fn_init
+	(struct msm_strobe_flash_ctrl *strobe_flash_ptr)
+{
+	strobe_flash_ptr->strobe_flash_init =
+				msm_strobe_flash_xenon_init;
+	strobe_flash_ptr->strobe_flash_charge =
+				msm_strobe_flash_xenon_charge;
+	strobe_flash_ptr->strobe_flash_release =
+				msm_strobe_flash_xenon_release;
+}
+
+int msm_strobe_flash_init(struct msm_sync *sync, uint32_t sftype)
+{
+	int rc = 0;
+	switch (sftype) {
+	case MSM_CAMERA_STROBE_FLASH_XENON:
+		if (sync->sdata->strobe_flash_data) {
+			msm_strobe_flash_xenon_fn_init(&sync->sfctrl);
+			rc = sync->sfctrl.strobe_flash_init(
+			sync->sdata->strobe_flash_data);
+		} else
+			return -ENODEV;
+		break;
+	default:
+		rc = -ENODEV;
+	}
+	return rc;
+}
+
+int msm_strobe_flash_ctrl(struct msm_camera_sensor_strobe_flash_data *sfdata,
+	struct strobe_flash_ctrl_data *strobe_ctrl)
+{
+	int rc = 0;
+	switch (strobe_ctrl->type) {
+	case STROBE_FLASH_CTRL_INIT:
+		if (!sfdata)
+			return -ENODEV;
+		rc = msm_strobe_flash_xenon_init(sfdata);
+		break;
+	case STROBE_FLASH_CTRL_CHARGE:
+		rc = msm_strobe_flash_xenon_charge(sfdata->flash_charge,
+			strobe_ctrl->charge_en,
+			sfdata->flash_recharge_duration);
+		break;
+	case STROBE_FLASH_CTRL_RELEASE:
+		if (sfdata)
+			rc = msm_strobe_flash_xenon_release(sfdata, 0);
+		break;
+	default:
+		pr_err("Invalid Strobe Flash State\n");
+		rc = -EINVAL;
+	}
+	return rc;
+}
+
+int msm_flash_ctrl(struct msm_camera_sensor_info *sdata,
+	struct flash_ctrl_data *flash_info)
+{
+	int rc = 0;
+	switch (flash_info->flashtype) {
+	case LED_FLASH:
+		rc = msm_camera_flash_set_led_state(sdata->flash_data,
+			flash_info->ctrl_data.led_state);
+			break;
+	case STROBE_FLASH:
+		rc = msm_strobe_flash_ctrl(sdata->strobe_flash_data,
+			&(flash_info->ctrl_data.strobe_ctrl));
+		break;
+	default:
+		pr_err("Invalid Flash MODE\n");
+		rc = -EINVAL;
+	}
+	return rc;
+}
diff --git a/drivers/media/video/msm/io/Makefile b/drivers/media/video/msm/io/Makefile
index 64df7fb..04bb4be 100644
--- a/drivers/media/video/msm/io/Makefile
+++ b/drivers/media/video/msm/io/Makefile
@@ -1,6 +1,8 @@
 GCC_VERSION      := $(shell $(CONFIG_SHELL) $(PWD)/scripts/gcc-version.sh $(CROSS_COMPILE)gcc)
 
-obj-$(CONFIG_MSM_CAMERA)   += msm_camera_io_util.o
+ifneq ($(CONFIG_MSM_CAMERA_LEGACY),y)
+  obj-$(CONFIG_MSM_CAMERA)   += msm_camera_io_util.o
+endif
 EXTRA_CFLAGS += -Idrivers/media/video/msm
 ifeq ($(CONFIG_MSM_CAMERA_V4L2),y)
   obj-$(CONFIG_MSM_CAMERA) += msm_camera_i2c.o msm_camera_i2c_mux.o
@@ -8,7 +10,11 @@ ifeq ($(CONFIG_MSM_CAMERA_V4L2),y)
   obj-$(CONFIG_ARCH_MSM8X60) += msm_io_vfe31_v4l2.o
   obj-$(CONFIG_ARCH_MSM7X30) += msm_io_vfe31_v4l2.o
 else
+ifeq ($(CONFIG_MSM_CAMERA_LEGACY),y)
+  obj-$(CONFIG_ARCH_MSM7X27A) += msm_io_7x27a_legacy.o
+else
   obj-$(CONFIG_ARCH_MSM7X27A) += msm_io_7x27a.o
+endif
   obj-$(CONFIG_ARCH_MSM8X60) += msm_io_8x60.o
   obj-$(CONFIG_ARCH_MSM7X30) += msm_io_vfe31.o
 endif
diff --git a/drivers/media/video/msm/io/msm_io_7x27a_legacy.c b/drivers/media/video/msm/io/msm_io_7x27a_legacy.c
new file mode 100644
index 0000000..9be6f56
--- /dev/null
+++ b/drivers/media/video/msm/io/msm_io_7x27a_legacy.c
@@ -0,0 +1,633 @@
+/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/pm_qos.h>
+#include <mach/board.h>
+#include <mach/camera.h>
+#include <mach/camera.h>
+#include <mach/clk.h>
+#include <mach/msm_bus.h>
+#include <mach/msm_bus_board.h>
+
+
+/* MIPI	CSI controller registers */
+#define	MIPI_PHY_CONTROL		0x00000000
+#define	MIPI_PROTOCOL_CONTROL		0x00000004
+#define	MIPI_INTERRUPT_STATUS		0x00000008
+#define	MIPI_INTERRUPT_MASK		0x0000000C
+#define	MIPI_CAMERA_CNTL		0x00000024
+#define	MIPI_CALIBRATION_CONTROL	0x00000018
+#define	MIPI_PHY_D0_CONTROL2		0x00000038
+#define	MIPI_PHY_D1_CONTROL2		0x0000003C
+#define	MIPI_PHY_D2_CONTROL2		0x00000040
+#define	MIPI_PHY_D3_CONTROL2		0x00000044
+#define	MIPI_PHY_CL_CONTROL		0x00000048
+#define	MIPI_PHY_D0_CONTROL		0x00000034
+#define	MIPI_PHY_D1_CONTROL		0x00000020
+#define	MIPI_PHY_D2_CONTROL		0x0000002C
+#define	MIPI_PHY_D3_CONTROL		0x00000030
+#define	MIPI_PWR_CNTL			0x00000054
+
+/*
+ * MIPI_PROTOCOL_CONTROL register bits to enable/disable the features of
+ * CSI Rx Block
+ */
+
+/* DPCM scheme */
+#define	MIPI_PROTOCOL_CONTROL_DPCM_SCHEME_SHFT			0x1e
+/* SW_RST to issue a SW reset to the CSI core */
+#define	MIPI_PROTOCOL_CONTROL_SW_RST_BMSK			0x8000000
+/* To Capture Long packet Header Info in MIPI_PROTOCOL_STATUS register */
+#define	MIPI_PROTOCOL_CONTROL_LONG_PACKET_HEADER_CAPTURE_BMSK	0x200000
+/* Data format for unpacking purpose */
+#define	MIPI_PROTOCOL_CONTROL_DATA_FORMAT_SHFT			0x13
+/* Enable decoding of payload based on data type filed of packet hdr */
+#define	MIPI_PROTOCOL_CONTROL_DECODE_ID_BMSK			0x00000
+/* Enable error correction on packet headers */
+#define	MIPI_PROTOCOL_CONTROL_ECC_EN_BMSK			0x20000
+
+/*
+ * MIPI_CALIBRATION_CONTROL register contains control info for
+ * calibration impledence controller
+*/
+
+/* Enable bit for calibration pad */
+#define	MIPI_CALIBRATION_CONTROL_SWCAL_CAL_EN_SHFT		0x16
+/* With SWCAL_STRENGTH_OVERRIDE_EN, SW_CAL_EN and MANUAL_OVERRIDE_EN
+ * the hardware calibration circuitry associated with CAL_SW_HW_MODE
+ * is bypassed
+*/
+#define	MIPI_CALIBRATION_CONTROL_SWCAL_STRENGTH_OVERRIDE_EN_SHFT	0x15
+/* To indicate the Calibration process is in the control of HW/SW */
+#define	MIPI_CALIBRATION_CONTROL_CAL_SW_HW_MODE_SHFT		0x14
+/* When this is set the strength value of the data and clk lane impedence
+ * termination is updated with MANUAL_STRENGTH settings and calibration
+ * sensing logic is idle.
+*/
+#define	MIPI_CALIBRATION_CONTROL_MANUAL_OVERRIDE_EN_SHFT	0x7
+
+/* Data lane0 control */
+/* T-hs Settle count value  for Rx */
+#define	MIPI_PHY_D0_CONTROL2_SETTLE_COUNT_SHFT			0x18
+/* Rx termination control */
+#define	MIPI_PHY_D0_CONTROL2_HS_TERM_IMP_SHFT			0x10
+/* LP Rx enable */
+#define	MIPI_PHY_D0_CONTROL2_LP_REC_EN_SHFT			0x4
+/*
+ * Enable for error in sync sequence
+ * 1 - one bit error in sync seq
+ * 0 - requires all 8 bit correct seq
+*/
+#define	MIPI_PHY_D0_CONTROL2_ERR_SOT_HS_EN_SHFT			0x3
+
+/* Comments are same as D0 */
+#define	MIPI_PHY_D1_CONTROL2_SETTLE_COUNT_SHFT			0x18
+#define	MIPI_PHY_D1_CONTROL2_HS_TERM_IMP_SHFT			0x10
+#define	MIPI_PHY_D1_CONTROL2_LP_REC_EN_SHFT			0x4
+#define	MIPI_PHY_D1_CONTROL2_ERR_SOT_HS_EN_SHFT			0x3
+
+/* Comments are same as D0 */
+#define	MIPI_PHY_D2_CONTROL2_SETTLE_COUNT_SHFT			0x18
+#define	MIPI_PHY_D2_CONTROL2_HS_TERM_IMP_SHFT			0x10
+#define	MIPI_PHY_D2_CONTROL2_LP_REC_EN_SHFT			0x4
+#define	MIPI_PHY_D2_CONTROL2_ERR_SOT_HS_EN_SHFT			0x3
+
+/* Comments are same as D0 */
+#define	MIPI_PHY_D3_CONTROL2_SETTLE_COUNT_SHFT			0x18
+#define	MIPI_PHY_D3_CONTROL2_HS_TERM_IMP_SHFT			0x10
+#define	MIPI_PHY_D3_CONTROL2_LP_REC_EN_SHFT			0x4
+#define	MIPI_PHY_D3_CONTROL2_ERR_SOT_HS_EN_SHFT			0x3
+
+/* PHY_CL_CTRL programs the parameters of clk lane of CSIRXPHY */
+/* HS Rx termination control */
+#define	MIPI_PHY_CL_CONTROL_HS_TERM_IMP_SHFT			0x18
+/* Start signal for T-hs delay */
+#define	MIPI_PHY_CL_CONTROL_LP_REC_EN_SHFT			0x2
+
+/* PHY DATA lane 0 control */
+/*
+ * HS RX equalizer strength control
+ * 00 - 0db 01 - 3db 10 - 5db 11 - 7db
+*/
+#define	MIPI_PHY_D0_CONTROL_HS_REC_EQ_SHFT			0x1c
+
+/* PHY DATA lane 1 control */
+/* Shutdown signal for MIPI clk phy line */
+#define	MIPI_PHY_D1_CONTROL_MIPI_CLK_PHY_SHUTDOWNB_SHFT		0x9
+/* Shutdown signal for MIPI data phy line */
+#define	MIPI_PHY_D1_CONTROL_MIPI_DATA_PHY_SHUTDOWNB_SHFT	0x8
+
+#define MSM_AXI_QOS_PREVIEW 200000
+#define MSM_AXI_QOS_SNAPSHOT 200000
+#define MSM_AXI_QOS_RECORDING 200000
+
+#define MIPI_PWR_CNTL_ENA	0x07
+#define MIPI_PWR_CNTL_DIS	0x0
+
+static struct clk *camio_cam_clk;
+static struct clk *camio_vfe_clk;
+static struct clk *camio_csi_src_clk;
+static struct clk *camio_csi0_vfe_clk;
+static struct clk *camio_csi1_vfe_clk;
+static struct clk *camio_csi0_clk;
+static struct clk *camio_csi1_clk;
+static struct clk *camio_csi0_pclk;
+static struct clk *camio_csi1_pclk;
+
+static struct msm_camera_io_ext camio_ext;
+static struct msm_camera_io_clk camio_clk;
+static struct platform_device *camio_dev;
+void __iomem *csibase;
+void __iomem *appbase;
+
+
+
+void msm_io_w(u32 data, void __iomem *addr)
+{
+	CDBG("%s: %08x %08x\n", __func__, (int) (addr), (data));
+	/* writel(data), (addr)); is not linux standard syntax */
+	 writel_relaxed((data), (addr));
+}
+
+u32 msm_io_r(void __iomem *addr)
+{
+	/* uint32_t data = readl(addr); */
+	/* is not linux standard syntax */
+	uint32_t data = readl_relaxed(addr);
+	CDBG("%s: %08x %08x\n", __func__, (int) (addr), (data));
+	return data;
+}
+
+void msm_camio_vfe_clk_rate_set(int rate)
+{
+	struct clk *clk = camio_vfe_clk;
+	if (rate > clk_get_rate(clk))
+		clk_set_rate(clk, rate);
+}
+
+int msm_camio_clk_enable(enum msm_camio_clk_type clktype)
+{
+	int rc = 0;
+	struct clk *clk = NULL;
+
+	switch (clktype) {
+	case CAMIO_CAM_MCLK_CLK:
+		clk = clk_get(NULL, "cam_m_clk");
+		camio_cam_clk = clk;
+		msm_camio_clk_rate_set_2(clk, camio_clk.mclk_clk_rate);
+		break;
+	case CAMIO_VFE_CLK:
+		clk = clk_get(NULL, "vfe_clk");
+		camio_vfe_clk = clk;
+		msm_camio_clk_rate_set_2(clk, camio_clk.vfe_clk_rate);
+		break;
+	case CAMIO_CSI0_VFE_CLK:
+		clk = clk_get(&camio_dev->dev, "csi_vfe_clk");
+		camio_csi0_vfe_clk = clk;
+		break;
+	case CAMIO_CSI1_VFE_CLK:
+		clk = clk_get(NULL, "csi_vfe_clk");
+		camio_csi1_vfe_clk = clk;
+		break;
+	case CAMIO_CSI_SRC_CLK:
+		clk = clk_get(NULL, "csi_src_clk");
+		camio_csi_src_clk = clk;
+		break;
+	case CAMIO_CSI0_CLK:
+		clk = clk_get(&camio_dev->dev, "csi_clk");
+		camio_csi0_clk = clk;
+		msm_camio_clk_rate_set_2(clk, 400000000);
+		break;
+	case CAMIO_CSI1_CLK:
+		clk = clk_get(NULL, "csi_clk");
+		camio_csi1_clk = clk;
+		break;
+	case CAMIO_CSI0_PCLK:
+		clk = clk_get(&camio_dev->dev, "csi_pclk");
+		camio_csi0_pclk = clk;
+		break;
+	case CAMIO_CSI1_PCLK:
+		clk = clk_get(NULL, "csi_pclk");
+		camio_csi1_pclk = clk;
+		break;
+	default:
+		break;
+	}
+
+	if (!IS_ERR(clk))
+		clk_enable(clk);
+	else
+		rc = -1;
+	return rc;
+}
+
+int msm_camio_clk_disable(enum msm_camio_clk_type clktype)
+{
+	int rc = 0;
+	struct clk *clk = NULL;
+
+	switch (clktype) {
+	case CAMIO_CAM_MCLK_CLK:
+		clk = camio_cam_clk;
+		break;
+	case CAMIO_VFE_CLK:
+		clk = camio_vfe_clk;
+		break;
+	case CAMIO_CSI_SRC_CLK:
+		clk = camio_csi_src_clk;
+		break;
+	case CAMIO_CSI0_VFE_CLK:
+		clk = camio_csi0_vfe_clk;
+		break;
+	case CAMIO_CSI1_VFE_CLK:
+		clk = camio_csi1_vfe_clk;
+		break;
+	case CAMIO_CSI0_CLK:
+		clk = camio_csi0_clk;
+		break;
+	case CAMIO_CSI1_CLK:
+		clk = camio_csi1_clk;
+		break;
+	case CAMIO_CSI0_PCLK:
+		clk = camio_csi0_pclk;
+		break;
+	case CAMIO_CSI1_PCLK:
+		clk = camio_csi1_pclk;
+		break;
+	default:
+		break;
+	}
+
+	if (!IS_ERR(clk)) {
+		clk_disable(clk);
+		clk_put(clk);
+	} else
+		rc = -1;
+	return rc;
+}
+
+void msm_camio_clk_rate_set(int rate)
+{
+	struct clk *clk = camio_cam_clk;
+	clk_set_rate(clk, rate);
+}
+
+void msm_camio_clk_rate_set_2(struct clk *clk, int rate)
+{
+	clk_set_rate(clk, rate);
+}
+
+void msm_camio_clk_set_min_rate(struct clk *clk, int rate)
+{
+	clk_set_rate(clk, rate);
+}
+
+static irqreturn_t msm_io_csi_irq(int irq_num, void *data)
+{
+	uint32_t irq;
+
+	irq = msm_io_r(csibase + MIPI_INTERRUPT_STATUS);
+	CDBG("%s MIPI_INTERRUPT_STATUS = 0x%x\n", __func__, irq);
+	msm_io_w(irq, csibase + MIPI_INTERRUPT_STATUS);
+
+	/* TODO: Needs to send this info to upper layers */
+	if ((irq >> 19) & 0x1)
+		pr_info("Unsupported packet format is received\n");
+	return IRQ_HANDLED;
+}
+
+int msm_camio_enable(struct platform_device *pdev)
+{
+	int rc = 0;
+	const struct msm_camera_sensor_info *sinfo = pdev->dev.platform_data;
+	struct msm_camera_device_platform_data *camdev = sinfo->pdata;
+	uint32_t val;
+
+	camio_dev = pdev;
+	camio_ext = camdev->ioext;
+	camio_clk = camdev->ioclk;
+
+	msm_camio_clk_enable(CAMIO_VFE_CLK);
+	msm_camio_clk_enable(CAMIO_CSI0_VFE_CLK);
+	msm_camio_clk_enable(CAMIO_CSI1_VFE_CLK);
+	msm_camio_clk_enable(CAMIO_CSI0_CLK);
+	msm_camio_clk_enable(CAMIO_CSI1_CLK);
+	msm_camio_clk_enable(CAMIO_CSI0_PCLK);
+	msm_camio_clk_enable(CAMIO_CSI1_PCLK);
+
+	csibase = ioremap(camio_ext.csiphy, camio_ext.csisz);
+	if (!csibase) {
+		rc = -ENOMEM;
+		goto csi_busy;
+	}
+	rc = request_irq(camio_ext.csiirq, msm_io_csi_irq,
+				IRQF_TRIGGER_RISING, "csi", 0);
+	if (rc < 0)
+		goto csi_irq_fail;
+
+	msleep(20);
+	val = (20 <<
+		MIPI_PHY_D0_CONTROL2_SETTLE_COUNT_SHFT) |
+		(0x0F << MIPI_PHY_D0_CONTROL2_HS_TERM_IMP_SHFT) |
+		(0x0 << MIPI_PHY_D0_CONTROL2_LP_REC_EN_SHFT) |
+		(0x1 << MIPI_PHY_D0_CONTROL2_ERR_SOT_HS_EN_SHFT);
+	CDBG("%s MIPI_PHY_D0_CONTROL2 val=0x%x\n", __func__, val);
+	msm_io_w(val, csibase + MIPI_PHY_D0_CONTROL2);
+	msm_io_w(val, csibase + MIPI_PHY_D1_CONTROL2);
+	msm_io_w(val, csibase + MIPI_PHY_D2_CONTROL2);
+	msm_io_w(val, csibase + MIPI_PHY_D3_CONTROL2);
+
+	val = (0x0F << MIPI_PHY_CL_CONTROL_HS_TERM_IMP_SHFT) |
+		(0x0 << MIPI_PHY_CL_CONTROL_LP_REC_EN_SHFT);
+	CDBG("%s MIPI_PHY_CL_CONTROL val=0x%x\n", __func__, val);
+	msm_io_w(val, csibase + MIPI_PHY_CL_CONTROL);
+
+	appbase = ioremap(camio_ext.appphy,
+		camio_ext.appsz);
+	if (!appbase) {
+		rc = -ENOMEM;
+		goto csi_irq_fail;
+	}
+	return 0;
+
+csi_irq_fail:
+	iounmap(csibase);
+csi_busy:
+	msm_camio_clk_disable(CAMIO_CAM_MCLK_CLK);
+	msm_camio_clk_disable(CAMIO_VFE_CLK);
+	msm_camio_clk_disable(CAMIO_CSI0_VFE_CLK);
+	msm_camio_clk_disable(CAMIO_CSI1_VFE_CLK);
+	msm_camio_clk_disable(CAMIO_CSI0_CLK);
+	msm_camio_clk_disable(CAMIO_CSI1_CLK);
+	msm_camio_clk_disable(CAMIO_CSI0_PCLK);
+	msm_camio_clk_disable(CAMIO_CSI1_PCLK);
+	camdev->camera_gpio_off();
+	return rc;
+}
+
+void msm_camio_disable(struct platform_device *pdev)
+{
+	uint32_t val;
+
+	val = (20 <<
+		MIPI_PHY_D0_CONTROL2_SETTLE_COUNT_SHFT) |
+		(0x0F << MIPI_PHY_D0_CONTROL2_HS_TERM_IMP_SHFT) |
+		(0x0 << MIPI_PHY_D0_CONTROL2_LP_REC_EN_SHFT) |
+		(0x1 << MIPI_PHY_D0_CONTROL2_ERR_SOT_HS_EN_SHFT);
+	CDBG("%s MIPI_PHY_D0_CONTROL2 val=0x%x\n", __func__, val);
+	msm_io_w(val, csibase + MIPI_PHY_D0_CONTROL2);
+	msm_io_w(val, csibase + MIPI_PHY_D1_CONTROL2);
+	msm_io_w(val, csibase + MIPI_PHY_D2_CONTROL2);
+	msm_io_w(val, csibase + MIPI_PHY_D3_CONTROL2);
+
+	val = (0x0F << MIPI_PHY_CL_CONTROL_HS_TERM_IMP_SHFT) |
+		(0x0 << MIPI_PHY_CL_CONTROL_LP_REC_EN_SHFT);
+	CDBG("%s MIPI_PHY_CL_CONTROL val=0x%x\n", __func__, val);
+	msm_io_w(val, csibase + MIPI_PHY_CL_CONTROL);
+	msleep(20);
+
+	free_irq(camio_ext.csiirq, 0);
+	iounmap(csibase);
+	iounmap(appbase);
+	CDBG("disable clocks\n");
+
+	msm_camio_clk_disable(CAMIO_VFE_CLK);
+	msm_camio_clk_disable(CAMIO_CSI0_CLK);
+	msm_camio_clk_disable(CAMIO_CSI1_CLK);
+	msm_camio_clk_disable(CAMIO_CSI0_VFE_CLK);
+	msm_camio_clk_disable(CAMIO_CSI1_VFE_CLK);
+	msm_camio_clk_disable(CAMIO_CSI0_PCLK);
+	msm_camio_clk_disable(CAMIO_CSI1_PCLK);
+}
+
+int msm_camio_sensor_clk_on(struct platform_device *pdev)
+{
+	int rc = 0;
+	const struct msm_camera_sensor_info *sinfo = pdev->dev.platform_data;
+	struct msm_camera_device_platform_data *camdev = sinfo->pdata;
+	camio_dev = pdev;
+	camio_ext = camdev->ioext;
+	camio_clk = camdev->ioclk;
+
+	rc = camdev->camera_gpio_on();
+	if (rc < 0)
+		return rc;
+
+/* In case of GEIM has to control MCLK in own camera driver.        */
+/* Because SR300PC20, camera sensor, doesn't accept to enable MCLK  */
+/* before the power supplied. */
+#if defined(CONFIG_MACH_GEIM) || defined(CONFIG_MACH_JENA)
+	return rc;
+#else
+	return msm_camio_clk_enable(CAMIO_CAM_MCLK_CLK);
+#endif
+}
+
+int msm_camio_sensor_clk_off(struct platform_device *pdev)
+{
+#if defined(CONFIG_MACH_GEIM) || defined(CONFIG_MACH_JENA)
+	int rc = 0;
+#endif
+	const struct msm_camera_sensor_info *sinfo = pdev->dev.platform_data;
+	struct msm_camera_device_platform_data *camdev = sinfo->pdata;
+	camdev->camera_gpio_off();
+
+/* In case of GEIM has to control MCLK in own camera driver.         */
+/* Because SR300PC20, camera sensor, doesn't accept to disable MCLK  */
+/* after turning off the power. */
+#if defined(CONFIG_MACH_GEIM) || defined(CONFIG_MACH_JENA)
+	return rc;
+#else
+	return msm_camio_clk_disable(CAMIO_CAM_MCLK_CLK);
+#endif
+}
+
+void msm_camio_vfe_blk_reset(void)
+{
+	uint32_t val;
+
+	/* do apps reset */
+	val = readl_relaxed(appbase + 0x00000210);
+	val |= 0x1;
+	writel_relaxed(val, appbase + 0x00000210);
+	usleep_range(1000, 2000);
+
+	val = readl_relaxed(appbase + 0x00000210);
+	val &= ~0x1;
+	writel_relaxed(val, appbase + 0x00000210);
+	usleep_range(1000, 2000);
+
+	/* do axi reset */
+	val = readl_relaxed(appbase + 0x00000208);
+	val |= 0x1;
+	writel_relaxed(val, appbase + 0x00000208);
+	usleep_range(1000, 2000);
+
+	val = readl_relaxed(appbase + 0x00000208);
+	val &= ~0x1;
+	writel_relaxed(val, appbase + 0x00000208);
+	mb();
+	usleep_range(1000, 2000);
+	return;
+}
+
+int msm_camio_probe_on(struct platform_device *pdev)
+{
+	int rc = 0;
+	const struct msm_camera_sensor_info *sinfo = pdev->dev.platform_data;
+	struct msm_camera_device_platform_data *camdev = sinfo->pdata;
+	camio_dev = pdev;
+	camio_ext = camdev->ioext;
+	camio_clk = camdev->ioclk;
+
+	msm_camio_clk_enable(CAMIO_CSI0_PCLK);
+	msm_camio_clk_enable(CAMIO_CSI1_PCLK);
+
+	rc = camdev->camera_gpio_on();
+	if (rc < 0)
+		return rc;
+	return msm_camio_clk_enable(CAMIO_CAM_MCLK_CLK);
+}
+
+int msm_camio_probe_off(struct platform_device *pdev)
+{
+	const struct msm_camera_sensor_info *sinfo = pdev->dev.platform_data;
+	struct msm_camera_device_platform_data *camdev = sinfo->pdata;
+	camdev->camera_gpio_off();
+
+	csibase = ioremap(camdev->ioext.csiphy, camdev->ioext.csisz);
+	if (!csibase) {
+		pr_err("ioremap failed for CSIBASE\n");
+		goto ioremap_fail;
+	}
+	msm_io_w(MIPI_PWR_CNTL_DIS, csibase + MIPI_PWR_CNTL);
+	iounmap(csibase);
+ioremap_fail:
+	msm_camio_clk_disable(CAMIO_CSI0_PCLK);
+	msm_camio_clk_disable(CAMIO_CSI1_PCLK);
+	return msm_camio_clk_disable(CAMIO_CAM_MCLK_CLK);
+}
+
+int msm_camio_csi_config(struct msm_camera_csi_params *csi_params)
+{
+	int rc = 0;
+	uint32_t val = 0;
+
+	CDBG("msm_camio_csi_config\n");
+
+	/* Enable error correction for DATA lane. Applies to all data lanes */
+	msm_io_w(0x4, csibase + MIPI_PHY_CONTROL);
+
+	msm_io_w(MIPI_PROTOCOL_CONTROL_SW_RST_BMSK,
+		csibase + MIPI_PROTOCOL_CONTROL);
+
+	val = MIPI_PROTOCOL_CONTROL_LONG_PACKET_HEADER_CAPTURE_BMSK |
+		MIPI_PROTOCOL_CONTROL_DECODE_ID_BMSK |
+		MIPI_PROTOCOL_CONTROL_ECC_EN_BMSK;
+	val |= (uint32_t)(csi_params->data_format) <<
+		MIPI_PROTOCOL_CONTROL_DATA_FORMAT_SHFT;
+	val |= csi_params->dpcm_scheme <<
+		MIPI_PROTOCOL_CONTROL_DPCM_SCHEME_SHFT;
+	CDBG("%s MIPI_PROTOCOL_CONTROL val=0x%x\n", __func__, val);
+	msm_io_w(val, csibase + MIPI_PROTOCOL_CONTROL);
+
+	val = (0x1 << MIPI_CALIBRATION_CONTROL_SWCAL_CAL_EN_SHFT) |
+		(0x1 <<
+		MIPI_CALIBRATION_CONTROL_SWCAL_STRENGTH_OVERRIDE_EN_SHFT) |
+		(0x1 << MIPI_CALIBRATION_CONTROL_CAL_SW_HW_MODE_SHFT) |
+		(0x1 << MIPI_CALIBRATION_CONTROL_MANUAL_OVERRIDE_EN_SHFT);
+	CDBG("%s MIPI_CALIBRATION_CONTROL val=0x%x\n", __func__, val);
+	msm_io_w(val, csibase + MIPI_CALIBRATION_CONTROL);
+
+	val = (csi_params->settle_cnt <<
+		MIPI_PHY_D0_CONTROL2_SETTLE_COUNT_SHFT) |
+		(0x0F << MIPI_PHY_D0_CONTROL2_HS_TERM_IMP_SHFT) |
+		(0x1 << MIPI_PHY_D0_CONTROL2_LP_REC_EN_SHFT) |
+		(0x1 << MIPI_PHY_D0_CONTROL2_ERR_SOT_HS_EN_SHFT);
+	CDBG("%s MIPI_PHY_D0_CONTROL2 val=0x%x\n", __func__, val);
+	msm_io_w(val, csibase + MIPI_PHY_D0_CONTROL2);
+	msm_io_w(val, csibase + MIPI_PHY_D1_CONTROL2);
+	msm_io_w(val, csibase + MIPI_PHY_D2_CONTROL2);
+	msm_io_w(val, csibase + MIPI_PHY_D3_CONTROL2);
+
+
+	val = (0x0F << MIPI_PHY_CL_CONTROL_HS_TERM_IMP_SHFT) |
+		(0x1 << MIPI_PHY_CL_CONTROL_LP_REC_EN_SHFT);
+	CDBG("%s MIPI_PHY_CL_CONTROL val=0x%x\n", __func__, val);
+	msm_io_w(val, csibase + MIPI_PHY_CL_CONTROL);
+
+	val = 0 << MIPI_PHY_D0_CONTROL_HS_REC_EQ_SHFT;
+	msm_io_w(val, csibase + MIPI_PHY_D0_CONTROL);
+
+	val = (0x1 << MIPI_PHY_D1_CONTROL_MIPI_CLK_PHY_SHUTDOWNB_SHFT) |
+		(0x1 << MIPI_PHY_D1_CONTROL_MIPI_DATA_PHY_SHUTDOWNB_SHFT);
+	CDBG("%s MIPI_PHY_D1_CONTROL val=0x%x\n", __func__, val);
+	msm_io_w(val, csibase + MIPI_PHY_D1_CONTROL);
+
+	msm_io_w(0x00000000, csibase + MIPI_PHY_D2_CONTROL);
+	msm_io_w(0x00000000, csibase + MIPI_PHY_D3_CONTROL);
+
+	/* program number of lanes and lane mapping */
+	switch (csi_params->lane_cnt) {
+	case 1:
+		msm_io_w(csi_params->lane_assign << 8 | 0x4,
+			csibase + MIPI_CAMERA_CNTL);
+		break;
+	case 2:
+		msm_io_w(csi_params->lane_assign << 8 | 0x5,
+			csibase + MIPI_CAMERA_CNTL);
+		break;
+	case 3:
+		msm_io_w(csi_params->lane_assign << 8 | 0x6,
+			csibase + MIPI_CAMERA_CNTL);
+		break;
+	case 4:
+		msm_io_w(csi_params->lane_assign << 8 | 0x7,
+			csibase + MIPI_CAMERA_CNTL);
+		break;
+	}
+
+	msm_io_w(0xFFFFF3FF, csibase + MIPI_INTERRUPT_MASK);
+	/*clear IRQ bits - write 1 clears the status*/
+	msm_io_w(0xFFFFF3FF, csibase + MIPI_INTERRUPT_STATUS);
+
+	return rc;
+}
+
+void msm_camio_set_perf_lvl(enum msm_bus_perf_setting perf_setting)
+{
+	switch (perf_setting) {
+	case S_INIT:
+		add_axi_qos();
+		break;
+	case S_PREVIEW:
+		update_axi_qos(MSM_AXI_QOS_PREVIEW);
+		break;
+	case S_VIDEO:
+		update_axi_qos(MSM_AXI_QOS_RECORDING);
+		break;
+	case S_CAPTURE:
+		update_axi_qos(MSM_AXI_QOS_SNAPSHOT);
+		break;
+	case S_DEFAULT:
+		update_axi_qos(PM_QOS_DEFAULT_VALUE);
+		break;
+	case S_EXIT:
+		release_axi_qos();
+		break;
+	default:
+		CDBG("%s: INVALID CASE\n", __func__);
+	}
+}
diff --git a/drivers/media/video/msm/msm_camera_legacy.c b/drivers/media/video/msm/msm_camera_legacy.c
new file mode 100644
index 0000000..60463bc
--- /dev/null
+++ b/drivers/media/video/msm/msm_camera_legacy.c
@@ -0,0 +1,4060 @@
+/* Copyright (c) 2009-2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+//FIXME: most allocations need not be GFP_ATOMIC
+/* FIXME: management of mutexes */
+/* FIXME: msm_pmem_region_lookup return values */
+/* FIXME: way too many copy to/from user */
+/* FIXME: does region->active mean free */
+/* FIXME: check limits on command lenghts passed from userspace */
+/* FIXME: __msm_release: which queues should we flush when opencnt != 0 */
+
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <mach/board.h>
+
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/list.h>
+#include <linux/uaccess.h>
+#include <linux/android_pmem.h>
+#include <linux/poll.h>
+#include <media/msm_camera.h>
+#include <mach/camera.h>
+#include <linux/syscalls.h>
+#include <linux/hrtimer.h>
+#include <mach/cpuidle.h>
+DEFINE_MUTEX(ctrl_cmd_lock);
+
+#define CAMERA_STOP_VIDEO 58
+spinlock_t pp_prev_spinlock;
+spinlock_t pp_stereocam_spinlock;
+spinlock_t st_frame_spinlock;
+
+#define ERR_USER_COPY(to) pr_err("%s(%d): copy %s user\n", \
+				__func__, __LINE__, ((to) ? "to" : "from"))
+#define ERR_COPY_FROM_USER() ERR_USER_COPY(0)
+#define ERR_COPY_TO_USER() ERR_USER_COPY(1)
+#define MAX_PMEM_CFG_BUFFERS 10
+
+static struct class *msm_class;
+static dev_t msm_devno;
+static LIST_HEAD(msm_sensors);
+struct  msm_control_device *g_v4l2_control_device;
+int g_v4l2_opencnt;
+static int camera_node;
+static enum msm_camera_type camera_type[MSM_MAX_CAMERA_SENSORS];
+static uint32_t sensor_mount_angle[MSM_MAX_CAMERA_SENSORS];
+
+static const char *vfe_config_cmd[] = {
+	"CMD_GENERAL",  /* 0 */
+	"CMD_AXI_CFG_OUT1",
+	"CMD_AXI_CFG_SNAP_O1_AND_O2",
+	"CMD_AXI_CFG_OUT2",
+	"CMD_PICT_T_AXI_CFG",
+	"CMD_PICT_M_AXI_CFG",  /* 5 */
+	"CMD_RAW_PICT_AXI_CFG",
+	"CMD_FRAME_BUF_RELEASE",
+	"CMD_PREV_BUF_CFG",
+	"CMD_SNAP_BUF_RELEASE",
+	"CMD_SNAP_BUF_CFG",  /* 10 */
+	"CMD_STATS_DISABLE",
+	"CMD_STATS_AEC_AWB_ENABLE",
+	"CMD_STATS_AF_ENABLE",
+	"CMD_STATS_AEC_ENABLE",
+	"CMD_STATS_AWB_ENABLE",  /* 15 */
+	"CMD_STATS_ENABLE",
+	"CMD_STATS_AXI_CFG",
+	"CMD_STATS_AEC_AXI_CFG",
+	"CMD_STATS_AF_AXI_CFG",
+	"CMD_STATS_AWB_AXI_CFG",  /* 20 */
+	"CMD_STATS_RS_AXI_CFG",
+	"CMD_STATS_CS_AXI_CFG",
+	"CMD_STATS_IHIST_AXI_CFG",
+	"CMD_STATS_SKIN_AXI_CFG",
+	"CMD_STATS_BUF_RELEASE",  /* 25 */
+	"CMD_STATS_AEC_BUF_RELEASE",
+	"CMD_STATS_AF_BUF_RELEASE",
+	"CMD_STATS_AWB_BUF_RELEASE",
+	"CMD_STATS_RS_BUF_RELEASE",
+	"CMD_STATS_CS_BUF_RELEASE",  /* 30 */
+	"CMD_STATS_IHIST_BUF_RELEASE",
+	"CMD_STATS_SKIN_BUF_RELEASE",
+	"UPDATE_STATS_INVALID",
+	"CMD_AXI_CFG_SNAP_GEMINI",
+	"CMD_AXI_CFG_SNAP",  /* 35 */
+	"CMD_AXI_CFG_PREVIEW",
+	"CMD_AXI_CFG_VIDEO",
+	"CMD_STATS_IHIST_ENABLE",
+	"CMD_STATS_RS_ENABLE",
+	"CMD_STATS_CS_ENABLE",  /* 40 */
+	"CMD_VPE",
+	"CMD_AXI_CFG_VPE",
+	"CMD_AXI_CFG_SNAP_VPE",
+	"CMD_AXI_CFG_SNAP_THUMB_VPE",
+};
+#define __CONTAINS(r, v, l, field) ({				\
+	typeof(r) __r = r;					\
+	typeof(v) __v = v;					\
+	typeof(v) __e = __v + l;				\
+	int res = __v >= __r->field &&				\
+		__e <= __r->field + __r->len;			\
+	res;							\
+})
+
+#define CONTAINS(r1, r2, field) ({				\
+	typeof(r2) __r2 = r2;					\
+	__CONTAINS(r1, __r2->field, __r2->len, field);		\
+})
+
+#define IN_RANGE(r, v, field) ({				\
+	typeof(r) __r = r;					\
+	typeof(v) __vv = v;					\
+	int res = ((__vv >= __r->field) &&			\
+		(__vv < (__r->field + __r->len)));		\
+	res;							\
+})
+
+#define OVERLAPS(r1, r2, field) ({				\
+	typeof(r1) __r1 = r1;					\
+	typeof(r2) __r2 = r2;					\
+	typeof(__r2->field) __v = __r2->field;			\
+	typeof(__v) __e = __v + __r2->len - 1;			\
+	int res = (IN_RANGE(__r1, __v, field) ||		\
+		   IN_RANGE(__r1, __e, field));                 \
+	res;							\
+})
+
+static inline void free_qcmd(struct msm_queue_cmd *qcmd)
+{
+	if (!qcmd || !atomic_read(&qcmd->on_heap))
+		return;
+	if (!atomic_sub_return(1, &qcmd->on_heap))
+		kfree(qcmd);
+}
+
+static void msm_region_init(struct msm_sync *sync)
+{
+	INIT_HLIST_HEAD(&sync->pmem_frames);
+	INIT_HLIST_HEAD(&sync->pmem_stats);
+	spin_lock_init(&sync->pmem_frame_spinlock);
+	spin_lock_init(&sync->pmem_stats_spinlock);
+}
+
+static void msm_queue_init(struct msm_device_queue *queue, const char *name)
+{
+	spin_lock_init(&queue->lock);
+	queue->len = 0;
+	queue->max = 0;
+	queue->name = name;
+	INIT_LIST_HEAD(&queue->list);
+	init_waitqueue_head(&queue->wait);
+}
+
+static void msm_enqueue(struct msm_device_queue *queue,
+		struct list_head *entry)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&queue->lock, flags);
+	queue->len++;
+	if (queue->len > queue->max) {
+		queue->max = queue->len;
+		CDBG("%s: queue %s new max is %d\n", __func__,
+			queue->name, queue->max);
+	}
+	list_add_tail(entry, &queue->list);
+	wake_up(&queue->wait);
+	CDBG("%s: woke up %s\n", __func__, queue->name);
+	spin_unlock_irqrestore(&queue->lock, flags);
+}
+
+static void msm_enqueue_vpe(struct msm_device_queue *queue,
+		struct list_head *entry)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&queue->lock, flags);
+	queue->len++;
+	if (queue->len > queue->max) {
+		queue->max = queue->len;
+		CDBG("%s: queue %s new max is %d\n", __func__,
+			queue->name, queue->max);
+	}
+	list_add_tail(entry, &queue->list);
+    CDBG("%s: woke up %s\n", __func__, queue->name);
+	spin_unlock_irqrestore(&queue->lock, flags);
+}
+
+#define msm_dequeue(queue, member) ({				\
+	unsigned long flags;					\
+	struct msm_device_queue *__q = (queue);			\
+	struct msm_queue_cmd *qcmd = 0;				\
+	spin_lock_irqsave(&__q->lock, flags);			\
+	if (!list_empty(&__q->list)) {				\
+		__q->len--;					\
+		qcmd = list_first_entry(&__q->list,		\
+				struct msm_queue_cmd, member);	\
+		if ((qcmd) && (&qcmd->member) && (&qcmd->member.next))	\
+			list_del_init(&qcmd->member);			\
+	}							\
+	spin_unlock_irqrestore(&__q->lock, flags);	\
+	qcmd;							\
+})
+
+#define msm_delete_entry(queue, member, q_cmd) ({		\
+	unsigned long flags;					\
+	struct msm_device_queue *__q = (queue);			\
+	struct msm_queue_cmd *qcmd = 0;				\
+	spin_lock_irqsave(&__q->lock, flags);			\
+	if (!list_empty(&__q->list)) {				\
+		list_for_each_entry(qcmd, &__q->list, member)	\
+		if (qcmd == q_cmd) {				\
+			__q->len--;				\
+			list_del_init(&qcmd->member);		\
+			CDBG("msm_delete_entry, match found\n");\
+			kfree(q_cmd);				\
+			q_cmd = NULL;				\
+			break;					\
+		}						\
+	}							\
+	spin_unlock_irqrestore(&__q->lock, flags);		\
+	q_cmd;		\
+})
+
+#define msm_queue_drain(queue, member) do {			\
+	unsigned long flags;					\
+	struct msm_device_queue *__q = (queue);			\
+	struct msm_queue_cmd *qcmd;				\
+	spin_lock_irqsave(&__q->lock, flags);			\
+	while (!list_empty(&__q->list)) {			\
+		__q->len--;					\
+		qcmd = list_first_entry(&__q->list,		\
+			struct msm_queue_cmd, member);		\
+		if (qcmd) {					\
+			if ((&qcmd->member) && (&qcmd->member.next))	\
+				list_del_init(&qcmd->member);		\
+			free_qcmd(qcmd);				\
+		}							\
+	}							\
+	spin_unlock_irqrestore(&__q->lock, flags);		\
+} while (0)
+
+static int check_overlap(struct hlist_head *ptype,
+			unsigned long paddr,
+			unsigned long len)
+{
+	struct msm_pmem_region *region;
+	struct msm_pmem_region t = { .paddr = paddr, .len = len };
+	struct hlist_node *node;
+
+	hlist_for_each_entry(region, node, ptype, list) {
+		if (CONTAINS(region, &t, paddr) ||
+				CONTAINS(&t, region, paddr) ||
+				OVERLAPS(region, &t, paddr)) {
+			CDBG(" region (PHYS %p len %ld)"
+				" clashes with registered region"
+				" (paddr %p len %ld)\n",
+				(void *)t.paddr, t.len,
+				(void *)region->paddr, region->len);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int check_pmem_info(struct msm_pmem_info *info, int len)
+{
+	if (info->offset < len &&
+	    info->offset + info->len <= len &&
+	    info->y_off < len &&
+	    info->cbcr_off < len)
+		return 0;
+
+	pr_err("%s: check failed: off %d len %d y %d cbcr %d (total len %d)\n",
+		__func__,
+		info->offset,
+		info->len,
+		info->y_off,
+		info->cbcr_off,
+		len);
+	return -EINVAL;
+}
+static int msm_pmem_table_add(struct hlist_head *ptype,
+	struct msm_pmem_info *info, spinlock_t* pmem_spinlock,
+	struct msm_sync *sync)
+{
+	struct file *file;
+	unsigned long paddr;
+	unsigned long kvstart;
+	unsigned long len;
+	int rc;
+	struct msm_pmem_region *region;
+	unsigned long flags;
+
+
+	rc = get_pmem_file(info->fd, &paddr, &kvstart, &len, &file);
+	if (rc < 0) {
+		pr_err("%s: get_pmem_file fd %d error %d\n",
+			__func__,
+			info->fd, rc);
+		return rc;
+	}
+
+	if (!info->len)
+		info->len = len;
+
+	rc = check_pmem_info(info, len);
+	if (rc < 0)
+		return rc;
+
+	paddr += info->offset;
+	len = info->len;
+
+	spin_lock_irqsave(pmem_spinlock, flags);
+	if (check_overlap(ptype, paddr, len) < 0) {
+		spin_unlock_irqrestore(pmem_spinlock, flags);
+		return -EINVAL;
+	}
+	spin_unlock_irqrestore(pmem_spinlock, flags);
+
+
+	region = kmalloc(sizeof(struct msm_pmem_region), GFP_KERNEL);
+	if (!region)
+		return -ENOMEM;
+
+	spin_lock_irqsave(pmem_spinlock, flags);
+	INIT_HLIST_NODE(&region->list);
+
+	region->paddr = paddr;
+	region->len = len;
+	region->file = file;
+	memcpy(&region->info, info, sizeof(region->info));
+
+	hlist_add_head(&(region->list), ptype);
+	spin_unlock_irqrestore(pmem_spinlock, flags);
+	CDBG("%s: type %d, paddr 0x%lx, vaddr 0x%lx\n",
+		__func__, info->type, paddr, (unsigned long)info->vaddr);
+
+	return 0;
+}
+
+/* return of 0 means failure */
+static uint8_t msm_pmem_region_lookup(struct hlist_head *ptype,
+	int pmem_type, struct msm_pmem_region *reg, uint8_t maxcount,
+	spinlock_t *pmem_spinlock)
+{
+	struct msm_pmem_region *region;
+	struct msm_pmem_region *regptr;
+	struct hlist_node *node, *n;
+	unsigned long flags = 0;
+
+	uint8_t rc = 0;
+
+	regptr = reg;
+	spin_lock_irqsave(pmem_spinlock, flags);
+	hlist_for_each_entry_safe(region, node, n, ptype, list) {
+		if (region->info.type == pmem_type && region->info.active) {
+			*regptr = *region;
+			rc += 1;
+			if (rc >= maxcount)
+				break;
+			regptr++;
+		}
+	}
+	spin_unlock_irqrestore(pmem_spinlock, flags);
+	/* After lookup failure, dump all the list entries...*/
+	if (rc == 0) {
+		pr_err("%s: pmem_type = %d\n", __func__, pmem_type);
+		hlist_for_each_entry_safe(region, node, n, ptype, list) {
+			pr_err("listed region->info.type = %d, active = %d",
+				region->info.type, region->info.active);
+		}
+
+	}
+	return rc;
+}
+
+static uint8_t msm_pmem_region_lookup_2(struct hlist_head *ptype,
+					int pmem_type,
+					struct msm_pmem_region *reg,
+					uint8_t maxcount,
+					spinlock_t *pmem_spinlock)
+{
+	struct msm_pmem_region *region;
+	struct msm_pmem_region *regptr;
+	struct hlist_node *node, *n;
+	uint8_t rc = 0;
+	unsigned long flags = 0;
+	regptr = reg;
+	spin_lock_irqsave(pmem_spinlock, flags);
+	hlist_for_each_entry_safe(region, node, n, ptype, list) {
+		CDBG("%s:info.type=%d, pmem_type = %d,"
+						"info.active = %d\n",
+		__func__, region->info.type, pmem_type, region->info.active);
+
+		if (region->info.type == pmem_type && region->info.active) {
+			CDBG("%s:info.type=%d, pmem_type = %d,"
+							"info.active = %d,\n",
+				__func__, region->info.type, pmem_type,
+				region->info.active);
+			*regptr = *region;
+			region->info.type = MSM_PMEM_VIDEO;
+			rc += 1;
+			if (rc >= maxcount)
+				break;
+			regptr++;
+		}
+	}
+	spin_unlock_irqrestore(pmem_spinlock, flags);
+	return rc;
+}
+
+static int msm_pmem_frame_ptov_lookup(struct msm_sync *sync,
+		unsigned long pyaddr,
+		unsigned long pcbcraddr,
+		struct msm_pmem_info *pmem_info,
+		int clear_active)
+{
+	struct msm_pmem_region *region;
+	struct hlist_node *node, *n;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&sync->pmem_frame_spinlock, flags);
+	hlist_for_each_entry_safe(region, node, n, &sync->pmem_frames, list) {
+		if (pyaddr == (region->paddr + region->info.y_off) &&
+				pcbcraddr == (region->paddr +
+						region->info.cbcr_off) &&
+				region->info.active) {
+			/* offset since we could pass vaddr inside
+			 * a registerd pmem buffer
+			 */
+			memcpy(pmem_info, &region->info, sizeof(*pmem_info));
+			if (clear_active)
+				region->info.active = 0;
+			spin_unlock_irqrestore(&sync->pmem_frame_spinlock,
+				flags);
+			return 0;
+		}
+	}
+	/* After lookup failure, dump all the list entries... */
+	pr_err("%s, for pyaddr 0x%lx, pcbcraddr 0x%lx\n",
+			__func__, pyaddr, pcbcraddr);
+	hlist_for_each_entry_safe(region, node, n, &sync->pmem_frames, list) {
+		pr_err("listed pyaddr 0x%lx, pcbcraddr 0x%lx, active = %d",
+				(region->paddr + region->info.y_off),
+				(region->paddr + region->info.cbcr_off),
+				region->info.active);
+	}
+
+	spin_unlock_irqrestore(&sync->pmem_frame_spinlock, flags);
+	return -EINVAL;
+}
+
+static int msm_pmem_frame_ptov_lookup2(struct msm_sync *sync,
+		unsigned long pyaddr,
+		struct msm_pmem_info *pmem_info,
+		int clear_active)
+{
+	struct msm_pmem_region *region;
+	struct hlist_node *node, *n;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&sync->pmem_frame_spinlock, flags);
+	hlist_for_each_entry_safe(region, node, n, &sync->pmem_frames, list) {
+		if (pyaddr == (region->paddr + region->info.y_off) &&
+				region->info.active) {
+			/* offset since we could pass vaddr inside
+			 * a registerd pmem buffer
+			 */
+			memcpy(pmem_info, &region->info, sizeof(*pmem_info));
+			if (clear_active)
+				region->info.active = 0;
+			spin_unlock_irqrestore(&sync->pmem_frame_spinlock,
+				flags);
+			return 0;
+		}
+	}
+
+	spin_unlock_irqrestore(&sync->pmem_frame_spinlock, flags);
+	return -EINVAL;
+}
+
+static unsigned long msm_pmem_stats_ptov_lookup(struct msm_sync *sync,
+		unsigned long addr, int *fd)
+{
+	struct msm_pmem_region *region;
+	struct hlist_node *node, *n;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&sync->pmem_stats_spinlock, flags);
+	hlist_for_each_entry_safe(region, node, n, &sync->pmem_stats, list) {
+		if (addr == region->paddr && region->info.active) {
+			/* offset since we could pass vaddr inside a
+			 * registered pmem buffer */
+			*fd = region->info.fd;
+			region->info.active = 0;
+			spin_unlock_irqrestore(&sync->pmem_stats_spinlock,
+				flags);
+			return (unsigned long)(region->info.vaddr);
+		}
+	}
+	/* After lookup failure, dump all the list entries... */
+	pr_err("%s, lookup failure, for paddr 0x%lx\n",
+			__func__, addr);
+	hlist_for_each_entry_safe(region, node, n, &sync->pmem_stats, list) {
+		pr_err("listed paddr 0x%lx, active = %d",
+				region->paddr,
+				region->info.active);
+	}
+	spin_unlock_irqrestore(&sync->pmem_stats_spinlock, flags);
+
+	return 0;
+}
+
+static unsigned long msm_pmem_frame_vtop_lookup(struct msm_sync *sync,
+		unsigned long buffer,
+		uint32_t yoff, uint32_t cbcroff, int fd, int change_flag)
+{
+	struct msm_pmem_region *region;
+	struct hlist_node *node, *n;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&sync->pmem_frame_spinlock, flags);
+	hlist_for_each_entry_safe(region,
+		node, n, &sync->pmem_frames, list) {
+		if (((unsigned long)(region->info.vaddr) == buffer) &&
+				(region->info.y_off == yoff) &&
+				(region->info.cbcr_off == cbcroff) &&
+				(region->info.fd == fd) &&
+				(region->info.active == 0)) {
+			if (change_flag)
+				region->info.active = 1;
+			spin_unlock_irqrestore(&sync->pmem_frame_spinlock,
+				flags);
+			return region->paddr;
+		}
+	}
+	/* After lookup failure, dump all the list entries... */
+	pr_err("%s, failed for vaddr 0x%lx, yoff %d cbcroff %d\n",
+			__func__, buffer, yoff, cbcroff);
+	hlist_for_each_entry_safe(region, node, n, &sync->pmem_frames, list) {
+		pr_err("listed vaddr 0x%p, cbcroff %d, active = %d",
+				(region->info.vaddr),
+				(region->info.cbcr_off),
+				region->info.active);
+	}
+
+	spin_unlock_irqrestore(&sync->pmem_frame_spinlock, flags);
+
+	return 0;
+}
+
+static unsigned long msm_pmem_stats_vtop_lookup(
+		struct msm_sync *sync,
+		unsigned long buffer,
+		int fd)
+{
+	struct msm_pmem_region *region;
+	struct hlist_node *node, *n;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&sync->pmem_stats_spinlock, flags);
+	hlist_for_each_entry_safe(region, node, n, &sync->pmem_stats, list) {
+		if (((unsigned long)(region->info.vaddr) == buffer) &&
+				(region->info.fd == fd) &&
+				region->info.active == 0) {
+			region->info.active = 1;
+			spin_unlock_irqrestore(&sync->pmem_stats_spinlock,
+				flags);
+			return region->paddr;
+		}
+	}
+	/* After lookup failure, dump all the list entries... */
+	pr_err("%s,look up error for vaddr %ld\n",
+			__func__, buffer);
+	hlist_for_each_entry_safe(region, node, n, &sync->pmem_stats, list) {
+		pr_err("listed vaddr 0x%p, active = %d",
+				region->info.vaddr,
+				region->info.active);
+	}
+	spin_unlock_irqrestore(&sync->pmem_stats_spinlock, flags);
+
+	return 0;
+}
+
+static int __msm_pmem_table_del(struct msm_sync *sync,
+		struct msm_pmem_info *pinfo)
+{
+	int rc = 0;
+	struct msm_pmem_region *region;
+	struct hlist_node *node, *n;
+	unsigned long flags = 0;
+
+	switch (pinfo->type) {
+	case MSM_PMEM_PREVIEW:
+	case MSM_PMEM_THUMBNAIL:
+	case MSM_PMEM_MAINIMG:
+	case MSM_PMEM_RAW_MAINIMG:
+	case MSM_PMEM_C2D:
+	case MSM_PMEM_MAINIMG_VPE:
+	case MSM_PMEM_THUMBNAIL_VPE:
+		spin_lock_irqsave(&sync->pmem_frame_spinlock, flags);
+		hlist_for_each_entry_safe(region, node, n,
+			&sync->pmem_frames, list) {
+
+			if (pinfo->type == region->info.type &&
+					pinfo->vaddr == region->info.vaddr &&
+					pinfo->fd == region->info.fd) {
+				hlist_del(node);
+				put_pmem_file(region->file);
+				kfree(region);
+				CDBG("%s: type %d, vaddr  0x%p\n",
+					__func__, pinfo->type, pinfo->vaddr);
+			}
+		}
+		spin_unlock_irqrestore(&sync->pmem_frame_spinlock, flags);
+		break;
+
+	case MSM_PMEM_VIDEO:
+	case MSM_PMEM_VIDEO_VPE:
+		spin_lock_irqsave(&sync->pmem_frame_spinlock, flags);
+		hlist_for_each_entry_safe(region, node, n,
+			&sync->pmem_frames, list) {
+
+			if (((region->info.type == MSM_PMEM_VIDEO) ||
+				(region->info.type == MSM_PMEM_VIDEO_VPE)) &&
+				pinfo->vaddr == region->info.vaddr &&
+				pinfo->fd == region->info.fd) {
+				hlist_del(node);
+				put_pmem_file(region->file);
+				kfree(region);
+				CDBG("%s: type %d, vaddr  0x%p\n",
+					__func__, pinfo->type, pinfo->vaddr);
+			}
+		}
+		spin_unlock_irqrestore(&sync->pmem_frame_spinlock, flags);
+		break;
+
+	case MSM_PMEM_AEC_AWB:
+	case MSM_PMEM_AF:
+		spin_lock_irqsave(&sync->pmem_stats_spinlock, flags);
+		hlist_for_each_entry_safe(region, node, n,
+			&sync->pmem_stats, list) {
+
+			if (pinfo->type == region->info.type &&
+					pinfo->vaddr == region->info.vaddr &&
+					pinfo->fd == region->info.fd) {
+				hlist_del(node);
+				put_pmem_file(region->file);
+				kfree(region);
+				CDBG("%s: type %d, vaddr  0x%p\n",
+					__func__, pinfo->type, pinfo->vaddr);
+			}
+		}
+		spin_unlock_irqrestore(&sync->pmem_stats_spinlock, flags);
+		break;
+
+	default:
+		rc = -EINVAL;
+		break;
+	}
+
+	return rc;
+}
+
+static int msm_pmem_table_del(struct msm_sync *sync, void __user *arg)
+{
+	struct msm_pmem_info info;
+
+	if (copy_from_user(&info, arg, sizeof(info))) {
+		ERR_COPY_FROM_USER();
+		return -EFAULT;
+	}
+
+	return __msm_pmem_table_del(sync, &info);
+}
+
+static int __msm_get_frame(struct msm_sync *sync,
+		struct msm_frame *frame)
+{
+	int rc = 0;
+
+	struct msm_pmem_info pmem_info;
+	struct msm_queue_cmd *qcmd = NULL;
+	struct msm_vfe_resp *vdata;
+	struct msm_vfe_phy_info *pphy;
+
+	qcmd = msm_dequeue(&sync->frame_q, list_frame);
+
+	if (!qcmd) {
+		pr_err("%s: no preview frame.\n", __func__);
+		return -EAGAIN;
+	}
+
+	if ((!qcmd->command) && (qcmd->error_code & MSM_CAMERA_ERR_MASK)) {
+		frame->error_code = qcmd->error_code;
+		pr_err("%s: fake frame with camera error code = %d\n",
+			__func__, frame->error_code);
+		goto err;
+	}
+
+	vdata = (struct msm_vfe_resp *)(qcmd->command);
+	pphy = &vdata->phy;
+
+	rc = msm_pmem_frame_ptov_lookup(sync,
+			pphy->y_phy,
+			pphy->cbcr_phy,
+			&pmem_info,
+			1); /* Clear the active flag */
+
+	if (rc < 0) {
+		pr_err("%s: cannot get frame, invalid lookup address "
+			"y %x cbcr %x\n",
+			__func__,
+			pphy->y_phy,
+			pphy->cbcr_phy);
+		goto err;
+	}
+
+	frame->ts = qcmd->ts;
+	frame->buffer = (unsigned long)pmem_info.vaddr;
+	frame->y_off = pmem_info.y_off;
+	frame->cbcr_off = pmem_info.cbcr_off;
+	frame->fd = pmem_info.fd;
+	frame->path = vdata->phy.output_id;
+	frame->frame_id = vdata->phy.frame_id;
+
+	CDBG("%s: y %x, cbcr %x, qcmd %x, virt_addr %x\n",
+		__func__,
+		pphy->y_phy, pphy->cbcr_phy, (int) qcmd, (int) frame->buffer);
+
+err:
+	free_qcmd(qcmd);
+	return rc;
+}
+
+static int msm_get_frame(struct msm_sync *sync, void __user *arg)
+{
+	int rc = 0;
+	struct msm_frame frame;
+
+	if (copy_from_user(&frame,
+				arg,
+				sizeof(struct msm_frame))) {
+		ERR_COPY_FROM_USER();
+		return -EFAULT;
+	}
+
+	rc = __msm_get_frame(sync, &frame);
+	if (rc < 0)
+		return rc;
+
+	mutex_lock(&sync->lock);
+	if (sync->croplen && (!sync->stereocam_enabled)) {
+		if (frame.croplen != sync->croplen) {
+			pr_err("%s: invalid frame croplen %d,"
+				"expecting %d\n",
+				__func__,
+				frame.croplen,
+				sync->croplen);
+			mutex_unlock(&sync->lock);
+			return -EINVAL;
+		}
+
+		if (copy_to_user((void *)frame.cropinfo,
+				sync->cropinfo,
+				sync->croplen)) {
+			ERR_COPY_TO_USER();
+			mutex_unlock(&sync->lock);
+			return -EFAULT;
+		}
+	}
+
+	if (sync->fdroiinfo.info) {
+		if (copy_to_user((void *)frame.roi_info.info,
+			sync->fdroiinfo.info,
+			sync->fdroiinfo.info_len)) {
+			ERR_COPY_TO_USER();
+			mutex_unlock(&sync->lock);
+			return -EFAULT;
+		}
+	}
+
+	if (sync->stereocam_enabled) {
+		frame.stcam_conv_value = sync->stcam_conv_value;
+		frame.stcam_quality_ind = sync->stcam_quality_ind;
+	}
+
+	if (copy_to_user((void *)arg,
+				&frame, sizeof(struct msm_frame))) {
+		ERR_COPY_TO_USER();
+		rc = -EFAULT;
+	}
+
+	mutex_unlock(&sync->lock);
+	CDBG("%s: got frame\n", __func__);
+
+	return rc;
+}
+
+static int msm_enable_vfe(struct msm_sync *sync, void __user *arg)
+{
+	int rc = -EIO;
+	struct camera_enable_cmd cfg;
+
+	if (copy_from_user(&cfg,
+			arg,
+			sizeof(struct camera_enable_cmd))) {
+		ERR_COPY_FROM_USER();
+		return -EFAULT;
+	}
+
+	if (sync->vfefn.vfe_enable)
+		rc = sync->vfefn.vfe_enable(&cfg);
+
+	return rc;
+}
+
+static int msm_disable_vfe(struct msm_sync *sync, void __user *arg)
+{
+	int rc = -EIO;
+	struct camera_enable_cmd cfg;
+
+	if (copy_from_user(&cfg,
+			arg,
+			sizeof(struct camera_enable_cmd))) {
+		ERR_COPY_FROM_USER();
+		return -EFAULT;
+	}
+
+	if (sync->vfefn.vfe_disable)
+		rc = sync->vfefn.vfe_disable(&cfg, NULL);
+
+	return rc;
+}
+
+static struct msm_queue_cmd *__msm_control(struct msm_sync *sync,
+		struct msm_device_queue *queue,
+		struct msm_queue_cmd *qcmd,
+		int timeout)
+{
+	int rc;
+
+	CDBG("Inside __msm_control\n");
+	if (sync->event_q.len <= 100 && sync->frame_q.len <= 100) {
+		/* wake up config thread */
+		msm_enqueue(&sync->event_q, &qcmd->list_config);
+	} else {
+		pr_err("%s, Error Queue limit exceeded e_q = %d, f_q = %d\n",
+			__func__, sync->event_q.len, sync->frame_q.len);
+		free_qcmd(qcmd);
+		return NULL;
+	}
+	if (!queue)
+		return NULL;
+
+	/* wait for config status */
+	CDBG("Waiting for config status \n");
+	rc = wait_event_interruptible_timeout(
+			queue->wait,
+			!list_empty_careful(&queue->list),
+			timeout);
+	CDBG("Waiting over for config status\n");
+	if (list_empty_careful(&queue->list)) {
+		if (!rc) {
+			rc = -ETIMEDOUT;
+			pr_err("%s: wait_event error %d\n", __func__, rc);
+			return ERR_PTR(rc);
+		} else if (rc < 0) {
+			pr_err("%s: wait_event error %d\n", __func__, rc);
+			if (msm_delete_entry(&sync->event_q,
+				list_config, qcmd)) {
+				sync->ignore_qcmd = true;
+				sync->ignore_qcmd_type =
+					(int16_t)((struct msm_ctrl_cmd *)
+					(qcmd->command))->type;
+			}
+			return ERR_PTR(rc);
+		}
+	}
+	qcmd = msm_dequeue(queue, list_control);
+	BUG_ON(!qcmd);
+	CDBG("__msm_control done \n");
+	return qcmd;
+}
+
+static struct msm_queue_cmd *__msm_control_nb(struct msm_sync *sync,
+					struct msm_queue_cmd *qcmd_to_copy)
+{
+	/* Since this is a non-blocking command, we cannot use qcmd_to_copy and
+	 * its data, since they are on the stack.  We replicate them on the heap
+	 * and mark them on_heap so that they get freed when the config thread
+	 * dequeues them.
+	 */
+
+	struct msm_ctrl_cmd *udata;
+	struct msm_ctrl_cmd *udata_to_copy = qcmd_to_copy->command;
+
+	struct msm_queue_cmd *qcmd =
+			kmalloc(sizeof(*qcmd_to_copy) +
+				sizeof(*udata_to_copy) +
+				udata_to_copy->length,
+				GFP_KERNEL);
+	if (!qcmd) {
+		pr_err("%s: out of memory\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+	*qcmd = *qcmd_to_copy;
+	udata = qcmd->command = qcmd + 1;
+	memcpy(udata, udata_to_copy, sizeof(*udata));
+	udata->value = udata + 1;
+	memcpy(udata->value, udata_to_copy->value, udata_to_copy->length);
+
+	atomic_set(&qcmd->on_heap, 1);
+
+	/* qcmd_resp will be set to NULL */
+	return __msm_control(sync, NULL, qcmd, 0);
+}
+
+static int msm_control(struct msm_control_device *ctrl_pmsm,
+			int block,
+			void __user *arg)
+{
+	int rc = 0;
+
+	struct msm_sync *sync = ctrl_pmsm->pmsm->sync;
+	void __user *uptr;
+	struct msm_ctrl_cmd udata_resp;
+	struct msm_queue_cmd *qcmd_resp = NULL;
+	uint8_t data[max_control_command_size];
+	struct msm_ctrl_cmd *udata;
+	struct msm_queue_cmd *qcmd =
+		kmalloc(sizeof(struct msm_queue_cmd) +
+			sizeof(struct msm_ctrl_cmd), GFP_ATOMIC);
+	if (!qcmd) {
+		pr_err("%s: out of memory\n", __func__);
+		return -ENOMEM;
+	}
+	udata = (struct msm_ctrl_cmd *)(qcmd + 1);
+	atomic_set(&(qcmd->on_heap), 1);
+	CDBG("Inside msm_control\n");
+	if (copy_from_user(udata, arg, sizeof(struct msm_ctrl_cmd))) {
+		ERR_COPY_FROM_USER();
+		rc = -EFAULT;
+		goto end;
+	}
+
+	uptr = udata->value;
+	udata->value = data;
+	qcmd->type = MSM_CAM_Q_CTRL;
+	qcmd->command = udata;
+
+	if (udata->length) {
+		if (udata->length > sizeof(data)) {
+			pr_err("%s: user data too large (%d, max is %d)\n",
+					__func__,
+					udata->length,
+					sizeof(data));
+			rc = -EIO;
+			goto end;
+		}
+		if (copy_from_user(udata->value, uptr, udata->length)) {
+			ERR_COPY_FROM_USER();
+			rc = -EFAULT;
+			goto end;
+		}
+	}
+
+	if (unlikely(!block)) {
+		qcmd_resp = __msm_control_nb(sync, qcmd);
+		goto end;
+	}
+
+	qcmd_resp = __msm_control(sync,
+				&ctrl_pmsm->ctrl_q,
+				qcmd, msecs_to_jiffies(5000));
+
+	/* ownership of qcmd will be transfered to event queue */
+	qcmd = NULL;
+
+	if (!qcmd_resp || IS_ERR(qcmd_resp)) {
+		/* Do not free qcmd_resp here.  If the config thread read it,
+		 * then it has already been freed, and we timed out because
+		 * we did not receive a MSM_CAM_IOCTL_CTRL_CMD_DONE.  If the
+		 * config thread itself is blocked and not dequeueing commands,
+		 * then it will either eventually unblock and process them,
+		 * or when it is killed, qcmd will be freed in
+		 * msm_release_config.
+		 */
+		rc = PTR_ERR(qcmd_resp);
+		qcmd_resp = NULL;
+		goto end;
+	}
+
+	if (qcmd_resp->command) {
+		udata_resp = *(struct msm_ctrl_cmd *)qcmd_resp->command;
+		if (udata_resp.length > 0) {
+			if (copy_to_user(uptr,
+					 udata_resp.value,
+					 udata_resp.length)) {
+				ERR_COPY_TO_USER();
+				rc = -EFAULT;
+				goto end;
+			}
+		}
+		udata_resp.value = uptr;
+
+		if (copy_to_user((void *)arg, &udata_resp,
+				sizeof(struct msm_ctrl_cmd))) {
+			ERR_COPY_TO_USER();
+			rc = -EFAULT;
+			goto end;
+		}
+	}
+
+end:
+	free_qcmd(qcmd);
+	CDBG("%s: done rc = %d\n", __func__, rc);
+	return rc;
+}
+
+/* Divert frames for post-processing by delivering them to the config thread;
+ * when post-processing is done, it will return the frame to the frame thread.
+ */
+static int msm_divert_frame(struct msm_sync *sync,
+		struct msm_vfe_resp *data,
+		struct msm_stats_event_ctrl *se)
+{
+	struct msm_pmem_info pinfo;
+	struct msm_postproc buf;
+	int rc;
+
+	CDBG("%s: Frame PP sync->pp_mask %d\n", __func__, sync->pp_mask);
+
+	if (!(sync->pp_mask & PP_PREV)  && !(sync->pp_mask & PP_SNAP)) {
+		pr_err("%s: diverting frame, not in PP_PREV or PP_SNAP!\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	rc = msm_pmem_frame_ptov_lookup(sync, data->phy.y_phy,
+			data->phy.cbcr_phy, &pinfo,
+			0); /* do not clear the active flag */
+
+	if (rc < 0) {
+		pr_err("%s: msm_pmem_frame_ptov_lookup failed\n", __func__);
+		return rc;
+	}
+
+	buf.fmain.buffer = (unsigned long)pinfo.vaddr;
+	buf.fmain.y_off = pinfo.y_off;
+	buf.fmain.cbcr_off = pinfo.cbcr_off;
+	buf.fmain.fd = pinfo.fd;
+
+	CDBG("%s: buf 0x%x fd %d\n", __func__, (unsigned int)buf.fmain.buffer,
+		 buf.fmain.fd);
+	if (copy_to_user((void *)(se->stats_event.data),
+			&(buf.fmain), sizeof(struct msm_frame))) {
+		ERR_COPY_TO_USER();
+		return -EFAULT;
+	}
+	return 0;
+}
+
+/* Divert stereo frames for post-processing by delivering
+ * them to the config thread.
+ */
+static int msm_divert_st_frame(struct msm_sync *sync,
+	struct msm_vfe_resp *data, struct msm_stats_event_ctrl *se, int path)
+{
+	struct msm_pmem_info pinfo;
+	struct msm_st_frame buf;
+	struct video_crop_t *crop = NULL;
+	int rc = 0;
+
+	if (se->stats_event.msg_id == OUTPUT_TYPE_ST_L) {
+		buf.type = OUTPUT_TYPE_ST_L;
+	} else if (se->stats_event.msg_id == OUTPUT_TYPE_ST_R) {
+		buf.type = OUTPUT_TYPE_ST_R;
+	} else {
+		if (se->resptype == MSM_CAM_RESP_STEREO_OP_1) {
+			rc = msm_pmem_frame_ptov_lookup(sync, data->phy.y_phy,
+					data->phy.cbcr_phy, &pinfo,
+					1);  /* do clear the active flag */
+			buf.buf_info.path = path;
+		} else if (se->resptype == MSM_CAM_RESP_STEREO_OP_2) {
+			rc = msm_pmem_frame_ptov_lookup(sync, data->phy.y_phy,
+					data->phy.cbcr_phy, &pinfo,
+					0); /* do not clear the active flag */
+			buf.buf_info.path = path;
+		} else
+			CDBG("%s: Invalid resptype = %d\n", __func__,
+				se->resptype);
+
+		if (rc < 0) {
+			CDBG("%s: msm_pmem_frame_ptov_lookup failed\n",
+				__func__);
+			return rc;
+		}
+
+		buf.type = OUTPUT_TYPE_ST_D;
+
+		if (sync->cropinfo != NULL) {
+			crop = sync->cropinfo;
+			switch (path) {
+			case OUTPUT_TYPE_P:
+			case OUTPUT_TYPE_T: {
+				buf.L.stCropInfo.in_w = crop->in1_w;
+				buf.L.stCropInfo.in_h = crop->in1_h;
+				buf.L.stCropInfo.out_w = crop->out1_w;
+				buf.L.stCropInfo.out_h = crop->out1_h;
+				buf.R.stCropInfo = buf.L.stCropInfo;
+				break;
+			}
+
+			case OUTPUT_TYPE_V:
+			case OUTPUT_TYPE_S: {
+				buf.L.stCropInfo.in_w = crop->in2_w;
+				buf.L.stCropInfo.in_h = crop->in2_h;
+				buf.L.stCropInfo.out_w = crop->out2_w;
+				buf.L.stCropInfo.out_h = crop->out2_h;
+				buf.R.stCropInfo = buf.L.stCropInfo;
+				break;
+			}
+			default: {
+				pr_warning("%s: invalid frame path %d\n",
+					__func__, path);
+				break;
+			}
+			}
+		} else {
+			buf.L.stCropInfo.in_w = 0;
+			buf.L.stCropInfo.in_h = 0;
+			buf.L.stCropInfo.out_w = 0;
+			buf.L.stCropInfo.out_h = 0;
+			buf.R.stCropInfo = buf.L.stCropInfo;
+		}
+
+		/* hardcode for now. */
+		if ((path == OUTPUT_TYPE_S) || (path == OUTPUT_TYPE_T))
+			buf.packing = sync->sctrl.s_snap_packing;
+		else
+			buf.packing = sync->sctrl.s_video_packing;
+
+		buf.buf_info.buffer = (unsigned long)pinfo.vaddr;
+		buf.buf_info.phy_offset = pinfo.offset;
+		buf.buf_info.y_off = pinfo.y_off;
+		buf.buf_info.cbcr_off = pinfo.cbcr_off;
+		buf.buf_info.fd = pinfo.fd;
+
+		CDBG("%s: buf 0x%x fd %d\n", __func__,
+			(unsigned int)buf.buf_info.buffer, buf.buf_info.fd);
+	}
+
+	if (copy_to_user((void *)(se->stats_event.data),
+			&buf, sizeof(struct msm_st_frame))) {
+		ERR_COPY_TO_USER();
+		return -EFAULT;
+	}
+	return 0;
+}
+
+static int msm_get_stats(struct msm_sync *sync, void __user *arg)
+{
+	int rc = 0;
+
+	struct msm_stats_event_ctrl se;
+
+	struct msm_queue_cmd *qcmd = NULL;
+	struct msm_ctrl_cmd  *ctrl = NULL;
+	struct msm_vfe_resp  *data = NULL;
+	struct msm_vpe_resp  *vpe_data = NULL;
+	struct msm_stats_buf stats;
+
+	if (copy_from_user(&se, arg,
+			sizeof(struct msm_stats_event_ctrl))) {
+		ERR_COPY_FROM_USER();
+		pr_err("%s, ERR_COPY_FROM_USER\n", __func__);
+		return -EFAULT;
+	}
+
+	rc = 0;
+
+	qcmd = msm_dequeue(&sync->event_q, list_config);
+	if (!qcmd) {
+		/* Should be associated with wait_event
+			error -512 from __msm_control*/
+		pr_err("%s, qcmd is Null\n", __func__);
+		rc = -ETIMEDOUT;
+		return rc;
+	}
+
+	CDBG("%s: received from DSP %d\n", __func__, qcmd->type);
+
+	switch (qcmd->type) {
+	case MSM_CAM_Q_VPE_MSG:
+		/* Complete VPE response. */
+		vpe_data = (struct msm_vpe_resp *)(qcmd->command);
+		se.resptype = MSM_CAM_RESP_STEREO_OP_2;
+		se.stats_event.type   = vpe_data->evt_msg.type;
+		se.stats_event.msg_id = vpe_data->evt_msg.msg_id;
+		se.stats_event.len    = vpe_data->evt_msg.len;
+
+		if (vpe_data->type == VPE_MSG_OUTPUT_ST_L) {
+			CDBG("%s: Change msg_id to OUTPUT_TYPE_ST_L\n",
+				__func__);
+			se.stats_event.msg_id = OUTPUT_TYPE_ST_L;
+			rc = msm_divert_st_frame(sync, data, &se,
+				OUTPUT_TYPE_V);
+		} else if (vpe_data->type == VPE_MSG_OUTPUT_ST_R) {
+			CDBG("%s: Change msg_id to OUTPUT_TYPE_ST_R\n",
+				__func__);
+			se.stats_event.msg_id = OUTPUT_TYPE_ST_R;
+			rc = msm_divert_st_frame(sync, data, &se,
+				OUTPUT_TYPE_V);
+		} else {
+			pr_warning("%s: invalid vpe_data->type = %d\n",
+				__func__, vpe_data->type);
+		}
+		break;
+
+	case MSM_CAM_Q_VFE_EVT:
+	case MSM_CAM_Q_VFE_MSG:
+		data = (struct msm_vfe_resp *)(qcmd->command);
+
+		/* adsp event and message */
+		se.resptype = MSM_CAM_RESP_STAT_EVT_MSG;
+
+		/* 0 - msg from aDSP, 1 - event from mARM */
+		se.stats_event.type   = data->evt_msg.type;
+		se.stats_event.msg_id = data->evt_msg.msg_id;
+		se.stats_event.len    = data->evt_msg.len;
+		se.stats_event.frame_id = data->evt_msg.frame_id;
+
+		CDBG("%s: qcmd->type %d length %d msd_id %d\n", __func__,
+			qcmd->type,
+			se.stats_event.len,
+			se.stats_event.msg_id);
+
+		if (data->type == VFE_MSG_COMMON) {
+			stats.status_bits = data->stats_msg.status_bits;
+			if (data->stats_msg.aec_buff) {
+				stats.aec.buff =
+				msm_pmem_stats_ptov_lookup(sync,
+						data->stats_msg.aec_buff,
+						&(stats.aec.fd));
+				if (!stats.aec.buff) {
+					pr_err("%s: msm_pmem_stats_ptov_lookup error\n",
+						__func__);
+					rc = -EINVAL;
+					goto failure;
+				}
+
+			} else {
+				stats.aec.buff = 0;
+			}
+			if (data->stats_msg.awb_buff) {
+				stats.awb.buff =
+				msm_pmem_stats_ptov_lookup(sync,
+						data->stats_msg.awb_buff,
+						&(stats.awb.fd));
+				if (!stats.awb.buff) {
+					pr_err("%s: msm_pmem_stats_ptov_lookup error\n",
+						__func__);
+					rc = -EINVAL;
+					goto failure;
+				}
+
+			} else {
+				stats.awb.buff = 0;
+			}
+			if (data->stats_msg.af_buff) {
+				stats.af.buff =
+				msm_pmem_stats_ptov_lookup(sync,
+						data->stats_msg.af_buff,
+						&(stats.af.fd));
+				if (!stats.af.buff) {
+					pr_err("%s: msm_pmem_stats_ptov_lookup error\n",
+						__func__);
+					rc = -EINVAL;
+					goto failure;
+				}
+
+			} else {
+				stats.af.buff = 0;
+			}
+			if (data->stats_msg.ihist_buff) {
+				stats.ihist.buff =
+				msm_pmem_stats_ptov_lookup(sync,
+						data->stats_msg.ihist_buff,
+						&(stats.ihist.fd));
+				if (!stats.ihist.buff) {
+					pr_err("%s: msm_pmem_stats_ptov_lookup error\n",
+						__func__);
+					rc = -EINVAL;
+					goto failure;
+				}
+
+			} else {
+				stats.ihist.buff = 0;
+			}
+
+			if (data->stats_msg.rs_buff) {
+				stats.rs.buff =
+				msm_pmem_stats_ptov_lookup(sync,
+						data->stats_msg.rs_buff,
+						&(stats.rs.fd));
+				if (!stats.rs.buff) {
+					pr_err("%s: msm_pmem_stats_ptov_lookup error\n",
+						__func__);
+					rc = -EINVAL;
+					goto failure;
+				}
+
+			} else {
+				stats.rs.buff = 0;
+			}
+
+			if (data->stats_msg.cs_buff) {
+				stats.cs.buff =
+				msm_pmem_stats_ptov_lookup(sync,
+						data->stats_msg.cs_buff,
+						&(stats.cs.fd));
+				if (!stats.cs.buff) {
+					pr_err("%s: msm_pmem_stats_ptov_lookup error\n",
+						__func__);
+					rc = -EINVAL;
+					goto failure;
+				}
+			} else {
+				stats.cs.buff = 0;
+			}
+
+			se.stats_event.frame_id = data->phy.frame_id;
+			if (copy_to_user((void *)(se.stats_event.data),
+					&stats,
+					sizeof(struct msm_stats_buf))) {
+				ERR_COPY_TO_USER();
+				rc = -EFAULT;
+				goto failure;
+			}
+		} else if ((data->type >= VFE_MSG_STATS_AEC) &&
+			(data->type <=  VFE_MSG_STATS_WE)) {
+			/* the check above includes all stats type. */
+			stats.buffer =
+				msm_pmem_stats_ptov_lookup(sync,
+						data->phy.sbuf_phy,
+						&(stats.fd));
+			if (!stats.buffer) {
+					pr_err("%s: msm_pmem_stats_ptov_lookup error\n",
+						__func__);
+					rc = -EINVAL;
+					goto failure;
+			}
+			se.stats_event.frame_id = data->phy.frame_id;
+			if (copy_to_user((void *)(se.stats_event.data),
+					&stats,
+					sizeof(struct msm_stats_buf))) {
+				ERR_COPY_TO_USER();
+				rc = -EFAULT;
+				goto failure;
+			}
+		} else if ((data->evt_msg.len > 0) &&
+				(data->type == VFE_MSG_GENERAL)) {
+			if (copy_to_user((void *)(se.stats_event.data),
+					data->evt_msg.data,
+					data->evt_msg.len)) {
+				ERR_COPY_TO_USER();
+				rc = -EFAULT;
+				goto failure;
+			}
+		} else {
+			if (sync->stereocam_enabled) {
+				if (data->type == VFE_MSG_OUTPUT_P) {
+					CDBG("%s: Preview mark as st op 1\n",
+						__func__);
+					se.resptype = MSM_CAM_RESP_STEREO_OP_1;
+					rc = msm_divert_st_frame(sync, data,
+						&se, OUTPUT_TYPE_P);
+					break;
+				} else if (data->type == VFE_MSG_OUTPUT_V) {
+					CDBG("%s: Video mark as st op 2\n",
+						__func__);
+					se.resptype = MSM_CAM_RESP_STEREO_OP_2;
+					rc = msm_divert_st_frame(sync, data,
+						&se, OUTPUT_TYPE_V);
+					break;
+				} else if (data->type == VFE_MSG_OUTPUT_S) {
+					CDBG("%s: Main img mark as st op 2\n",
+						__func__);
+					se.resptype = MSM_CAM_RESP_STEREO_OP_2;
+					rc = msm_divert_st_frame(sync, data,
+						&se, OUTPUT_TYPE_S);
+					break;
+				} else if (data->type == VFE_MSG_OUTPUT_T) {
+					CDBG("%s: Thumb img mark as st op 2\n",
+						__func__);
+					se.resptype = MSM_CAM_RESP_STEREO_OP_2;
+					rc = msm_divert_st_frame(sync, data,
+						&se, OUTPUT_TYPE_T);
+					break;
+				} else
+					CDBG("%s: VFE_MSG Fall Through\n",
+						__func__);
+			}
+			if ((sync->pp_frame_avail == 1) &&
+				(sync->pp_mask & PP_PREV) &&
+				(data->type == VFE_MSG_OUTPUT_P)) {
+					CDBG("%s:%d:preiew PP\n",
+					__func__, __LINE__);
+					se.stats_event.frame_id =
+							data->phy.frame_id;
+					rc = msm_divert_frame(sync, data, &se);
+					sync->pp_frame_avail = 0;
+			} else {
+				if ((sync->pp_mask & PP_PREV) &&
+					(data->type == VFE_MSG_OUTPUT_P)) {
+					se.stats_event.frame_id =
+							data->phy.frame_id;
+					free_qcmd(qcmd);
+					return 0;
+				} else
+					CDBG("%s:indication type is %d\n",
+						__func__, data->type);
+			}
+			if (sync->pp_mask & PP_SNAP)
+				if (data->type == VFE_MSG_OUTPUT_S ||
+					data->type == VFE_MSG_OUTPUT_T)
+					rc = msm_divert_frame(sync, data, &se);
+		}
+		break;
+
+	case MSM_CAM_Q_CTRL:
+		/* control command from control thread */
+		ctrl = (struct msm_ctrl_cmd *)(qcmd->command);
+
+		CDBG("%s: qcmd->type %d length %d\n", __func__,
+			qcmd->type, ctrl->length);
+
+		if (ctrl->length > 0) {
+			if (copy_to_user((void *)(se.ctrl_cmd.value),
+						ctrl->value,
+						ctrl->length)) {
+				ERR_COPY_TO_USER();
+				rc = -EFAULT;
+				goto failure;
+			}
+		}
+
+		se.resptype = MSM_CAM_RESP_CTRL;
+
+		/* what to control */
+		se.ctrl_cmd.type = ctrl->type;
+		se.ctrl_cmd.length = ctrl->length;
+		se.ctrl_cmd.resp_fd = ctrl->resp_fd;
+		break;
+
+	case MSM_CAM_Q_V4L2_REQ:
+		/* control command from v4l2 client */
+		ctrl = (struct msm_ctrl_cmd *)(qcmd->command);
+		if (ctrl->length > 0) {
+			if (copy_to_user((void *)(se.ctrl_cmd.value),
+					ctrl->value, ctrl->length)) {
+				ERR_COPY_TO_USER();
+				rc = -EFAULT;
+				goto failure;
+			}
+		}
+
+		/* 2 tells config thread this is v4l2 request */
+		se.resptype = MSM_CAM_RESP_V4L2;
+
+		/* what to control */
+		se.ctrl_cmd.type   = ctrl->type;
+		se.ctrl_cmd.length = ctrl->length;
+		break;
+
+	default:
+		rc = -EFAULT;
+		goto failure;
+	} /* switch qcmd->type */
+	if (copy_to_user((void *)arg, &se, sizeof(se))) {
+		ERR_COPY_TO_USER();
+		rc = -EFAULT;
+		goto failure;
+	}
+
+failure:
+	free_qcmd(qcmd);
+
+	CDBG("%s: %d\n", __func__, rc);
+	return rc;
+}
+
+static int msm_ctrl_cmd_done(struct msm_control_device *ctrl_pmsm,
+		void __user *arg)
+{
+	void __user *uptr;
+	struct msm_queue_cmd *qcmd = &ctrl_pmsm->qcmd;
+	struct msm_ctrl_cmd *command = &ctrl_pmsm->ctrl;
+
+	if (copy_from_user(command, arg, sizeof(*command))) {
+		ERR_COPY_FROM_USER();
+		return -EFAULT;
+	}
+
+	atomic_set(&qcmd->on_heap, 0);
+	qcmd->command = command;
+	uptr = command->value;
+
+	if (command->length > 0) {
+		command->value = ctrl_pmsm->ctrl_data;
+		if (command->length > sizeof(ctrl_pmsm->ctrl_data)) {
+			pr_err("%s: user data %d is too big (max %d)\n",
+				__func__, command->length,
+				sizeof(ctrl_pmsm->ctrl_data));
+			return -EINVAL;
+		}
+
+		if (copy_from_user(command->value,
+					uptr,
+					command->length)) {
+			ERR_COPY_FROM_USER();
+			return -EFAULT;
+		}
+	} else
+		command->value = NULL;
+
+	/* Ignore the command if the ctrl cmd has
+	   return back due to signaling */
+	/* Should be associated with wait_event
+	   error -512 from __msm_control*/
+	if (ctrl_pmsm->pmsm->sync->ignore_qcmd == true &&
+	   ctrl_pmsm->pmsm->sync->ignore_qcmd_type == (int16_t)command->type) {
+		ctrl_pmsm->pmsm->sync->ignore_qcmd = false;
+		ctrl_pmsm->pmsm->sync->ignore_qcmd_type = -1;
+	} else /* wake up control thread */
+		msm_enqueue(&ctrl_pmsm->ctrl_q, &qcmd->list_control);
+
+	return 0;
+}
+
+static int msm_config_vpe(struct msm_sync *sync, void __user *arg)
+{
+	struct msm_vpe_cfg_cmd cfgcmd;
+	if (copy_from_user(&cfgcmd, arg, sizeof(cfgcmd))) {
+		ERR_COPY_FROM_USER();
+		return -EFAULT;
+	}
+	CDBG("%s: cmd_type %s\n", __func__, vfe_config_cmd[cfgcmd.cmd_type]);
+	switch (cfgcmd.cmd_type) {
+	case CMD_VPE:
+		return sync->vpefn.vpe_config(&cfgcmd, NULL);
+	default:
+		pr_err("%s: unknown command type %d\n",
+			__func__, cfgcmd.cmd_type);
+	}
+	return -EINVAL;
+}
+
+static int msm_config_vfe(struct msm_sync *sync, void __user *arg)
+{
+	struct msm_vfe_cfg_cmd cfgcmd;
+	struct msm_pmem_region region[8];
+	struct axidata axi_data;
+
+	if (!sync->vfefn.vfe_config) {
+		pr_err("%s: no vfe_config!\n", __func__);
+		return -EIO;
+	}
+
+	if (copy_from_user(&cfgcmd, arg, sizeof(cfgcmd))) {
+		ERR_COPY_FROM_USER();
+		return -EFAULT;
+	}
+
+	memset(&axi_data, 0, sizeof(axi_data));
+	CDBG("%s: cmd_type %s\n", __func__, vfe_config_cmd[cfgcmd.cmd_type]);
+	switch (cfgcmd.cmd_type) {
+	case CMD_STATS_ENABLE:
+		axi_data.bufnum1 =
+			msm_pmem_region_lookup(&sync->pmem_stats,
+				MSM_PMEM_AEC_AWB, &region[0],
+				NUM_STAT_OUTPUT_BUFFERS,
+				&sync->pmem_stats_spinlock);
+		axi_data.bufnum2 =
+			msm_pmem_region_lookup(&sync->pmem_stats,
+				MSM_PMEM_AF, &region[axi_data.bufnum1],
+				NUM_STAT_OUTPUT_BUFFERS,
+				&sync->pmem_stats_spinlock);
+		if (!axi_data.bufnum1 || !axi_data.bufnum2) {
+			pr_err("%s: pmem region lookup error\n", __func__);
+			return -EINVAL;
+		}
+		axi_data.region = &region[0];
+		return sync->vfefn.vfe_config(&cfgcmd, &axi_data);
+	case CMD_STATS_AF_ENABLE:
+		axi_data.bufnum1 =
+			msm_pmem_region_lookup(&sync->pmem_stats,
+				MSM_PMEM_AF, &region[0],
+				NUM_STAT_OUTPUT_BUFFERS,
+				&sync->pmem_stats_spinlock);
+		if (!axi_data.bufnum1) {
+			pr_err("%s %d: pmem region lookup error\n",
+				__func__, __LINE__);
+			return -EINVAL;
+		}
+		axi_data.region = &region[0];
+		return sync->vfefn.vfe_config(&cfgcmd, &axi_data);
+	case CMD_STATS_AEC_AWB_ENABLE:
+		axi_data.bufnum1 =
+			msm_pmem_region_lookup(&sync->pmem_stats,
+				MSM_PMEM_AEC_AWB, &region[0],
+				NUM_STAT_OUTPUT_BUFFERS,
+				&sync->pmem_stats_spinlock);
+		if (!axi_data.bufnum1) {
+			pr_err("%s %d: pmem region lookup error\n",
+				__func__, __LINE__);
+			return -EINVAL;
+		}
+		axi_data.region = &region[0];
+		return sync->vfefn.vfe_config(&cfgcmd, &axi_data);
+	case CMD_STATS_AEC_ENABLE:
+		axi_data.bufnum1 =
+			msm_pmem_region_lookup(&sync->pmem_stats,
+			MSM_PMEM_AEC, &region[0],
+			NUM_STAT_OUTPUT_BUFFERS,
+			&sync->pmem_stats_spinlock);
+		if (!axi_data.bufnum1) {
+			pr_err("%s %d: pmem region lookup error\n",
+				__func__, __LINE__);
+			return -EINVAL;
+		}
+		axi_data.region = &region[0];
+		return sync->vfefn.vfe_config(&cfgcmd, &axi_data);
+	case CMD_STATS_AWB_ENABLE:
+		axi_data.bufnum1 =
+			msm_pmem_region_lookup(&sync->pmem_stats,
+			MSM_PMEM_AWB, &region[0],
+			NUM_STAT_OUTPUT_BUFFERS,
+			&sync->pmem_stats_spinlock);
+		if (!axi_data.bufnum1) {
+			pr_err("%s %d: pmem region lookup error\n",
+				__func__, __LINE__);
+			return -EINVAL;
+		}
+		axi_data.region = &region[0];
+		return sync->vfefn.vfe_config(&cfgcmd, &axi_data);
+
+
+	case CMD_STATS_IHIST_ENABLE:
+		axi_data.bufnum1 =
+			msm_pmem_region_lookup(&sync->pmem_stats,
+			MSM_PMEM_IHIST, &region[0],
+			NUM_STAT_OUTPUT_BUFFERS,
+			&sync->pmem_stats_spinlock);
+		if (!axi_data.bufnum1) {
+			pr_err("%s %d: pmem region lookup error\n",
+				__func__, __LINE__);
+			return -EINVAL;
+		}
+		axi_data.region = &region[0];
+		return sync->vfefn.vfe_config(&cfgcmd, &axi_data);
+
+	case CMD_STATS_RS_ENABLE:
+		axi_data.bufnum1 =
+			msm_pmem_region_lookup(&sync->pmem_stats,
+			MSM_PMEM_RS, &region[0],
+			NUM_STAT_OUTPUT_BUFFERS,
+			&sync->pmem_stats_spinlock);
+		if (!axi_data.bufnum1) {
+			pr_err("%s %d: pmem region lookup error\n",
+				__func__, __LINE__);
+			return -EINVAL;
+		}
+		axi_data.region = &region[0];
+		return sync->vfefn.vfe_config(&cfgcmd, &axi_data);
+
+	case CMD_STATS_CS_ENABLE:
+		axi_data.bufnum1 =
+			msm_pmem_region_lookup(&sync->pmem_stats,
+			MSM_PMEM_CS, &region[0],
+			NUM_STAT_OUTPUT_BUFFERS,
+			&sync->pmem_stats_spinlock);
+		if (!axi_data.bufnum1) {
+			pr_err("%s %d: pmem region lookup error\n",
+				__func__, __LINE__);
+			return -EINVAL;
+		}
+		axi_data.region = &region[0];
+		return sync->vfefn.vfe_config(&cfgcmd, &axi_data);
+
+	case CMD_GENERAL:
+	case CMD_STATS_DISABLE:
+		return sync->vfefn.vfe_config(&cfgcmd, NULL);
+	default:
+		pr_err("%s: unknown command type %d\n",
+			__func__, cfgcmd.cmd_type);
+	}
+
+	return -EINVAL;
+}
+static int msm_vpe_frame_cfg(struct msm_sync *sync,
+				void *cfgcmdin)
+{
+	int rc = -EIO;
+	struct axidata axi_data;
+	void *data = &axi_data;
+	struct msm_pmem_region region[8];
+	int pmem_type;
+
+	struct msm_vpe_cfg_cmd *cfgcmd;
+	cfgcmd = (struct msm_vpe_cfg_cmd *)cfgcmdin;
+
+	memset(&axi_data, 0, sizeof(axi_data));
+	CDBG("In vpe_frame_cfg cfgcmd->cmd_type = %s\n",
+		vfe_config_cmd[cfgcmd->cmd_type]);
+	switch (cfgcmd->cmd_type) {
+	case CMD_AXI_CFG_VPE:
+		pmem_type = MSM_PMEM_VIDEO_VPE;
+		axi_data.bufnum1 =
+			msm_pmem_region_lookup_2(&sync->pmem_frames, pmem_type,
+				&region[0], 8, &sync->pmem_frame_spinlock);
+		CDBG("axi_data.bufnum1 = %d\n", axi_data.bufnum1);
+		if (!axi_data.bufnum1) {
+			pr_err("%s %d: pmem region lookup error\n",
+				__func__, __LINE__);
+			return -EINVAL;
+		}
+		pmem_type = MSM_PMEM_VIDEO;
+		break;
+	case CMD_AXI_CFG_SNAP_THUMB_VPE:
+		CDBG("%s: CMD_AXI_CFG_SNAP_THUMB_VPE", __func__);
+		pmem_type = MSM_PMEM_THUMBNAIL_VPE;
+		axi_data.bufnum1 =
+			msm_pmem_region_lookup(&sync->pmem_frames, pmem_type,
+			&region[0], 8, &sync->pmem_frame_spinlock);
+		if (!axi_data.bufnum1) {
+			pr_err("%s: THUMBNAIL_VPE pmem region lookup error\n",
+				__func__);
+			return -EINVAL;
+		}
+		break;
+	case CMD_AXI_CFG_SNAP_VPE:
+		CDBG("%s: CMD_AXI_CFG_SNAP_VPE", __func__);
+		pmem_type = MSM_PMEM_MAINIMG_VPE;
+		axi_data.bufnum1 =
+			msm_pmem_region_lookup(&sync->pmem_frames, pmem_type,
+				&region[0], 8, &sync->pmem_frame_spinlock);
+		if (!axi_data.bufnum1) {
+			pr_err("%s: MAINIMG_VPE pmem region lookup error\n",
+				__func__);
+			return -EINVAL;
+		}
+		break;
+	default:
+		pr_err("%s: unknown command type %d\n",
+			__func__, cfgcmd->cmd_type);
+		break;
+	}
+	axi_data.region = &region[0];
+	CDBG("out vpe_frame_cfg cfgcmd->cmd_type = %s\n",
+		vfe_config_cmd[cfgcmd->cmd_type]);
+	/* send the AXI configuration command to driver */
+	if (sync->vpefn.vpe_config)
+		rc = sync->vpefn.vpe_config(cfgcmd, data);
+	return rc;
+}
+
+static int msm_frame_axi_cfg(struct msm_sync *sync,
+		struct msm_vfe_cfg_cmd *cfgcmd)
+{
+	int rc = -EIO;
+	struct axidata axi_data;
+	void *data = &axi_data;
+	struct msm_pmem_region region[MAX_PMEM_CFG_BUFFERS];
+	int pmem_type;
+
+	memset(&axi_data, 0, sizeof(axi_data));
+
+	switch (cfgcmd->cmd_type) {
+
+	case CMD_AXI_CFG_PREVIEW:
+		pmem_type = MSM_PMEM_PREVIEW;
+		axi_data.bufnum2 =
+			msm_pmem_region_lookup(&sync->pmem_frames, pmem_type,
+				&region[0], MAX_PMEM_CFG_BUFFERS,
+				&sync->pmem_frame_spinlock);
+		if (!axi_data.bufnum2) {
+			pr_err("%s %d: pmem region lookup error (empty %d)\n",
+				__func__, __LINE__,
+				hlist_empty(&sync->pmem_frames));
+			return -EINVAL;
+		}
+		break;
+
+	case CMD_AXI_CFG_VIDEO:
+		pmem_type = MSM_PMEM_PREVIEW;
+		axi_data.bufnum1 =
+			msm_pmem_region_lookup(&sync->pmem_frames, pmem_type,
+				&region[0], MAX_PMEM_CFG_BUFFERS,
+				&sync->pmem_frame_spinlock);
+		if (!axi_data.bufnum1) {
+			pr_err("%s %d: pmem region lookup error\n",
+				__func__, __LINE__);
+			return -EINVAL;
+		}
+
+		pmem_type = MSM_PMEM_VIDEO;
+		axi_data.bufnum2 =
+			msm_pmem_region_lookup(&sync->pmem_frames, pmem_type,
+				&region[axi_data.bufnum1],
+				(MAX_PMEM_CFG_BUFFERS-(axi_data.bufnum1)),
+				&sync->pmem_frame_spinlock);
+		if (!axi_data.bufnum2) {
+			pr_err("%s %d: pmem region lookup error\n",
+				__func__, __LINE__);
+			return -EINVAL;
+		}
+		break;
+
+	case CMD_AXI_CFG_SNAP:
+		CDBG("%s, CMD_AXI_CFG_SNAP, type=%d\n", __func__,
+			cfgcmd->cmd_type);
+		pmem_type = MSM_PMEM_THUMBNAIL;
+		axi_data.bufnum1 =
+			msm_pmem_region_lookup(&sync->pmem_frames, pmem_type,
+				&region[0], MAX_PMEM_CFG_BUFFERS,
+				&sync->pmem_frame_spinlock);
+		if (!axi_data.bufnum1) {
+			pr_err("%s %d: pmem region lookup error\n",
+				__func__, __LINE__);
+			return -EINVAL;
+		}
+
+		pmem_type = MSM_PMEM_MAINIMG;
+		axi_data.bufnum2 =
+			msm_pmem_region_lookup(&sync->pmem_frames, pmem_type,
+				&region[axi_data.bufnum1],
+				(MAX_PMEM_CFG_BUFFERS-(axi_data.bufnum1)),
+				 &sync->pmem_frame_spinlock);
+		if (!axi_data.bufnum2) {
+			pr_err("%s %d: pmem region lookup error\n",
+				__func__, __LINE__);
+			return -EINVAL;
+		}
+		break;
+
+	case CMD_AXI_CFG_ZSL:
+		CDBG("%s, CMD_AXI_CFG_ZSL, type = %d\n", __func__,
+			cfgcmd->cmd_type);
+		pmem_type = MSM_PMEM_PREVIEW;
+		axi_data.bufnum1 =
+			msm_pmem_region_lookup(&sync->pmem_frames, pmem_type,
+				&region[0], MAX_PMEM_CFG_BUFFERS,
+				&sync->pmem_frame_spinlock);
+		if (!axi_data.bufnum1) {
+			pr_err("%s %d: pmem region lookup error\n",
+				__func__, __LINE__);
+			return -EINVAL;
+		}
+
+		pmem_type = MSM_PMEM_THUMBNAIL;
+		axi_data.bufnum2 =
+			msm_pmem_region_lookup(&sync->pmem_frames, pmem_type,
+				&region[axi_data.bufnum1],
+				(MAX_PMEM_CFG_BUFFERS-(axi_data.bufnum1)),
+				 &sync->pmem_frame_spinlock);
+		if (!axi_data.bufnum2) {
+			pr_err("%s %d: pmem region lookup error\n",
+				__func__, __LINE__);
+			return -EINVAL;
+		}
+
+		pmem_type = MSM_PMEM_MAINIMG;
+		axi_data.bufnum3 =
+			msm_pmem_region_lookup(&sync->pmem_frames, pmem_type,
+				&region[axi_data.bufnum1 + axi_data.bufnum2],
+				(MAX_PMEM_CFG_BUFFERS - axi_data.bufnum1 -
+				axi_data.bufnum2), &sync->pmem_frame_spinlock);
+		if (!axi_data.bufnum3) {
+			pr_err("%s %d: pmem region lookup error\n",
+				__func__, __LINE__);
+			return -EINVAL;
+		}
+		break;
+
+	case CMD_RAW_PICT_AXI_CFG:
+		pmem_type = MSM_PMEM_RAW_MAINIMG;
+		axi_data.bufnum2 =
+			msm_pmem_region_lookup(&sync->pmem_frames, pmem_type,
+				&region[0], MAX_PMEM_CFG_BUFFERS,
+				&sync->pmem_frame_spinlock);
+		if (!axi_data.bufnum2) {
+			pr_err("%s %d: pmem region lookup error\n",
+				__func__, __LINE__);
+			return -EINVAL;
+		}
+		break;
+
+	case CMD_GENERAL:
+		data = NULL;
+		break;
+
+	default:
+		pr_err("%s: unknown command type %d\n",
+			__func__, cfgcmd->cmd_type);
+		return -EINVAL;
+	}
+
+	axi_data.region = &region[0];
+
+	/* send the AXI configuration command to driver */
+	if (sync->vfefn.vfe_config)
+		rc = sync->vfefn.vfe_config(cfgcmd, data);
+
+	return rc;
+}
+
+static int msm_get_sensor_info(struct msm_sync *sync, void __user *arg)
+{
+	int rc = 0;
+	struct msm_camsensor_info info;
+	struct msm_camera_sensor_info *sdata;
+
+	if (copy_from_user(&info,
+			arg,
+			sizeof(struct msm_camsensor_info))) {
+		ERR_COPY_FROM_USER();
+		return -EFAULT;
+	}
+
+	sdata = sync->pdev->dev.platform_data;
+	if (sync->sctrl.s_camera_type == BACK_CAMERA_3D)
+		info.support_3d = true;
+	else
+		info.support_3d = false;
+	memcpy(&info.name[0],
+		sdata->sensor_name,
+		MAX_SENSOR_NAME);
+	info.flash_enabled = sdata->flash_data->flash_type !=
+		MSM_CAMERA_FLASH_NONE;
+
+	/* copy back to user space */
+	if (copy_to_user((void *)arg,
+			&info,
+			sizeof(struct msm_camsensor_info))) {
+		ERR_COPY_TO_USER();
+		rc = -EFAULT;
+	}
+
+	return rc;
+}
+
+static int msm_get_camera_info(void __user *arg)
+{
+	int rc = 0;
+	int i = 0;
+	struct msm_camera_info info;
+
+	if (copy_from_user(&info, arg, sizeof(struct msm_camera_info))) {
+		ERR_COPY_FROM_USER();
+		return -EFAULT;
+	}
+
+	CDBG("%s: camera_node %d\n", __func__, camera_node);
+	info.num_cameras = camera_node;
+
+	for (i = 0; i < camera_node; i++) {
+		info.has_3d_support[i] = 0;
+		info.is_internal_cam[i] = 0;
+		info.s_mount_angle[i] = sensor_mount_angle[i];
+		switch (camera_type[i]) {
+		case FRONT_CAMERA_2D:
+			info.is_internal_cam[i] = 1;
+			break;
+		case BACK_CAMERA_3D:
+			info.has_3d_support[i] = 1;
+			break;
+		case BACK_CAMERA_2D:
+		default:
+			break;
+		}
+	}
+	/* copy back to user space */
+	if (copy_to_user((void *)arg, &info, sizeof(struct msm_camera_info))) {
+		ERR_COPY_TO_USER();
+		rc = -EFAULT;
+	}
+	return rc;
+}
+
+static int __msm_put_frame_buf(struct msm_sync *sync,
+		struct msm_frame *pb)
+{
+	unsigned long pphy;
+	struct msm_vfe_cfg_cmd cfgcmd;
+
+	int rc = -EIO;
+
+	/* Change the active flag. */
+	pphy = msm_pmem_frame_vtop_lookup(sync,
+		pb->buffer,
+		pb->y_off, pb->cbcr_off, pb->fd, 1);
+
+	if (pphy != 0) {
+		CDBG("%s: rel: vaddr %lx, paddr %lx\n",
+			__func__,
+			pb->buffer, pphy);
+		cfgcmd.cmd_type = CMD_FRAME_BUF_RELEASE;
+		cfgcmd.value    = (void *)pb;
+		if (sync->vfefn.vfe_config)
+			rc = sync->vfefn.vfe_config(&cfgcmd, &pphy);
+	} else {
+		pr_err("%s: msm_pmem_frame_vtop_lookup failed\n",
+			__func__);
+		rc = -EINVAL;
+	}
+
+	return rc;
+}
+static int __msm_put_pic_buf(struct msm_sync *sync,
+		struct msm_frame *pb)
+{
+	unsigned long pphy;
+	struct msm_vfe_cfg_cmd cfgcmd;
+
+	int rc = -EIO;
+
+	pphy = msm_pmem_frame_vtop_lookup(sync,
+		pb->buffer,
+		pb->y_off, pb->cbcr_off, pb->fd, 1);
+
+	if (pphy != 0) {
+		CDBG("%s: rel: vaddr %lx, paddr %lx\n",
+			__func__,
+			pb->buffer, pphy);
+		cfgcmd.cmd_type = CMD_SNAP_BUF_RELEASE;
+		cfgcmd.value    = (void *)pb;
+		if (sync->vfefn.vfe_config)
+			rc = sync->vfefn.vfe_config(&cfgcmd, &pphy);
+	} else {
+		pr_err("%s: msm_pmem_frame_vtop_lookup failed\n",
+			__func__);
+		rc = -EINVAL;
+	}
+
+	return rc;
+}
+
+
+static int msm_put_frame_buffer(struct msm_sync *sync, void __user *arg)
+{
+	struct msm_frame buf_t;
+
+	if (copy_from_user(&buf_t,
+				arg,
+				sizeof(struct msm_frame))) {
+		ERR_COPY_FROM_USER();
+		return -EFAULT;
+	}
+
+	return __msm_put_frame_buf(sync, &buf_t);
+}
+
+
+static int msm_put_pic_buffer(struct msm_sync *sync, void __user *arg)
+{
+	struct msm_frame buf_t;
+
+	if (copy_from_user(&buf_t,
+				arg,
+				sizeof(struct msm_frame))) {
+		ERR_COPY_FROM_USER();
+		return -EFAULT;
+	}
+
+	return __msm_put_pic_buf(sync, &buf_t);
+}
+
+static int __msm_register_pmem(struct msm_sync *sync,
+		struct msm_pmem_info *pinfo)
+{
+	int rc = 0;
+
+	switch (pinfo->type) {
+	case MSM_PMEM_VIDEO:
+	case MSM_PMEM_PREVIEW:
+	case MSM_PMEM_THUMBNAIL:
+	case MSM_PMEM_MAINIMG:
+	case MSM_PMEM_RAW_MAINIMG:
+	case MSM_PMEM_VIDEO_VPE:
+	case MSM_PMEM_C2D:
+	case MSM_PMEM_MAINIMG_VPE:
+	case MSM_PMEM_THUMBNAIL_VPE:
+		rc = msm_pmem_table_add(&sync->pmem_frames, pinfo,
+			&sync->pmem_frame_spinlock, sync);
+		break;
+
+	case MSM_PMEM_AEC_AWB:
+	case MSM_PMEM_AF:
+	case MSM_PMEM_AEC:
+	case MSM_PMEM_AWB:
+	case MSM_PMEM_RS:
+	case MSM_PMEM_CS:
+	case MSM_PMEM_IHIST:
+	case MSM_PMEM_SKIN:
+
+		rc = msm_pmem_table_add(&sync->pmem_stats, pinfo,
+			 &sync->pmem_stats_spinlock, sync);
+		break;
+
+	default:
+		rc = -EINVAL;
+		break;
+	}
+
+	return rc;
+}
+
+static int msm_register_pmem(struct msm_sync *sync, void __user *arg)
+{
+	struct msm_pmem_info info;
+
+	if (copy_from_user(&info, arg, sizeof(info))) {
+		ERR_COPY_FROM_USER();
+		return -EFAULT;
+	}
+
+	return __msm_register_pmem(sync, &info);
+}
+
+static int msm_stats_axi_cfg(struct msm_sync *sync,
+		struct msm_vfe_cfg_cmd *cfgcmd)
+{
+	int rc = -EIO;
+	struct axidata axi_data;
+	void *data = &axi_data;
+
+	struct msm_pmem_region region[3];
+	int pmem_type = MSM_PMEM_MAX;
+
+	memset(&axi_data, 0, sizeof(axi_data));
+
+	switch (cfgcmd->cmd_type) {
+	case CMD_STATS_AXI_CFG:
+		pmem_type = MSM_PMEM_AEC_AWB;
+		break;
+	case CMD_STATS_AF_AXI_CFG:
+		pmem_type = MSM_PMEM_AF;
+		break;
+	case CMD_GENERAL:
+		data = NULL;
+		break;
+	default:
+		pr_err("%s: unknown command type %d\n",
+			__func__, cfgcmd->cmd_type);
+		return -EINVAL;
+	}
+
+	if (cfgcmd->cmd_type != CMD_GENERAL) {
+		axi_data.bufnum1 =
+			msm_pmem_region_lookup(&sync->pmem_stats, pmem_type,
+				&region[0], NUM_STAT_OUTPUT_BUFFERS,
+				&sync->pmem_stats_spinlock);
+		if (!axi_data.bufnum1) {
+			pr_err("%s %d: pmem region lookup error\n",
+				__func__, __LINE__);
+			return -EINVAL;
+		}
+	axi_data.region = &region[0];
+	}
+
+	/* send the AEC/AWB STATS configuration command to driver */
+	if (sync->vfefn.vfe_config)
+		rc = sync->vfefn.vfe_config(cfgcmd, &axi_data);
+
+	return rc;
+}
+
+static int msm_put_stats_buffer(struct msm_sync *sync, void __user *arg)
+{
+	int rc = -EIO;
+
+	struct msm_stats_buf buf;
+	unsigned long pphy;
+	struct msm_vfe_cfg_cmd cfgcmd;
+
+	if (copy_from_user(&buf, arg,
+				sizeof(struct msm_stats_buf))) {
+		ERR_COPY_FROM_USER();
+		return -EFAULT;
+	}
+
+	CDBG("%s\n", __func__);
+	pphy = msm_pmem_stats_vtop_lookup(sync, buf.buffer, buf.fd);
+
+	if (pphy != 0) {
+		if (buf.type == STAT_AEAW)
+			cfgcmd.cmd_type = CMD_STATS_BUF_RELEASE;
+		else if (buf.type == STAT_AF)
+			cfgcmd.cmd_type = CMD_STATS_AF_BUF_RELEASE;
+		else if (buf.type == STAT_AEC)
+			cfgcmd.cmd_type = CMD_STATS_AEC_BUF_RELEASE;
+		else if (buf.type == STAT_AWB)
+			cfgcmd.cmd_type = CMD_STATS_AWB_BUF_RELEASE;
+		else if (buf.type == STAT_IHIST)
+			cfgcmd.cmd_type = CMD_STATS_IHIST_BUF_RELEASE;
+		else if (buf.type == STAT_RS)
+			cfgcmd.cmd_type = CMD_STATS_RS_BUF_RELEASE;
+		else if (buf.type == STAT_CS)
+			cfgcmd.cmd_type = CMD_STATS_CS_BUF_RELEASE;
+
+		else {
+			pr_err("%s: invalid buf type %d\n",
+				__func__,
+				buf.type);
+			rc = -EINVAL;
+			goto put_done;
+		}
+
+		cfgcmd.value = (void *)&buf;
+
+		if (sync->vfefn.vfe_config) {
+			rc = sync->vfefn.vfe_config(&cfgcmd, &pphy);
+			if (rc < 0)
+				pr_err("%s: vfe_config error %d\n",
+					__func__, rc);
+		} else
+			pr_err("%s: vfe_config is NULL\n", __func__);
+	} else {
+		pr_err("%s: NULL physical address\n", __func__);
+		rc = -EINVAL;
+	}
+
+put_done:
+	return rc;
+}
+
+static int msm_axi_config(struct msm_sync *sync, void __user *arg)
+{
+	struct msm_vfe_cfg_cmd cfgcmd;
+
+	if (copy_from_user(&cfgcmd, arg, sizeof(cfgcmd))) {
+		ERR_COPY_FROM_USER();
+		return -EFAULT;
+	}
+
+	switch (cfgcmd.cmd_type) {
+	case CMD_AXI_CFG_VIDEO:
+	case CMD_AXI_CFG_PREVIEW:
+	case CMD_AXI_CFG_SNAP:
+	case CMD_RAW_PICT_AXI_CFG:
+	case CMD_AXI_CFG_ZSL:
+		CDBG("%s, cfgcmd.cmd_type = %d\n", __func__, cfgcmd.cmd_type);
+		return msm_frame_axi_cfg(sync, &cfgcmd);
+
+	case CMD_AXI_CFG_VPE:
+	case CMD_AXI_CFG_SNAP_VPE:
+	case CMD_AXI_CFG_SNAP_THUMB_VPE:
+		return msm_vpe_frame_cfg(sync, (void *)&cfgcmd);
+
+	case CMD_STATS_AXI_CFG:
+	case CMD_STATS_AF_AXI_CFG:
+		return msm_stats_axi_cfg(sync, &cfgcmd);
+
+	default:
+		pr_err("%s: unknown command type %d\n",
+			__func__,
+			cfgcmd.cmd_type);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int __msm_get_pic(struct msm_sync *sync,
+		struct msm_frame *frame)
+{
+
+	int rc = 0;
+	struct msm_queue_cmd *qcmd = NULL;
+	struct msm_vfe_resp *vdata;
+	struct msm_vfe_phy_info *pphy;
+	struct msm_pmem_info pmem_info;
+	struct msm_frame *pframe;
+
+	qcmd = msm_dequeue(&sync->pict_q, list_pict);
+
+	if (!qcmd) {
+		pr_err("%s: no pic frame.\n", __func__);
+		return -EAGAIN;
+	}
+
+	if (MSM_CAM_Q_PP_MSG != qcmd->type) {
+		vdata = (struct msm_vfe_resp *)(qcmd->command);
+		pphy = &vdata->phy;
+
+		rc = msm_pmem_frame_ptov_lookup2(sync,
+				pphy->y_phy,
+				&pmem_info,
+				1); /* mark pic frame in use */
+
+		if (rc < 0) {
+			pr_err("%s: cannot get pic frame, invalid lookup"
+				" address y %x cbcr %x\n",
+				__func__, pphy->y_phy, pphy->cbcr_phy);
+			goto err;
+		}
+
+		frame->ts = qcmd->ts;
+		frame->buffer = (unsigned long)pmem_info.vaddr;
+		frame->y_off = pmem_info.y_off;
+		frame->cbcr_off = pmem_info.cbcr_off;
+		frame->fd = pmem_info.fd;
+		if (sync->stereocam_enabled &&
+			sync->stereo_state != STEREO_RAW_SNAP_STARTED) {
+			if (pmem_info.type == MSM_PMEM_THUMBNAIL_VPE)
+				frame->path = OUTPUT_TYPE_T;
+			else
+				frame->path = OUTPUT_TYPE_S;
+		} else
+			frame->path = vdata->phy.output_id;
+
+		CDBG("%s: y %x, cbcr %x, qcmd %x, virt_addr %x\n",
+			__func__, pphy->y_phy,
+			pphy->cbcr_phy, (int) qcmd, (int) frame->buffer);
+	} else { /* PP */
+		pframe = (struct msm_frame *)(qcmd->command);
+		frame->ts = qcmd->ts;
+		frame->buffer = pframe->buffer;
+		frame->y_off = pframe->y_off;
+		frame->cbcr_off = pframe->cbcr_off;
+		frame->fd = pframe->fd;
+		frame->path = pframe->path;
+		CDBG("%s: PP y_off %x, cbcr_off %x, path %d vaddr 0x%x\n",
+			__func__, frame->y_off, frame->cbcr_off, frame->path,
+			(int) frame->buffer);
+	}
+
+err:
+	free_qcmd(qcmd);
+
+	return rc;
+}
+
+static int msm_get_pic(struct msm_sync *sync, void __user *arg)
+{
+	int rc = 0;
+	struct msm_frame frame;
+
+	if (copy_from_user(&frame,
+				arg,
+				sizeof(struct msm_frame))) {
+		ERR_COPY_FROM_USER();
+		return -EFAULT;
+	}
+
+	rc = __msm_get_pic(sync, &frame);
+	if (rc < 0)
+		return rc;
+
+	if (sync->croplen && (!sync->stereocam_enabled)) {
+		if (frame.croplen != sync->croplen) {
+			pr_err("%s: invalid frame croplen %d,"
+				"expecting %d\n",
+				__func__,
+				frame.croplen,
+				sync->croplen);
+			return -EINVAL;
+		}
+
+		if (copy_to_user((void *)frame.cropinfo,
+				sync->cropinfo,
+				sync->croplen)) {
+			ERR_COPY_TO_USER();
+			return -EFAULT;
+		}
+	}
+	CDBG("%s: copy snapshot frame to user\n", __func__);
+	if (copy_to_user((void *)arg,
+				&frame, sizeof(struct msm_frame))) {
+		ERR_COPY_TO_USER();
+		rc = -EFAULT;
+	}
+
+	/*CDBG("%s: got pic frame\n", __func__);*//*original code*/
+	pr_err("%s: got pic frame\n", __func__); /* It always show */
+
+	return rc;
+}
+
+static int msm_set_crop(struct msm_sync *sync, void __user *arg)
+{
+	struct crop_info crop;
+
+	mutex_lock(&sync->lock);
+	if (copy_from_user(&crop,
+				arg,
+				sizeof(struct crop_info))) {
+		ERR_COPY_FROM_USER();
+		mutex_unlock(&sync->lock);
+		return -EFAULT;
+	}
+
+	if (crop.len != CROP_LEN) {
+		mutex_unlock(&sync->lock);
+		return -EINVAL;
+	}
+
+	if (!sync->croplen) {
+		sync->cropinfo = kmalloc(crop.len, GFP_KERNEL);
+		if (!sync->cropinfo) {
+			mutex_unlock(&sync->lock);
+			return -ENOMEM;
+		}
+	}
+
+	if (copy_from_user(sync->cropinfo,
+				crop.info,
+				crop.len)) {
+		ERR_COPY_FROM_USER();
+		sync->croplen = 0;
+		kfree(sync->cropinfo);
+		mutex_unlock(&sync->lock);
+		return -EFAULT;
+	}
+
+	sync->croplen = crop.len;
+
+	mutex_unlock(&sync->lock);
+	return 0;
+}
+
+static int msm_error_config(struct msm_sync *sync, void __user *arg)
+{
+	struct msm_queue_cmd *qcmd =
+		kmalloc(sizeof(struct msm_queue_cmd), GFP_KERNEL);
+
+	qcmd->command = NULL;
+
+	if (qcmd)
+		atomic_set(&(qcmd->on_heap), 1);
+
+	if (copy_from_user(&(qcmd->error_code), arg, sizeof(uint32_t))) {
+		ERR_COPY_FROM_USER();
+		free_qcmd(qcmd);
+		return -EFAULT;
+	}
+
+	pr_err("%s: Enqueue Fake Frame with error code = %d\n", __func__,
+		qcmd->error_code);
+	msm_enqueue(&sync->frame_q, &qcmd->list_frame);
+	return 0;
+}
+
+static int msm_set_fd_roi(struct msm_sync *sync, void __user *arg)
+{
+	struct fd_roi_info fd_roi;
+
+	mutex_lock(&sync->lock);
+	if (copy_from_user(&fd_roi,
+			arg,
+			sizeof(struct fd_roi_info))) {
+		ERR_COPY_FROM_USER();
+		mutex_unlock(&sync->lock);
+		return -EFAULT;
+	}
+	if (fd_roi.info_len <= 0) {
+		mutex_unlock(&sync->lock);
+		return -EFAULT;
+	}
+
+	if (!sync->fdroiinfo.info) {
+		sync->fdroiinfo.info = kmalloc(fd_roi.info_len, GFP_KERNEL);
+		if (!sync->fdroiinfo.info) {
+			mutex_unlock(&sync->lock);
+			return -ENOMEM;
+		}
+		sync->fdroiinfo.info_len = fd_roi.info_len;
+	} else if (sync->fdroiinfo.info_len < fd_roi.info_len) {
+		mutex_unlock(&sync->lock);
+		return -EINVAL;
+    }
+
+	if (copy_from_user(sync->fdroiinfo.info,
+			fd_roi.info,
+			fd_roi.info_len)) {
+		ERR_COPY_FROM_USER();
+		kfree(sync->fdroiinfo.info);
+		sync->fdroiinfo.info = NULL;
+		mutex_unlock(&sync->lock);
+		return -EFAULT;
+	}
+	mutex_unlock(&sync->lock);
+	return 0;
+}
+
+static int msm_pp_grab(struct msm_sync *sync, void __user *arg)
+{
+	uint32_t enable;
+	if (copy_from_user(&enable, arg, sizeof(enable))) {
+		ERR_COPY_FROM_USER();
+		return -EFAULT;
+	} else {
+		enable &= PP_MASK;
+		if (enable & (enable - 1)) {
+			CDBG("%s: more than one PP request!\n",
+				__func__);
+		}
+		if (sync->pp_mask) {
+			if (enable) {
+				CDBG("%s: postproc %x is already enabled\n",
+					__func__, sync->pp_mask & enable);
+			} else {
+				sync->pp_mask &= enable;
+				CDBG("%s: sync->pp_mask %d enable %d\n",
+					__func__, sync->pp_mask, enable);
+			}
+		}
+
+		CDBG("%s: sync->pp_mask %d enable %d\n", __func__,
+			sync->pp_mask, enable);
+		sync->pp_mask |= enable;
+	}
+
+	return 0;
+}
+
+static int msm_put_st_frame(struct msm_sync *sync, void __user *arg)
+{
+	unsigned long flags;
+	unsigned long st_pphy;
+	if (sync->stereocam_enabled) {
+		/* Make stereo frame ready for VPE. */
+		struct msm_st_frame stereo_frame_half;
+
+		if (copy_from_user(&stereo_frame_half, arg,
+			sizeof(stereo_frame_half))) {
+			ERR_COPY_FROM_USER();
+			return -EFAULT;
+		}
+
+		if (stereo_frame_half.type == OUTPUT_TYPE_ST_L) {
+			struct msm_vfe_resp *vfe_rp;
+			struct msm_queue_cmd *qcmd;
+
+			spin_lock_irqsave(&pp_stereocam_spinlock, flags);
+			if (!sync->pp_stereocam) {
+				pr_warning("%s: no stereo frame to deliver!\n",
+					__func__);
+				spin_unlock_irqrestore(&pp_stereocam_spinlock,
+					flags);
+				return -EINVAL;
+			}
+			CDBG("%s: delivering left frame to VPE\n", __func__);
+
+			qcmd = sync->pp_stereocam;
+			sync->pp_stereocam = NULL;
+			spin_unlock_irqrestore(&pp_stereocam_spinlock, flags);
+
+			vfe_rp = (struct msm_vfe_resp *)qcmd->command;
+
+			CDBG("%s: Left Py = 0x%x y_off = %d cbcr_off = %d\n",
+				__func__, vfe_rp->phy.y_phy,
+				stereo_frame_half.L.buf_y_off,
+				stereo_frame_half.L.buf_cbcr_off);
+
+			sync->vpefn.vpe_cfg_offset(stereo_frame_half.packing,
+			vfe_rp->phy.y_phy + stereo_frame_half.L.buf_y_off,
+			vfe_rp->phy.y_phy + stereo_frame_half.L.buf_cbcr_off,
+			&(qcmd->ts), OUTPUT_TYPE_ST_L, stereo_frame_half.L,
+			stereo_frame_half.frame_id);
+
+			free_qcmd(qcmd);
+		} else if (stereo_frame_half.type == OUTPUT_TYPE_ST_R) {
+			CDBG("%s: delivering right frame to VPE\n", __func__);
+			spin_lock_irqsave(&st_frame_spinlock, flags);
+
+			sync->stcam_conv_value =
+				stereo_frame_half.buf_info.stcam_conv_value;
+			sync->stcam_quality_ind =
+				stereo_frame_half.buf_info.stcam_quality_ind;
+
+			st_pphy = msm_pmem_frame_vtop_lookup(sync,
+				stereo_frame_half.buf_info.buffer,
+				stereo_frame_half.buf_info.y_off,
+				stereo_frame_half.buf_info.cbcr_off,
+				stereo_frame_half.buf_info.fd,
+				0); /* Do not change the active flag. */
+
+			sync->vpefn.vpe_cfg_offset(stereo_frame_half.packing,
+				st_pphy + stereo_frame_half.R.buf_y_off,
+				st_pphy + stereo_frame_half.R.buf_cbcr_off,
+				NULL, OUTPUT_TYPE_ST_R, stereo_frame_half.R,
+				stereo_frame_half.frame_id);
+
+			spin_unlock_irqrestore(&st_frame_spinlock, flags);
+		} else {
+			CDBG("%s: Invalid Msg\n", __func__);
+		}
+	}
+
+	return 0;
+}
+
+static struct msm_queue_cmd *msm_get_pp_qcmd(struct msm_frame* frame)
+{
+	struct msm_queue_cmd *qcmd =
+		kmalloc(sizeof(struct msm_queue_cmd) +
+			sizeof(struct msm_frame), GFP_ATOMIC);
+	qcmd->command = (struct msm_frame *)(qcmd + 1);
+
+	qcmd->type = MSM_CAM_Q_PP_MSG;
+
+	ktime_get_ts(&(qcmd->ts));
+	memcpy(qcmd->command, frame, sizeof(struct msm_frame));
+	atomic_set(&(qcmd->on_heap), 1);
+	return qcmd;
+}
+
+static int msm_pp_release(struct msm_sync *sync, void __user *arg)
+{
+	unsigned long flags;
+
+	if (!sync->pp_mask) {
+		pr_warning("%s: pp not in progress for\n", __func__);
+		return -EINVAL;
+	}
+	if (sync->pp_mask & PP_PREV) {
+
+
+		spin_lock_irqsave(&pp_prev_spinlock, flags);
+		if (!sync->pp_prev) {
+			pr_err("%s: no preview frame to deliver!\n",
+				__func__);
+			spin_unlock_irqrestore(&pp_prev_spinlock,
+				flags);
+			return -EINVAL;
+		}
+		CDBG("%s: delivering pp_prev\n", __func__);
+
+			if (sync->frame_q.len <= 100 &&
+				sync->event_q.len <= 100) {
+					msm_enqueue(&sync->frame_q,
+						&sync->pp_prev->list_frame);
+			} else {
+				pr_err("%s, Error Queue limit exceeded f_q=%d,\
+					e_q = %d\n",
+					__func__, sync->frame_q.len,
+					sync->event_q.len);
+				free_qcmd(sync->pp_prev);
+				goto done;
+			}
+
+			sync->pp_prev = NULL;
+			spin_unlock_irqrestore(&pp_prev_spinlock, flags);
+		goto done;
+	}
+
+	if ((sync->pp_mask & PP_SNAP) ||
+		(sync->pp_mask & PP_RAW_SNAP)) {
+		struct msm_frame frame;
+		struct msm_queue_cmd *qcmd;
+
+		if (copy_from_user(&frame,
+			arg,
+			sizeof(struct msm_frame))) {
+			ERR_COPY_FROM_USER();
+			return -EFAULT;
+		}
+		qcmd = msm_get_pp_qcmd(&frame);
+		if (!qcmd) {
+			pr_err("%s: no snapshot to deliver!\n", __func__);
+			return -EINVAL;
+		}
+		CDBG("%s: delivering pp snap\n", __func__);
+		msm_enqueue(&sync->pict_q, &qcmd->list_pict);
+	}
+
+done:
+	return 0;
+}
+
+static long msm_ioctl_common(struct msm_cam_device *pmsm,
+		unsigned int cmd,
+		void __user *argp)
+{
+	switch (cmd) {
+	case MSM_CAM_IOCTL_REGISTER_PMEM:
+		CDBG("%s cmd = MSM_CAM_IOCTL_REGISTER_PMEM\n", __func__);
+		return msm_register_pmem(pmsm->sync, argp);
+	case MSM_CAM_IOCTL_UNREGISTER_PMEM:
+		CDBG("%s cmd = MSM_CAM_IOCTL_UNREGISTER_PMEM\n", __func__);
+		return msm_pmem_table_del(pmsm->sync, argp);
+	case MSM_CAM_IOCTL_RELEASE_FRAME_BUFFER:
+		CDBG("%s cmd = MSM_CAM_IOCTL_RELEASE_FRAME_BUFFER\n", __func__);
+		return msm_put_frame_buffer(pmsm->sync, argp);
+		break;
+	default:
+		CDBG("%s cmd invalid\n", __func__);
+		return -EINVAL;
+	}
+}
+
+static long msm_ioctl_config(struct file *filep, unsigned int cmd,
+	unsigned long arg)
+{
+	int rc = -EINVAL;
+	void __user *argp = (void __user *)arg;
+	struct msm_cam_device *pmsm = filep->private_data;
+
+	CDBG("%s: cmd %d\n", __func__, _IOC_NR(cmd));
+
+	switch (cmd) {
+	case MSM_CAM_IOCTL_GET_SENSOR_INFO:
+		rc = msm_get_sensor_info(pmsm->sync, argp);
+		break;
+
+	case MSM_CAM_IOCTL_CONFIG_VFE:
+		/* Coming from config thread for update */
+		rc = msm_config_vfe(pmsm->sync, argp);
+		break;
+
+	case MSM_CAM_IOCTL_CONFIG_VPE:
+		/* Coming from config thread for update */
+		rc = msm_config_vpe(pmsm->sync, argp);
+		break;
+
+	case MSM_CAM_IOCTL_GET_STATS:
+		/* Coming from config thread wait
+		 * for vfe statistics and control requests */
+		rc = msm_get_stats(pmsm->sync, argp);
+		break;
+
+	case MSM_CAM_IOCTL_ENABLE_VFE:
+		/* This request comes from control thread:
+		 * enable either QCAMTASK or VFETASK */
+		rc = msm_enable_vfe(pmsm->sync, argp);
+		break;
+
+	case MSM_CAM_IOCTL_DISABLE_VFE:
+		/* This request comes from control thread:
+		 * disable either QCAMTASK or VFETASK */
+		rc = msm_disable_vfe(pmsm->sync, argp);
+		break;
+
+	case MSM_CAM_IOCTL_VFE_APPS_RESET:
+		msm_camio_vfe_blk_reset();
+		rc = 0;
+		break;
+
+	case MSM_CAM_IOCTL_RELEASE_STATS_BUFFER:
+		rc = msm_put_stats_buffer(pmsm->sync, argp);
+		break;
+
+	case MSM_CAM_IOCTL_AXI_CONFIG:
+	case MSM_CAM_IOCTL_AXI_VPE_CONFIG:
+		rc = msm_axi_config(pmsm->sync, argp);
+		break;
+
+	case MSM_CAM_IOCTL_SET_CROP:
+		rc = msm_set_crop(pmsm->sync, argp);
+		break;
+
+	case MSM_CAM_IOCTL_SET_FD_ROI:
+		rc = msm_set_fd_roi(pmsm->sync, argp);
+		break;
+
+	case MSM_CAM_IOCTL_PICT_PP:
+		/* Grab one preview frame or one snapshot
+		 * frame.
+		 */
+		rc = msm_pp_grab(pmsm->sync, argp);
+		break;
+
+	case MSM_CAM_IOCTL_PICT_PP_DONE:
+		/* Release the preview of snapshot frame
+		 * that was grabbed.
+		 */
+		rc = msm_pp_release(pmsm->sync, argp);
+		break;
+
+	case MSM_CAM_IOCTL_PUT_ST_FRAME:
+		/* Release the left or right frame
+		 * that was sent for stereo processing.
+		 */
+		rc = msm_put_st_frame(pmsm->sync, argp);
+		break;
+
+	case MSM_CAM_IOCTL_SENSOR_IO_CFG:
+		rc = pmsm->sync->sctrl.s_config(argp);
+		break;
+
+	case MSM_CAM_IOCTL_FLASH_LED_CFG: {
+		uint32_t led_state;
+		if (copy_from_user(&led_state, argp, sizeof(led_state))) {
+			ERR_COPY_FROM_USER();
+			rc = -EFAULT;
+		} else
+			rc = msm_camera_flash_set_led_state(pmsm->sync->
+					sdata->flash_data, led_state);
+		break;
+	}
+
+	case MSM_CAM_IOCTL_STROBE_FLASH_CFG: {
+		uint32_t flash_type;
+		if (copy_from_user(&flash_type, argp, sizeof(flash_type))) {
+			pr_err("msm_strobe_flash_init failed");
+			ERR_COPY_FROM_USER();
+			rc = -EFAULT;
+		} else {
+			CDBG("msm_strobe_flash_init enter");
+			rc = msm_strobe_flash_init(pmsm->sync, flash_type);
+		}
+		break;
+	}
+
+	case MSM_CAM_IOCTL_STROBE_FLASH_RELEASE:
+		if (pmsm->sync->sdata->strobe_flash_data) {
+			rc = pmsm->sync->sfctrl.strobe_flash_release(
+				pmsm->sync->sdata->strobe_flash_data, 0);
+		}
+		break;
+
+	case MSM_CAM_IOCTL_STROBE_FLASH_CHARGE: {
+		uint32_t charge_en;
+		if (copy_from_user(&charge_en, argp, sizeof(charge_en))) {
+			ERR_COPY_FROM_USER();
+			rc = -EFAULT;
+		} else
+			rc = pmsm->sync->sfctrl.strobe_flash_charge(
+			pmsm->sync->sdata->strobe_flash_data->flash_charge,
+			charge_en, pmsm->sync->sdata->strobe_flash_data->
+				flash_recharge_duration);
+		break;
+	}
+
+	case MSM_CAM_IOCTL_FLASH_CTRL: {
+		struct flash_ctrl_data flash_info;
+		if (copy_from_user(&flash_info, argp, sizeof(flash_info))) {
+			ERR_COPY_FROM_USER();
+			rc = -EFAULT;
+		} else
+			rc = msm_flash_ctrl(pmsm->sync->sdata, &flash_info);
+
+		break;
+	}
+
+	case MSM_CAM_IOCTL_ERROR_CONFIG:
+		rc = msm_error_config(pmsm->sync, argp);
+		break;
+
+	case MSM_CAM_IOCTL_ABORT_CAPTURE: {
+		unsigned long flags = 0;
+		CDBG("get_pic:MSM_CAM_IOCTL_ABORT_CAPTURE\n");
+		spin_lock_irqsave(&pmsm->sync->abort_pict_lock, flags);
+		pmsm->sync->get_pic_abort = 1;
+		spin_unlock_irqrestore(&pmsm->sync->abort_pict_lock, flags);
+		wake_up(&(pmsm->sync->pict_q.wait));
+		rc = 0;
+		break;
+	}
+
+	default:
+		rc = msm_ioctl_common(pmsm, cmd, argp);
+		break;
+	}
+
+	CDBG("%s: cmd %d DONE\n", __func__, _IOC_NR(cmd));
+	return rc;
+}
+
+static int msm_unblock_poll_frame(struct msm_sync *);
+
+static long msm_ioctl_frame(struct file *filep, unsigned int cmd,
+	unsigned long arg)
+{
+	int rc = -EINVAL;
+	void __user *argp = (void __user *)arg;
+	struct msm_cam_device *pmsm = filep->private_data;
+
+
+	switch (cmd) {
+	case MSM_CAM_IOCTL_GETFRAME:
+		/* Coming from frame thread to get frame
+		 * after SELECT is done */
+		rc = msm_get_frame(pmsm->sync, argp);
+		break;
+	case MSM_CAM_IOCTL_RELEASE_FRAME_BUFFER:
+		rc = msm_put_frame_buffer(pmsm->sync, argp);
+		break;
+	case MSM_CAM_IOCTL_UNBLOCK_POLL_FRAME:
+		rc = msm_unblock_poll_frame(pmsm->sync);
+		break;
+	default:
+		break;
+	}
+
+	return rc;
+}
+
+static int msm_unblock_poll_pic(struct msm_sync *sync);
+static long msm_ioctl_pic(struct file *filep, unsigned int cmd,
+	unsigned long arg)
+{
+	int rc = -EINVAL;
+	void __user *argp = (void __user *)arg;
+	struct msm_cam_device *pmsm = filep->private_data;
+
+
+	switch (cmd) {
+	case MSM_CAM_IOCTL_GET_PICTURE:
+		rc = msm_get_pic(pmsm->sync, argp);
+		break;
+	case MSM_CAM_IOCTL_RELEASE_PIC_BUFFER:
+		rc = msm_put_pic_buffer(pmsm->sync, argp);
+		break;
+	case MSM_CAM_IOCTL_UNBLOCK_POLL_PIC_FRAME:
+		rc = msm_unblock_poll_pic(pmsm->sync);
+		break;
+	default:
+		break;
+	}
+
+	return rc;
+}
+
+
+void sensor_rough_control(void __user *arg);
+
+
+
+static long msm_ioctl_control(struct file *filep, unsigned int cmd,
+	unsigned long arg)
+{
+	int rc = -EINVAL;
+	void __user *argp = (void __user *)arg;
+	struct msm_control_device *ctrl_pmsm = filep->private_data;
+	struct msm_cam_device *pmsm = ctrl_pmsm->pmsm;
+
+	switch (cmd) {
+	case MSM_CAM_IOCTL_CTRL_COMMAND:
+		/* Coming from control thread, may need to wait for
+		 * command status */
+		CDBG("calling msm_control kernel msm_ioctl_control\n");
+		mutex_lock(&ctrl_cmd_lock);
+		rc = msm_control(ctrl_pmsm, 1, argp);
+		mutex_unlock(&ctrl_cmd_lock);
+		break;
+	case MSM_CAM_IOCTL_CTRL_COMMAND_2:
+		/* Sends a message, returns immediately */
+		rc = msm_control(ctrl_pmsm, 0, argp);
+		break;
+	case MSM_CAM_IOCTL_CTRL_CMD_DONE:
+		/* Config thread calls the control thread to notify it
+		 * of the result of a MSM_CAM_IOCTL_CTRL_COMMAND.
+		 */
+		rc = msm_ctrl_cmd_done(ctrl_pmsm, argp);
+		break;
+	case MSM_CAM_IOCTL_GET_SENSOR_INFO:
+		rc = msm_get_sensor_info(pmsm->sync, argp);
+		break;
+	case MSM_CAM_IOCTL_GET_CAMERA_INFO:
+		rc = msm_get_camera_info(argp);
+		break;
+
+    case MSM_CAM_IOCTL_PCAM_CTRL_8BIT:
+		//sensor_rough_control(argp);
+		//rc = 0;
+			rc = pmsm->sync->sctrl.s_ext_config(argp); // for dual camera interface
+		        break;
+	default:
+		rc = msm_ioctl_common(pmsm, cmd, argp);
+		break;
+	}
+
+	return rc;
+}
+
+static int __msm_release(struct msm_sync *sync)
+{
+	struct msm_pmem_region *region;
+	struct hlist_node *hnode;
+	struct hlist_node *n;
+
+	mutex_lock(&sync->lock);
+	if (sync->opencnt)
+		sync->opencnt--;
+	pr_info("%s, open count =%d\n", __func__, sync->opencnt);
+	if (!sync->opencnt) {
+		/* need to clean up system resource */
+		pr_info("%s, release VFE\n", __func__);
+		if (sync->core_powered_on) {
+			if (sync->vfefn.vfe_release)
+				sync->vfefn.vfe_release(sync->pdev);
+			/*sensor release */
+			pr_info("%s, release Sensor\n", __func__);
+			sync->sctrl.s_release();
+			CDBG("%s, msm_camio_sensor_clk_off\n", __func__);
+			msm_camio_sensor_clk_off(sync->pdev);
+			if (sync->sfctrl.strobe_flash_release) {
+				CDBG("%s, strobe_flash_release\n", __func__);
+				sync->sfctrl.strobe_flash_release(
+				sync->sdata->strobe_flash_data, 1);
+			}
+		}
+		kfree(sync->cropinfo);
+		sync->cropinfo = NULL;
+		sync->croplen = 0;
+		CDBG("%s, free frame pmem region\n", __func__);
+		hlist_for_each_entry_safe(region, hnode, n,
+				&sync->pmem_frames, list) {
+			hlist_del(hnode);
+			put_pmem_file(region->file);
+			kfree(region);
+		}
+		CDBG("%s, free stats pmem region\n", __func__);
+		hlist_for_each_entry_safe(region, hnode, n,
+				&sync->pmem_stats, list) {
+			hlist_del(hnode);
+			put_pmem_file(region->file);
+			kfree(region);
+		}
+		msm_queue_drain(&sync->pict_q, list_pict);
+		msm_queue_drain(&sync->event_q, list_config);
+
+		pm_qos_update_request(&sync->idle_pm_qos, PM_QOS_DEFAULT_VALUE);
+		sync->apps_id = NULL;
+		sync->core_powered_on = 0;
+	}
+	mutex_unlock(&sync->lock);
+
+	return 0;
+}
+
+static int msm_release_config(struct inode *node, struct file *filep)
+{
+	int rc;
+	struct msm_cam_device *pmsm = filep->private_data;
+	pr_info("%s: %s\n", __func__, filep->f_path.dentry->d_name.name);
+	rc = __msm_release(pmsm->sync);
+	if (!rc) {
+		msm_queue_drain(&pmsm->sync->event_q, list_config);
+		atomic_set(&pmsm->opened, 0);
+	}
+	return rc;
+}
+
+static int msm_release_control(struct inode *node, struct file *filep)
+{
+	int rc;
+	struct msm_control_device *ctrl_pmsm = filep->private_data;
+	struct msm_cam_device *pmsm = ctrl_pmsm->pmsm;
+	pr_info("%s: %s\n", __func__, filep->f_path.dentry->d_name.name);
+	g_v4l2_opencnt--;
+	mutex_lock(&pmsm->sync->lock);
+	if (pmsm->sync->core_powered_on && pmsm->sync->vfefn.vfe_stop) {
+		pr_info("%s, stop vfe if active\n", __func__);
+		pmsm->sync->vfefn.vfe_stop();
+	}
+	mutex_unlock(&pmsm->sync->lock);
+	rc = __msm_release(pmsm->sync);
+	if (!rc) {
+		msm_queue_drain(&ctrl_pmsm->ctrl_q, list_control);
+		kfree(ctrl_pmsm);
+	}
+	return rc;
+}
+
+static int msm_release_frame(struct inode *node, struct file *filep)
+{
+	int rc;
+	struct msm_cam_device *pmsm = filep->private_data;
+	pr_info("%s: %s\n", __func__, filep->f_path.dentry->d_name.name);
+	rc = __msm_release(pmsm->sync);
+	if (!rc) {
+		msm_queue_drain(&pmsm->sync->frame_q, list_frame);
+		atomic_set(&pmsm->opened, 0);
+	}
+	return rc;
+}
+
+
+static int msm_release_pic(struct inode *node, struct file *filep)
+{
+	int rc;
+	struct msm_cam_device *pmsm = filep->private_data;
+	CDBG("%s: %s\n", __func__, filep->f_path.dentry->d_name.name);
+	rc = __msm_release(pmsm->sync);
+	if (!rc) {
+		msm_queue_drain(&pmsm->sync->pict_q, list_pict);
+		atomic_set(&pmsm->opened, 0);
+	}
+	return rc;
+}
+
+static int msm_unblock_poll_pic(struct msm_sync *sync)
+{
+	unsigned long flags;
+	CDBG("%s\n", __func__);
+	spin_lock_irqsave(&sync->pict_q.lock, flags);
+	sync->unblock_poll_pic_frame = 1;
+	wake_up(&sync->pict_q.wait);
+	spin_unlock_irqrestore(&sync->pict_q.lock, flags);
+	return 0;
+}
+
+static int msm_unblock_poll_frame(struct msm_sync *sync)
+{
+	unsigned long flags;
+	CDBG("%s\n", __func__);
+	spin_lock_irqsave(&sync->frame_q.lock, flags);
+	sync->unblock_poll_frame = 1;
+	wake_up(&sync->frame_q.wait);
+	spin_unlock_irqrestore(&sync->frame_q.lock, flags);
+	return 0;
+}
+
+static unsigned int __msm_poll_frame(struct msm_sync *sync,
+		struct file *filep,
+		struct poll_table_struct *pll_table)
+{
+	int rc = 0;
+	unsigned long flags;
+
+	poll_wait(filep, &sync->frame_q.wait, pll_table);
+
+	spin_lock_irqsave(&sync->frame_q.lock, flags);
+	if (!list_empty_careful(&sync->frame_q.list))
+		/* frame ready */
+		rc = POLLIN | POLLRDNORM;
+	if (sync->unblock_poll_frame) {
+		CDBG("%s: sync->unblock_poll_frame is true\n", __func__);
+		rc |= POLLPRI;
+		sync->unblock_poll_frame = 0;
+	}
+	spin_unlock_irqrestore(&sync->frame_q.lock, flags);
+
+	return rc;
+}
+
+static unsigned int __msm_poll_pic(struct msm_sync *sync,
+		struct file *filep,
+		struct poll_table_struct *pll_table)
+{
+	int rc = 0;
+	unsigned long flags;
+
+	poll_wait(filep, &sync->pict_q.wait , pll_table);
+	spin_lock_irqsave(&sync->abort_pict_lock, flags);
+	if (sync->get_pic_abort == 1) {
+		/* TODO: need to pass an error case */
+		sync->get_pic_abort = 0;
+	}
+	spin_unlock_irqrestore(&sync->abort_pict_lock, flags);
+
+	spin_lock_irqsave(&sync->pict_q.lock, flags);
+	if (!list_empty_careful(&sync->pict_q.list))
+		/* frame ready */
+		rc = POLLIN | POLLRDNORM;
+	if (sync->unblock_poll_pic_frame) {
+		CDBG("%s: sync->unblock_poll_pic_frame is true\n", __func__);
+		rc |= POLLPRI;
+		sync->unblock_poll_pic_frame = 0;
+	}
+	spin_unlock_irqrestore(&sync->pict_q.lock, flags);
+
+	return rc;
+}
+
+static unsigned int msm_poll_frame(struct file *filep,
+	struct poll_table_struct *pll_table)
+{
+	struct msm_cam_device *pmsm = filep->private_data;
+	return __msm_poll_frame(pmsm->sync, filep, pll_table);
+}
+
+static unsigned int msm_poll_pic(struct file *filep,
+	struct poll_table_struct *pll_table)
+{
+	struct msm_cam_device *pmsm = filep->private_data;
+	return __msm_poll_pic(pmsm->sync, filep, pll_table);
+}
+
+static unsigned int __msm_poll_config(struct msm_sync *sync,
+		struct file *filep,
+		struct poll_table_struct *pll_table)
+{
+	int rc = 0;
+	unsigned long flags;
+
+	poll_wait(filep, &sync->event_q.wait, pll_table);
+
+	spin_lock_irqsave(&sync->event_q.lock, flags);
+	if (!list_empty_careful(&sync->event_q.list))
+		/* event ready */
+		rc = POLLIN | POLLRDNORM;
+	spin_unlock_irqrestore(&sync->event_q.lock, flags);
+
+	return rc;
+}
+
+static unsigned int msm_poll_config(struct file *filep,
+	struct poll_table_struct *pll_table)
+{
+	struct msm_cam_device *pmsm = filep->private_data;
+	return __msm_poll_config(pmsm->sync, filep, pll_table);
+}
+
+/*
+ * This function executes in interrupt context.
+ */
+
+static void *msm_vfe_sync_alloc(int size,
+			void *syncdata __attribute__((unused)),
+			gfp_t gfp)
+{
+	struct msm_queue_cmd *qcmd =
+		kzalloc(sizeof(struct msm_queue_cmd) + size, gfp);
+	if (qcmd) {
+		atomic_set(&qcmd->on_heap, 1);
+		return qcmd + 1;
+	}
+	return NULL;
+}
+
+static void *msm_vpe_sync_alloc(int size,
+			void *syncdata __attribute__((unused)),
+			gfp_t gfp)
+{
+	struct msm_queue_cmd *qcmd =
+		kzalloc(sizeof(struct msm_queue_cmd) + size, gfp);
+	if (qcmd) {
+		atomic_set(&qcmd->on_heap, 1);
+		return qcmd + 1;
+	}
+	return NULL;
+}
+
+static void msm_vfe_sync_free(void *ptr)
+{
+	if (ptr) {
+		struct msm_queue_cmd *qcmd =
+			(struct msm_queue_cmd *)ptr;
+		qcmd--;
+		if (atomic_read(&qcmd->on_heap))
+			kfree(qcmd);
+	}
+}
+
+static void msm_vpe_sync_free(void *ptr)
+{
+	if (ptr) {
+		struct msm_queue_cmd *qcmd =
+			(struct msm_queue_cmd *)ptr;
+		qcmd--;
+		if (atomic_read(&qcmd->on_heap))
+			kfree(qcmd);
+	}
+}
+
+/*
+ * This function executes in interrupt context.
+ */
+
+static void msm_vfe_sync(struct msm_vfe_resp *vdata,
+		enum msm_queue qtype, void *syncdata,
+		gfp_t gfp)
+{
+	struct msm_queue_cmd *qcmd = NULL;
+	struct msm_sync *sync = (struct msm_sync *)syncdata;
+	unsigned long flags;
+
+	if (!sync) {
+		pr_err("%s: no context in dsp callback.\n", __func__);
+		return;
+	}
+
+	qcmd = ((struct msm_queue_cmd *)vdata) - 1;
+	qcmd->type = qtype;
+	qcmd->command = vdata;
+
+	ktime_get_ts(&(qcmd->ts));
+
+	if (qtype != MSM_CAM_Q_VFE_MSG)
+		goto vfe_for_config;
+
+	CDBG("%s: vdata->type %d\n", __func__, vdata->type);
+
+	switch (vdata->type) {
+	case VFE_MSG_OUTPUT_P:
+		if (sync->pp_mask & PP_PREV) {
+			CDBG("%s: PP_PREV in progress: phy_y %x phy_cbcr %x\n",
+				__func__,
+				vdata->phy.y_phy,
+				vdata->phy.cbcr_phy);
+			spin_lock_irqsave(&pp_prev_spinlock, flags);
+			if (sync->pp_prev)
+				CDBG("%s: overwriting pp_prev!\n",
+					__func__);
+			CDBG("%s: sending preview to config\n", __func__);
+			sync->pp_prev = qcmd;
+			spin_unlock_irqrestore(&pp_prev_spinlock, flags);
+			sync->pp_frame_avail = 1;
+			if (atomic_read(&qcmd->on_heap))
+				atomic_add(1, &qcmd->on_heap);
+			break;
+		}
+		CDBG("%s: msm_enqueue frame_q\n", __func__);
+		if (sync->stereocam_enabled)
+			CDBG("%s: Enqueue VFE_MSG_OUTPUT_P to event_q for "
+				"stereo processing\n", __func__);
+		else {
+			if (sync->frame_q.len <= 100 &&
+				sync->event_q.len <= 100) {
+				if (atomic_read(&qcmd->on_heap))
+					atomic_add(1, &qcmd->on_heap);
+				msm_enqueue(&sync->frame_q, &qcmd->list_frame);
+			} else {
+				pr_err("%s, Error Queue limit exceeded "
+					"f_q = %d, e_q = %d\n",	__func__,
+					sync->frame_q.len, sync->event_q.len);
+				free_qcmd(qcmd);
+				return;
+			}
+		}
+		break;
+
+	case VFE_MSG_OUTPUT_T:
+		if (sync->stereocam_enabled) {
+			spin_lock_irqsave(&pp_stereocam_spinlock, flags);
+
+			/* if out1/2 is currently in progress, save the qcmd
+			and issue only ionce the 1st one completes the 3D
+			pipeline */
+			if (STEREO_SNAP_BUFFER1_PROCESSING ==
+				sync->stereo_state) {
+				sync->pp_stereocam2 = qcmd;
+				spin_unlock_irqrestore(&pp_stereocam_spinlock,
+					flags);
+				if (atomic_read(&qcmd->on_heap))
+					atomic_add(1, &qcmd->on_heap);
+				CDBG("%s: snapshot stereo in progress\n",
+					__func__);
+				return;
+			}
+
+			if (sync->pp_stereocam)
+				CDBG("%s: overwriting pp_stereocam!\n",
+					__func__);
+
+			CDBG("%s: sending stereo frame to config\n", __func__);
+			sync->pp_stereocam = qcmd;
+			sync->stereo_state =
+				STEREO_SNAP_BUFFER1_PROCESSING;
+
+			spin_unlock_irqrestore(&pp_stereocam_spinlock, flags);
+
+			/* Increament on_heap by one because the same qcmd will
+			be used for VPE in msm_pp_release. */
+			if (atomic_read(&qcmd->on_heap))
+				atomic_add(1, &qcmd->on_heap);
+			CDBG("%s: Enqueue VFE_MSG_OUTPUT_T to event_q for "
+				"stereo processing.\n", __func__);
+			break;
+		}
+		if (sync->pp_mask & PP_SNAP) {
+			CDBG("%s: pp sending thumbnail to config\n",
+				__func__);
+		} else {
+			msm_enqueue(&sync->pict_q, &qcmd->list_pict);
+			return;
+		}
+
+	case VFE_MSG_OUTPUT_S:
+		if (sync->stereocam_enabled &&
+			sync->stereo_state != STEREO_RAW_SNAP_STARTED) {
+			spin_lock_irqsave(&pp_stereocam_spinlock, flags);
+
+			/* if out1/2 is currently in progress, save the qcmd
+			and issue only once the 1st one completes the 3D
+			pipeline */
+			if (STEREO_SNAP_BUFFER1_PROCESSING ==
+				sync->stereo_state) {
+				sync->pp_stereocam2 = qcmd;
+				spin_unlock_irqrestore(&pp_stereocam_spinlock,
+					flags);
+				if (atomic_read(&qcmd->on_heap))
+					atomic_add(1, &qcmd->on_heap);
+				CDBG("%s: snapshot stereo in progress\n",
+					__func__);
+				return;
+			}
+			if (sync->pp_stereocam)
+				CDBG("%s: overwriting pp_stereocam!\n",
+					__func__);
+
+			CDBG("%s: sending stereo frame to config\n", __func__);
+			sync->pp_stereocam = qcmd;
+			sync->stereo_state =
+				STEREO_SNAP_BUFFER1_PROCESSING;
+
+			spin_unlock_irqrestore(&pp_stereocam_spinlock, flags);
+
+			/* Increament on_heap by one because the same qcmd will
+			be used for VPE in msm_pp_release. */
+			if (atomic_read(&qcmd->on_heap))
+				atomic_add(1, &qcmd->on_heap);
+			CDBG("%s: Enqueue VFE_MSG_OUTPUT_S to event_q for "
+				"stereo processing.\n", __func__);
+			break;
+		}
+		if (sync->pp_mask & PP_SNAP) {
+			CDBG("%s: pp sending main image to config\n",
+				__func__);
+		} else {
+			CDBG("%s: enqueue to picture queue\n", __func__);
+			msm_enqueue(&sync->pict_q, &qcmd->list_pict);
+			return;
+		}
+		break;
+
+	case VFE_MSG_OUTPUT_V:
+		if (sync->stereocam_enabled) {
+			spin_lock_irqsave(&pp_stereocam_spinlock, flags);
+
+			if (sync->pp_stereocam)
+				CDBG("%s: overwriting pp_stereocam!\n",
+					__func__);
+
+			CDBG("%s: sending stereo frame to config\n", __func__);
+			sync->pp_stereocam = qcmd;
+
+			spin_unlock_irqrestore(&pp_stereocam_spinlock, flags);
+
+			/* Increament on_heap by one because the same qcmd will
+			be used for VPE in msm_pp_release. */
+			if (atomic_read(&qcmd->on_heap))
+				atomic_add(1, &qcmd->on_heap);
+			CDBG("%s: Enqueue VFE_MSG_OUTPUT_V to event_q for "
+				"stereo processing.\n", __func__);
+			break;
+		}
+		if (sync->vpefn.vpe_cfg_update) {
+			CDBG("dis_en = %d\n", *sync->vpefn.dis);
+			if (*(sync->vpefn.dis)) {
+				memset(&(vdata->vpe_bf), 0,
+					sizeof(vdata->vpe_bf));
+
+				if (sync->cropinfo != NULL)
+					vdata->vpe_bf.vpe_crop =
+				*(struct video_crop_t *)(sync->cropinfo);
+
+				vdata->vpe_bf.y_phy = vdata->phy.y_phy;
+				vdata->vpe_bf.cbcr_phy = vdata->phy.cbcr_phy;
+				vdata->vpe_bf.ts = (qcmd->ts);
+				vdata->vpe_bf.frame_id = vdata->phy.frame_id;
+				qcmd->command = vdata;
+				msm_enqueue_vpe(&sync->vpe_q,
+					&qcmd->list_vpe_frame);
+				return;
+			} else if (sync->vpefn.vpe_cfg_update(sync->cropinfo)) {
+				CDBG("%s: msm_enqueue video frame to vpe time "
+					"= %ld\n", __func__, qcmd->ts.tv_nsec);
+
+				sync->vpefn.send_frame_to_vpe(
+					vdata->phy.y_phy,
+					vdata->phy.cbcr_phy,
+					&(qcmd->ts), OUTPUT_TYPE_V);
+
+				free_qcmd(qcmd);
+				return;
+			} else {
+				CDBG("%s: msm_enqueue video frame_q\n",
+					__func__);
+				if (sync->liveshot_enabled) {
+					CDBG("%s: msm_enqueue liveshot\n",
+						__func__);
+					vdata->phy.output_id |= OUTPUT_TYPE_L;
+					sync->liveshot_enabled = false;
+				}
+				if (sync->frame_q.len <= 100 &&
+					sync->event_q.len <= 100) {
+						msm_enqueue(&sync->frame_q,
+							&qcmd->list_frame);
+				} else {
+					pr_err("%s, Error Queue limit exceeded\
+						f_q = %d, e_q = %d\n",
+						__func__, sync->frame_q.len,
+						sync->event_q.len);
+					free_qcmd(qcmd);
+				}
+
+				return;
+			}
+		} else {
+			CDBG("%s: msm_enqueue video frame_q\n",	__func__);
+			if (sync->frame_q.len <= 100 &&
+				sync->event_q.len <= 100) {
+				msm_enqueue(&sync->frame_q, &qcmd->list_frame);
+			} else {
+				pr_err("%s, Error Queue limit exceeded\
+					f_q = %d, e_q = %d\n",
+					__func__, sync->frame_q.len,
+					sync->event_q.len);
+				free_qcmd(qcmd);
+			}
+
+			return;
+		}
+
+	case VFE_MSG_SNAPSHOT:
+		if (sync->pp_mask & (PP_SNAP | PP_RAW_SNAP)) {
+			CDBG("%s: PP_SNAP in progress: pp_mask %x\n",
+				__func__, sync->pp_mask);
+		} else {
+			if (atomic_read(&qcmd->on_heap))
+				atomic_add(1, &qcmd->on_heap);
+			CDBG("%s: VFE_MSG_SNAPSHOT store\n",
+				__func__);
+			if (sync->stereocam_enabled &&
+				sync->stereo_state != STEREO_RAW_SNAP_STARTED) {
+				sync->pp_stereosnap = qcmd;
+				return;
+			}
+		}
+		break;
+
+	case VFE_MSG_COMMON:
+		CDBG("%s: qtype %d, comp stats, enqueue event_q.\n",
+			__func__, vdata->type);
+		break;
+
+	case VFE_MSG_GENERAL:
+		CDBG("%s: qtype %d, general msg, enqueue event_q.\n",
+			__func__, vdata->type);
+		break;
+
+	default:
+		CDBG("%s: qtype %d not handled\n", __func__, vdata->type);
+		/* fall through, send to config. */
+	}
+
+vfe_for_config:
+	CDBG("%s: msm_enqueue event_q\n", __func__);
+	if (sync->frame_q.len <= 100 && sync->event_q.len <= 100) {
+		msm_enqueue(&sync->event_q, &qcmd->list_config);
+	} else {
+		pr_err("%s, Error Queue limit exceeded f_q = %d, e_q = %d\n",
+			__func__, sync->frame_q.len, sync->event_q.len);
+		free_qcmd(qcmd);
+	}
+
+}
+
+static void msm_vpe_sync(struct msm_vpe_resp *vdata,
+	enum msm_queue qtype, void *syncdata, void *ts, gfp_t gfp)
+{
+	struct msm_queue_cmd *qcmd = NULL;
+	unsigned long flags;
+
+	struct msm_sync *sync = (struct msm_sync *)syncdata;
+	if (!sync) {
+		pr_err("%s: no context in dsp callback.\n", __func__);
+		return;
+	}
+
+	qcmd = ((struct msm_queue_cmd *)vdata) - 1;
+	qcmd->type = qtype;
+	qcmd->command = vdata;
+	qcmd->ts = *((struct timespec *)ts);
+
+	if (qtype != MSM_CAM_Q_VPE_MSG) {
+		pr_err("%s: Invalid qcmd type = %d.\n", __func__, qcmd->type);
+		free_qcmd(qcmd);
+		return;
+	}
+
+	CDBG("%s: vdata->type %d\n", __func__, vdata->type);
+	switch (vdata->type) {
+	case VPE_MSG_OUTPUT_V:
+		if (sync->liveshot_enabled) {
+			CDBG("%s: msm_enqueue liveshot %d\n", __func__,
+				sync->liveshot_enabled);
+			vdata->phy.output_id |= OUTPUT_TYPE_L;
+			sync->liveshot_enabled = false;
+		}
+		if (sync->frame_q.len <= 100 && sync->event_q.len <= 100) {
+			CDBG("%s: enqueue to frame_q from VPE\n", __func__);
+			msm_enqueue(&sync->frame_q, &qcmd->list_frame);
+		} else {
+			pr_err("%s, Error Queue limit exceeded f_q = %d, "
+				"e_q = %d\n", __func__, sync->frame_q.len,
+				sync->event_q.len);
+			free_qcmd(qcmd);
+		}
+		return;
+
+	case VPE_MSG_OUTPUT_ST_L:
+		CDBG("%s: enqueue left frame done msg to event_q from VPE\n",
+			__func__);
+		msm_enqueue(&sync->event_q, &qcmd->list_config);
+		return;
+
+	case VPE_MSG_OUTPUT_ST_R:
+		spin_lock_irqsave(&pp_stereocam_spinlock, flags);
+		CDBG("%s: received VPE_MSG_OUTPUT_ST_R state %d\n", __func__,
+			sync->stereo_state);
+
+		if (STEREO_SNAP_BUFFER1_PROCESSING == sync->stereo_state) {
+			msm_enqueue(&sync->pict_q, &qcmd->list_pict);
+			qcmd = sync->pp_stereocam2;
+			sync->pp_stereocam = sync->pp_stereocam2;
+			sync->pp_stereocam2 = NULL;
+			msm_enqueue(&sync->event_q, &qcmd->list_config);
+			sync->stereo_state =
+				STEREO_SNAP_BUFFER2_PROCESSING;
+		} else if (STEREO_SNAP_BUFFER2_PROCESSING ==
+				sync->stereo_state) {
+			sync->stereo_state = STEREO_SNAP_IDLE;
+			/* Send snapshot DONE */
+			msm_enqueue(&sync->pict_q, &qcmd->list_pict);
+			qcmd = sync->pp_stereosnap;
+			sync->pp_stereosnap = NULL;
+			CDBG("%s: send SNAPSHOT_DONE message\n", __func__);
+			msm_enqueue(&sync->event_q, &qcmd->list_config);
+		} else {
+			if (atomic_read(&qcmd->on_heap))
+				atomic_add(1, &qcmd->on_heap);
+			msm_enqueue(&sync->event_q, &qcmd->list_config);
+			if (sync->stereo_state == STEREO_VIDEO_ACTIVE) {
+				CDBG("%s: st frame to frame_q from VPE\n",
+					__func__);
+				msm_enqueue(&sync->frame_q, &qcmd->list_frame);
+			}
+		}
+		spin_unlock_irqrestore(&pp_stereocam_spinlock, flags);
+		return;
+
+	default:
+		pr_err("%s: qtype %d not handled\n", __func__, vdata->type);
+	}
+	pr_err("%s: Should not come here. Error.\n", __func__);
+}
+
+static struct msm_vpe_callback msm_vpe_s = {
+	.vpe_resp = msm_vpe_sync,
+	.vpe_alloc = msm_vpe_sync_alloc,
+	.vpe_free = msm_vpe_sync_free,
+};
+
+static struct msm_vfe_callback msm_vfe_s = {
+	.vfe_resp = msm_vfe_sync,
+	.vfe_alloc = msm_vfe_sync_alloc,
+	.vfe_free = msm_vfe_sync_free,
+};
+
+static int __msm_open(struct msm_cam_device *pmsm, const char *const apps_id,
+			int is_controlnode)
+{
+	int rc = 0;
+	struct msm_sync *sync = pmsm->sync;
+
+	mutex_lock(&sync->lock);
+	if (sync->apps_id && strcmp(sync->apps_id, apps_id)
+				&& (!strcmp(MSM_APPS_ID_V4L2, apps_id))) {
+		pr_err("%s(%s): sensor %s is already opened for %s\n",
+			__func__,
+			apps_id,
+			sync->sdata->sensor_name,
+			sync->apps_id);
+		rc = -EBUSY;
+		goto msm_open_done;
+	}
+
+	sync->apps_id = apps_id;
+
+	if (!sync->core_powered_on && !is_controlnode) {
+		pm_qos_update_request(&sync->idle_pm_qos,
+			msm_cpuidle_get_deep_idle_latency());
+
+		msm_camvfe_fn_init(&sync->vfefn, sync);
+		if (sync->vfefn.vfe_init) {
+			sync->pp_frame_avail = 0;
+			sync->get_pic_abort = 0;
+			rc = msm_camio_sensor_clk_on(sync->pdev);
+			if (rc < 0) {
+				pr_err("%s: setting sensor clocks failed: %d\n",
+					__func__, rc);
+				goto msm_open_err;
+			}
+			rc = sync->sctrl.s_init(sync->sdata);
+			if (rc < 0) {
+				pr_err("%s: sensor init failed: %d\n",
+					__func__, rc);
+				msm_camio_sensor_clk_off(sync->pdev);
+				goto msm_open_err;
+			}
+			rc = sync->vfefn.vfe_init(&msm_vfe_s,
+				sync->pdev);
+			if (rc < 0) {
+				pr_err("%s: vfe_init failed at %d\n",
+					__func__, rc);
+				sync->sctrl.s_release();
+				msm_camio_sensor_clk_off(sync->pdev);
+				goto msm_open_err;
+			}
+		} else {
+			pr_err("%s: no sensor init func\n", __func__);
+			rc = -ENODEV;
+			goto msm_open_err;
+		}
+		msm_camvpe_fn_init(&sync->vpefn, sync);
+
+		spin_lock_init(&sync->abort_pict_lock);
+		spin_lock_init(&pp_prev_spinlock);
+		spin_lock_init(&pp_stereocam_spinlock);
+		spin_lock_init(&st_frame_spinlock);
+		if (rc >= 0) {
+			msm_region_init(sync);
+			if (sync->vpefn.vpe_reg)
+				sync->vpefn.vpe_reg(&msm_vpe_s);
+			sync->unblock_poll_frame = 0;
+			sync->unblock_poll_pic_frame = 0;
+		}
+		sync->core_powered_on = 1;
+	}
+	sync->opencnt++;
+
+msm_open_done:
+	mutex_unlock(&sync->lock);
+	return rc;
+
+msm_open_err:
+	atomic_set(&pmsm->opened, 0);
+	mutex_unlock(&sync->lock);
+	return rc;
+}
+
+static int msm_open_common(struct inode *inode, struct file *filep,
+			int once, int is_controlnode)
+{
+	int rc;
+	struct msm_cam_device *pmsm =
+		container_of(inode->i_cdev, struct msm_cam_device, cdev);
+
+	CDBG("%s: open %s\n", __func__, filep->f_path.dentry->d_name.name);
+
+	if (atomic_cmpxchg(&pmsm->opened, 0, 1) && once) {
+		pr_err("%s: %s is already opened.\n",
+			__func__,
+			filep->f_path.dentry->d_name.name);
+		return -EBUSY;
+	}
+
+	rc = nonseekable_open(inode, filep);
+	if (rc < 0) {
+		pr_err("%s: nonseekable_open error %d\n", __func__, rc);
+		return rc;
+	}
+
+	rc = __msm_open(pmsm, MSM_APPS_ID_PROP, is_controlnode);
+	if (rc < 0)
+		return rc;
+	filep->private_data = pmsm;
+	CDBG("%s: rc %d\n", __func__, rc);
+	return rc;
+}
+
+static int msm_open(struct inode *inode, struct file *filep)
+{
+	return msm_open_common(inode, filep, 1, 0);
+}
+
+static int msm_open_control(struct inode *inode, struct file *filep)
+{
+	int rc;
+
+	struct msm_control_device *ctrl_pmsm =
+		kmalloc(sizeof(struct msm_control_device), GFP_KERNEL);
+	if (!ctrl_pmsm)
+		return -ENOMEM;
+
+	rc = msm_open_common(inode, filep, 0, 1);
+	if (rc < 0) {
+		kfree(ctrl_pmsm);
+		return rc;
+	}
+	ctrl_pmsm->pmsm = filep->private_data;
+	filep->private_data = ctrl_pmsm;
+
+	msm_queue_init(&ctrl_pmsm->ctrl_q, "control");
+
+	if (!g_v4l2_opencnt)
+		g_v4l2_control_device = ctrl_pmsm;
+	g_v4l2_opencnt++;
+	CDBG("%s: rc %d\n", __func__, rc);
+	return rc;
+}
+
+static const struct file_operations msm_fops_config = {
+	.owner = THIS_MODULE,
+	.open = msm_open,
+	.unlocked_ioctl = msm_ioctl_config,
+	.release = msm_release_config,
+	.poll = msm_poll_config,
+};
+
+static const struct file_operations msm_fops_control = {
+	.owner = THIS_MODULE,
+	.open = msm_open_control,
+	.unlocked_ioctl = msm_ioctl_control,
+	.release = msm_release_control,
+};
+
+static const struct file_operations msm_fops_frame = {
+	.owner = THIS_MODULE,
+	.open = msm_open,
+	.unlocked_ioctl = msm_ioctl_frame,
+	.release = msm_release_frame,
+	.poll = msm_poll_frame,
+};
+
+static const struct file_operations msm_fops_pic = {
+	.owner = THIS_MODULE,
+	.open = msm_open,
+	.unlocked_ioctl = msm_ioctl_pic,
+	.release = msm_release_pic,
+	.poll = msm_poll_pic,
+};
+
+static int msm_setup_cdev(struct msm_cam_device *msm,
+			int node,
+			dev_t devno,
+			const char *suffix,
+			const struct file_operations *fops)
+{
+	int rc = -ENODEV;
+
+	struct device *device =
+		device_create(msm_class, NULL,
+			devno, NULL,
+			"%s%d", suffix, node);
+
+	if (IS_ERR(device)) {
+		rc = PTR_ERR(device);
+		pr_err("%s: error creating device: %d\n", __func__, rc);
+		return rc;
+	}
+
+	cdev_init(&msm->cdev, fops);
+	msm->cdev.owner = THIS_MODULE;
+
+	rc = cdev_add(&msm->cdev, devno, 1);
+	if (rc < 0) {
+		pr_err("%s: error adding cdev: %d\n", __func__, rc);
+		device_destroy(msm_class, devno);
+		return rc;
+	}
+
+	return rc;
+}
+
+static int msm_tear_down_cdev(struct msm_cam_device *msm, dev_t devno)
+{
+	cdev_del(&msm->cdev);
+	device_destroy(msm_class, devno);
+	return 0;
+}
+
+static int msm_sync_init(struct msm_sync *sync,
+		struct platform_device *pdev,
+		int (*sensor_probe)(const struct msm_camera_sensor_info *,
+				struct msm_sensor_ctrl *))
+{
+	int rc = 0;
+	struct msm_sensor_ctrl sctrl;
+	sync->sdata = pdev->dev.platform_data;
+
+	msm_queue_init(&sync->event_q, "event");
+	msm_queue_init(&sync->frame_q, "frame");
+	msm_queue_init(&sync->pict_q, "pict");
+	msm_queue_init(&sync->vpe_q, "vpe");
+
+	pm_qos_add_request(&sync->idle_pm_qos, PM_QOS_CPU_DMA_LATENCY,
+		PM_QOS_DEFAULT_VALUE);
+
+	rc = msm_camio_probe_on(pdev);
+	if (rc < 0) {
+		pm_qos_remove_request(&sync->idle_pm_qos);
+		return rc;
+	}
+	rc = sensor_probe(sync->sdata, &sctrl);
+	if (rc >= 0) {
+		sync->pdev = pdev;
+		sync->sctrl = sctrl;
+	}
+	msm_camio_probe_off(pdev);
+	if (rc < 0) {
+		pr_err("%s: failed to initialize %s\n",
+			__func__,
+			sync->sdata->sensor_name);
+		pm_qos_remove_request(&sync->idle_pm_qos);
+		return rc;
+	}
+
+	sync->opencnt = 0;
+	sync->core_powered_on = 0;
+	sync->ignore_qcmd = false;
+	sync->ignore_qcmd_type = -1;
+	mutex_init(&sync->lock);
+	if (sync->sdata->strobe_flash_data) {
+		sync->sdata->strobe_flash_data->state = 0;
+		spin_lock_init(&sync->sdata->strobe_flash_data->spin_lock);
+	}
+	CDBG("%s: initialized %s\n", __func__, sync->sdata->sensor_name);
+	return rc;
+}
+
+static int msm_sync_destroy(struct msm_sync *sync)
+{
+	pm_qos_remove_request(&sync->idle_pm_qos);
+	return 0;
+}
+
+static int msm_device_init(struct msm_cam_device *pmsm,
+		struct msm_sync *sync,
+		int node)
+{
+	int dev_num = 4 * node;
+	int rc = msm_setup_cdev(pmsm, node,
+		MKDEV(MAJOR(msm_devno), dev_num),
+		"control", &msm_fops_control);
+	if (rc < 0) {
+		pr_err("%s: error creating control node: %d\n", __func__, rc);
+		return rc;
+	}
+
+	rc = msm_setup_cdev(pmsm + 1, node,
+		MKDEV(MAJOR(msm_devno), dev_num + 1),
+		"config", &msm_fops_config);
+	if (rc < 0) {
+		pr_err("%s: error creating config node: %d\n", __func__, rc);
+		msm_tear_down_cdev(pmsm, MKDEV(MAJOR(msm_devno),
+				dev_num));
+		return rc;
+	}
+
+	rc = msm_setup_cdev(pmsm + 2, node,
+		MKDEV(MAJOR(msm_devno), dev_num + 2),
+		"frame", &msm_fops_frame);
+	if (rc < 0) {
+		pr_err("%s: error creating frame node: %d\n", __func__, rc);
+		msm_tear_down_cdev(pmsm,
+			MKDEV(MAJOR(msm_devno), dev_num));
+		msm_tear_down_cdev(pmsm + 1,
+			MKDEV(MAJOR(msm_devno), dev_num + 1));
+		return rc;
+	}
+
+	rc = msm_setup_cdev(pmsm + 3, node,
+		MKDEV(MAJOR(msm_devno), dev_num + 3),
+		"pic", &msm_fops_pic);
+	if (rc < 0) {
+		pr_err("%s: error creating pic node: %d\n", __func__, rc);
+		msm_tear_down_cdev(pmsm,
+			MKDEV(MAJOR(msm_devno), dev_num));
+		msm_tear_down_cdev(pmsm + 1,
+			MKDEV(MAJOR(msm_devno), dev_num + 1));
+		msm_tear_down_cdev(pmsm + 2,
+			MKDEV(MAJOR(msm_devno), dev_num + 2));
+		return rc;
+	}
+
+
+	atomic_set(&pmsm[0].opened, 0);
+	atomic_set(&pmsm[1].opened, 0);
+	atomic_set(&pmsm[2].opened, 0);
+	atomic_set(&pmsm[3].opened, 0);
+
+	pmsm[0].sync = sync;
+	pmsm[1].sync = sync;
+	pmsm[2].sync = sync;
+	pmsm[3].sync = sync;
+
+	return rc;
+}
+
+int msm_camera_drv_start(struct platform_device *dev,
+		int (*sensor_probe)(const struct msm_camera_sensor_info *,
+			struct msm_sensor_ctrl *))
+{
+	struct msm_cam_device *pmsm = NULL;
+	struct msm_sync *sync;
+	int rc = -ENODEV;
+
+	if (camera_node >= MSM_MAX_CAMERA_SENSORS) {
+		pr_err("%s: too many camera sensors\n", __func__);
+		return rc;
+	}
+
+	if (!msm_class) {
+		/* There are three device nodes per sensor */
+		rc = alloc_chrdev_region(&msm_devno, 0,
+				4 * MSM_MAX_CAMERA_SENSORS,
+				"msm_camera");
+		if (rc < 0) {
+			pr_err("%s: failed to allocate chrdev: %d\n", __func__,
+				rc);
+			return rc;
+		}
+
+		msm_class = class_create(THIS_MODULE, "msm_camera");
+		if (IS_ERR(msm_class)) {
+			rc = PTR_ERR(msm_class);
+			pr_err("%s: create device class failed: %d\n",
+				__func__, rc);
+			return rc;
+		}
+	}
+
+	pmsm = kzalloc(sizeof(struct msm_cam_device) * 4 +
+			sizeof(struct msm_sync), GFP_ATOMIC);
+	if (!pmsm)
+		return -ENOMEM;
+	sync = (struct msm_sync *)(pmsm + 4);
+
+	rc = msm_sync_init(sync, dev, sensor_probe);
+	if (rc < 0) {
+		kfree(pmsm);
+		return rc;
+	}
+
+	CDBG("%s: setting camera node %d\n", __func__, camera_node);
+	rc = msm_device_init(pmsm, sync, camera_node);
+	if (rc < 0) {
+		msm_sync_destroy(sync);
+		kfree(pmsm);
+		return rc;
+	}
+
+	camera_type[camera_node] = sync->sctrl.s_camera_type;
+	sensor_mount_angle[camera_node] = sync->sctrl.s_mount_angle;
+	camera_node++;
+
+	list_add(&sync->list, &msm_sensors);
+	return rc;
+}
+EXPORT_SYMBOL(msm_camera_drv_start);
diff --git a/drivers/media/video/msm/msm_vfe7x27a_legacy.c b/drivers/media/video/msm/msm_vfe7x27a_legacy.c
new file mode 100644
index 0000000..ff1072a
--- /dev/null
+++ b/drivers/media/video/msm/msm_vfe7x27a_legacy.c
@@ -0,0 +1,741 @@
+/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/msm_adsp.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/android_pmem.h>
+#include <linux/slab.h>
+#include <linux/pm_qos.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <mach/msm_adsp.h>
+#include <mach/clk.h>
+#include <mach/camera.h>
+#include "msm_vfe7x27a.h"
+
+#define QDSP_CMDQUEUE 25
+
+#define VFE_RESET_CMD 0
+#define VFE_START_CMD 1
+#define VFE_STOP_CMD  2
+#define VFE_FRAME_ACK 20
+#define STATS_AF_ACK  21
+#define STATS_WE_ACK  22
+
+#define MSG_STOP_ACK  1
+#define MSG_SNAPSHOT  2
+#define MSG_OUTPUT1   6
+#define MSG_OUTPUT2   7
+#define MSG_STATS_AF  8
+#define MSG_STATS_WE  9
+#define MSG_OUTPUT_S  23
+#define MSG_OUTPUT_T  22
+#define MSG_SOF       15
+
+#define VFE_ADSP_EVENT 0xFFFF
+#define SNAPSHOT_MASK_MODE 0x00000002
+#define MSM_AXI_QOS_PREVIEW	122000
+#define MSM_AXI_QOS_SNAPSHOT	192000
+
+
+static struct msm_adsp_module *qcam_mod;
+static struct msm_adsp_module *vfe_mod;
+static struct msm_vfe_callback *resp;
+static void *extdata;
+static uint32_t extlen;
+
+struct mutex vfe_lock;
+static void     *vfe_syncdata;
+static uint8_t vfestopped;
+
+static struct stop_event stopevent;
+
+unsigned long paddr_s_y;
+unsigned long paddr_s_cbcr;
+unsigned long paddr_t_y;
+unsigned long paddr_t_cbcr;
+static uint32_t op_mode;
+
+static void vfe_7x_convert(struct msm_vfe_phy_info *pinfo,
+		enum vfe_resp_msg type,
+		void *data, void **ext, int32_t *elen)
+{
+	switch (type) {
+	case VFE_MSG_OUTPUT_P: {
+		pinfo->y_phy = ((struct vfe_endframe *)data)->y_address;
+		pinfo->cbcr_phy =
+			((struct vfe_endframe *)data)->cbcr_address;
+
+		pinfo->output_id = OUTPUT_TYPE_P;
+
+		CDBG("vfe_7x_convert, y_phy = 0x%x, cbcr_phy = 0x%x\n",
+				 pinfo->y_phy, pinfo->cbcr_phy);
+
+		memcpy(((struct vfe_frame_extra *)extdata),
+			&((struct vfe_endframe *)data)->extra,
+			sizeof(struct vfe_frame_extra));
+
+		*ext  = extdata;
+		*elen = extlen;
+		pinfo->frame_id =
+				((struct vfe_frame_extra *)extdata)->frame_id;
+	}
+		break;
+	case VFE_MSG_OUTPUT_S: {
+		pinfo->y_phy = paddr_s_y;
+		pinfo->cbcr_phy = paddr_s_cbcr;
+		pinfo->output_id = OUTPUT_TYPE_S;
+		CDBG("vfe_7x_convert: y_phy = 0x%x cbcr_phy = 0x%x\n",
+					pinfo->y_phy, pinfo->cbcr_phy);
+	}
+		break;
+	case VFE_MSG_OUTPUT_T: {
+		pinfo->y_phy = paddr_t_y;
+		pinfo->cbcr_phy = paddr_t_cbcr;
+		pinfo->output_id = OUTPUT_TYPE_T;
+		CDBG("vfe_7x_convert: y_phy = 0x%x cbcr_phy = 0x%x\n",
+					pinfo->y_phy, pinfo->cbcr_phy);
+	}
+		break;
+	case VFE_MSG_STATS_AF:
+	case VFE_MSG_STATS_WE:
+		pinfo->sbuf_phy = *(uint32_t *)data;
+		pinfo->frame_id = *(((uint32_t *)data) + 1);
+		CDBG("frame id = %d\n", pinfo->frame_id);
+		break;
+	default:
+		break;
+	}
+}
+
+static void vfe_7x_ops(void *driver_data, unsigned id, size_t len,
+		void (*getevent)(void *ptr, size_t len))
+{
+	uint32_t evt_buf[3];
+	struct msm_vfe_resp *rp;
+	void *data;
+	CDBG("%s:id=%d\n", __func__, id);
+
+	len = (id == VFE_ADSP_EVENT) ? 0 : len;
+	data = resp->vfe_alloc(sizeof(struct msm_vfe_resp) + len,
+		vfe_syncdata,  GFP_ATOMIC);
+
+	if (!data) {
+		pr_err("%s: rp: cannot allocate buffer\n", __func__);
+		return;
+	}
+	rp = data;
+	rp->evt_msg.len = len;
+
+	if (id == VFE_ADSP_EVENT) {
+		/* event */
+		rp->type           = VFE_EVENT;
+		rp->evt_msg.type   = MSM_CAMERA_EVT;
+		getevent(evt_buf, sizeof(evt_buf));
+		rp->evt_msg.msg_id = evt_buf[0];
+		CDBG("%s:event:msg_id=%d\n", __func__, rp->evt_msg.msg_id);
+		resp->vfe_resp(rp, MSM_CAM_Q_VFE_EVT, vfe_syncdata,
+		GFP_ATOMIC);
+	} else {
+		/* messages */
+		rp->evt_msg.type   = MSM_CAMERA_MSG;
+		rp->evt_msg.msg_id = id;
+		rp->evt_msg.data = rp + 1;
+		getevent(rp->evt_msg.data, len);
+		CDBG("%s:messages:msg_id=%d\n", __func__, rp->evt_msg.msg_id);
+
+		switch (rp->evt_msg.msg_id) {
+		case MSG_SNAPSHOT:
+			msm_camio_set_perf_lvl(S_PREVIEW);
+			vfe_7x_ops(driver_data, MSG_OUTPUT_S, len, getevent);
+			vfe_7x_ops(driver_data, MSG_OUTPUT_T, len, getevent);
+			rp->type = VFE_MSG_SNAPSHOT;
+			break;
+		case MSG_OUTPUT_S:
+			rp->type = VFE_MSG_OUTPUT_S;
+			vfe_7x_convert(&(rp->phy), VFE_MSG_OUTPUT_S,
+					rp->evt_msg.data, &(rp->extdata),
+					&(rp->extlen));
+			break;
+		case MSG_OUTPUT_T:
+			rp->type = VFE_MSG_OUTPUT_T;
+			vfe_7x_convert(&(rp->phy), VFE_MSG_OUTPUT_T,
+					rp->evt_msg.data, &(rp->extdata),
+					&(rp->extlen));
+			break;
+		case MSG_OUTPUT1:
+		case MSG_OUTPUT2:
+			if (op_mode & SNAPSHOT_MASK_MODE) {
+				resp->vfe_free(data);
+				return;
+			}
+			rp->type = VFE_MSG_OUTPUT_P;
+			vfe_7x_convert(&(rp->phy), VFE_MSG_OUTPUT_P,
+				rp->evt_msg.data, &(rp->extdata),
+				&(rp->extlen));
+			break;
+		case MSG_STATS_AF:
+			rp->type = VFE_MSG_STATS_AF;
+			vfe_7x_convert(&(rp->phy), VFE_MSG_STATS_AF,
+					rp->evt_msg.data, NULL, NULL);
+			break;
+		case MSG_STATS_WE:
+			rp->type = VFE_MSG_STATS_WE;
+			vfe_7x_convert(&(rp->phy), VFE_MSG_STATS_WE,
+					rp->evt_msg.data, NULL, NULL);
+
+			CDBG("MSG_STATS_WE: phy = 0x%x\n", rp->phy.sbuf_phy);
+			break;
+		case MSG_STOP_ACK:
+			rp->type = VFE_MSG_GENERAL;
+			stopevent.state = 1;
+			wake_up(&stopevent.wait);
+			break;
+		default:
+			rp->type = VFE_MSG_GENERAL;
+			break;
+		}
+		if (id != MSG_SOF)
+			resp->vfe_resp(rp, MSM_CAM_Q_VFE_MSG,
+					vfe_syncdata, GFP_ATOMIC);
+	}
+}
+
+static struct msm_adsp_ops vfe_7x_sync = {
+	.event = vfe_7x_ops,
+};
+
+static int vfe_7x_enable(struct camera_enable_cmd *enable)
+{
+	int rc = -EFAULT;
+	static int cnt;
+
+	if (!strcmp(enable->name, "QCAMTASK"))
+		rc = msm_adsp_enable(qcam_mod);
+	else if (!strcmp(enable->name, "VFETASK"))
+		rc = msm_adsp_enable(vfe_mod);
+
+	if (!cnt) {
+		msm_camio_set_perf_lvl(S_INIT);
+		cnt++;
+	}
+	return rc;
+}
+
+static int vfe_7x_disable(struct camera_enable_cmd *enable,
+		struct platform_device *dev __attribute__((unused)))
+{
+	int rc = -EFAULT;
+
+	if (!strcmp(enable->name, "QCAMTASK"))
+		rc = msm_adsp_disable(qcam_mod);
+	else if (!strcmp(enable->name, "VFETASK"))
+		rc = msm_adsp_disable(vfe_mod);
+
+	return rc;
+}
+
+static int vfe_7x_stop(void)
+{
+	int rc = 0;
+	uint32_t stopcmd = VFE_STOP_CMD;
+	rc = msm_adsp_write(vfe_mod, QDSP_CMDQUEUE,
+				&stopcmd, sizeof(uint32_t));
+	if (rc < 0) {
+		CDBG("%s:%d: failed rc = %d\n", __func__, __LINE__, rc);
+		return rc;
+	}
+
+	stopevent.state = 0;
+	rc = wait_event_timeout(stopevent.wait,
+		stopevent.state != 0,
+		msecs_to_jiffies(stopevent.timeout));
+
+	return rc;
+}
+
+static void vfe_7x_release(struct platform_device *pdev)
+{
+	mutex_lock(&vfe_lock);
+	vfe_syncdata = NULL;
+	mutex_unlock(&vfe_lock);
+
+	if (!vfestopped) {
+		CDBG("%s:%d:Calling vfe_7x_stop()\n", __func__, __LINE__);
+		vfe_7x_stop();
+	} else
+		vfestopped = 0;
+
+	msm_adsp_disable(qcam_mod);
+	msm_adsp_disable(vfe_mod);
+
+	msm_adsp_put(qcam_mod);
+	msm_adsp_put(vfe_mod);
+
+	msm_camio_disable(pdev);
+
+	kfree(extdata);
+	extlen = 0;
+
+	msm_camio_set_perf_lvl(S_EXIT);
+}
+
+static int vfe_7x_init(struct msm_vfe_callback *presp,
+	struct platform_device *dev)
+{
+	int rc = 0;
+
+	init_waitqueue_head(&stopevent.wait);
+	stopevent.timeout = 200;
+	stopevent.state = 0;
+
+	if (presp && presp->vfe_resp)
+		resp = presp;
+	else
+		return -EFAULT;
+
+	/* Bring up all the required GPIOs and Clocks */
+	rc = msm_camio_enable(dev);
+	if (rc < 0)
+		return rc;
+
+	extlen = sizeof(struct vfe_frame_extra);
+
+	extdata = kmalloc(extlen, GFP_ATOMIC);
+	if (!extdata) {
+		rc = -ENOMEM;
+		goto init_fail;
+	}
+
+	rc = msm_adsp_get("QCAMTASK", &qcam_mod, &vfe_7x_sync, NULL);
+	if (rc) {
+		rc = -EBUSY;
+		goto get_qcam_fail;
+	}
+
+	rc = msm_adsp_get("VFETASK", &vfe_mod, &vfe_7x_sync, NULL);
+	if (rc) {
+		rc = -EBUSY;
+		goto get_vfe_fail;
+	}
+
+	return 0;
+
+get_vfe_fail:
+	msm_adsp_put(qcam_mod);
+get_qcam_fail:
+	kfree(extdata);
+init_fail:
+	extlen = 0;
+	return rc;
+}
+
+static int vfe_7x_config_axi(int mode,
+	struct axidata *ad, struct axiout *ao)
+{
+	struct msm_pmem_region *regptr;
+	unsigned long *bptr;
+	int    cnt;
+
+	int rc = 0;
+
+	if (mode == OUTPUT_1 || mode == OUTPUT_1_AND_2) {
+		regptr = ad->region;
+
+		CDBG("bufnum1 = %d\n", ad->bufnum1);
+		if (mode == OUTPUT_1_AND_2) {
+			paddr_t_y = regptr->paddr + regptr->info.y_off;
+			paddr_t_cbcr = regptr->paddr +  regptr->info.cbcr_off;
+		}
+
+		CDBG("config_axi1: O1, phy = 0x%lx, y_off = %d, cbcr_off =%d\n",
+			regptr->paddr, regptr->info.y_off,
+			regptr->info.cbcr_off);
+
+		bptr = &ao->output1buffer1_y_phy;
+		for (cnt = 0; cnt < ad->bufnum1; cnt++) {
+			*bptr = regptr->paddr + regptr->info.y_off;
+			bptr++;
+			*bptr = regptr->paddr + regptr->info.cbcr_off;
+
+			bptr++;
+			regptr++;
+		}
+
+		regptr--;
+		for (cnt = 0; cnt < (8 - ad->bufnum1); cnt++) {
+			*bptr = regptr->paddr + regptr->info.y_off;
+			bptr++;
+			*bptr = regptr->paddr + regptr->info.cbcr_off;
+			bptr++;
+		}
+	}
+
+	if (mode == OUTPUT_2 || mode == OUTPUT_1_AND_2) {
+		regptr = &(ad->region[ad->bufnum1]);
+
+		CDBG("bufnum2 = %d\n", ad->bufnum2);
+		paddr_s_y = regptr->paddr +  regptr->info.y_off;
+		paddr_s_cbcr = regptr->paddr +  regptr->info.cbcr_off;
+
+		CDBG("config_axi2: O2, phy = 0x%lx, y_off = %d, cbcr_off =%d\n",
+		     regptr->paddr, regptr->info.y_off, regptr->info.cbcr_off);
+
+		bptr = &ao->output2buffer1_y_phy;
+		for (cnt = 0; cnt < ad->bufnum2; cnt++) {
+			*bptr = regptr->paddr + regptr->info.y_off;
+			bptr++;
+			*bptr = regptr->paddr + regptr->info.cbcr_off;
+
+			bptr++;
+			regptr++;
+		}
+
+		regptr--;
+		for (cnt = 0; cnt < (8 - ad->bufnum2); cnt++) {
+			*bptr = regptr->paddr + regptr->info.y_off;
+			bptr++;
+			*bptr = regptr->paddr + regptr->info.cbcr_off;
+			bptr++;
+		}
+	}
+
+	return rc;
+}
+
+static int vfe_7x_config(struct msm_vfe_cfg_cmd *cmd, void *data)
+{
+	struct msm_pmem_region *regptr;
+	unsigned char buf[256];
+
+	struct vfe_stats_ack sack;
+	struct axidata *axid;
+	uint32_t i;
+	uint32_t *_mode;
+
+	struct vfe_stats_we_cfg *scfg = NULL;
+	struct vfe_stats_af_cfg *sfcfg = NULL;
+
+	struct axiout *axio = NULL;
+	void   *cmd_data = NULL;
+	void   *cmd_data_alloc = NULL;
+	long rc = 0;
+	struct msm_vfe_command_7k *vfecmd;
+
+	vfecmd = kmalloc(sizeof(struct msm_vfe_command_7k), GFP_ATOMIC);
+	if (!vfecmd) {
+		pr_err("vfecmd alloc failed!\n");
+		return -ENOMEM;
+	}
+
+	if (cmd->cmd_type != CMD_FRAME_BUF_RELEASE &&
+	    cmd->cmd_type != CMD_STATS_BUF_RELEASE &&
+	    cmd->cmd_type != CMD_STATS_AF_BUF_RELEASE) {
+		if (copy_from_user(vfecmd,
+				(void __user *)(cmd->value),
+				sizeof(struct msm_vfe_command_7k))) {
+			rc = -EFAULT;
+			goto config_failure;
+		}
+	}
+
+	switch (cmd->cmd_type) {
+	case CMD_STATS_AEC_AWB_ENABLE:
+	case CMD_STATS_AXI_CFG: {
+		axid = data;
+		if (!axid) {
+			rc = -EFAULT;
+			goto config_failure;
+		}
+
+		scfg =
+			kmalloc(sizeof(struct vfe_stats_we_cfg),
+				GFP_ATOMIC);
+		if (!scfg) {
+			rc = -ENOMEM;
+			goto config_failure;
+		}
+
+		if (copy_from_user(scfg,
+					(void __user *)(vfecmd->value),
+					vfecmd->length)) {
+
+			rc = -EFAULT;
+			goto config_done;
+		}
+
+		CDBG("STATS_ENABLE: bufnum = %d, enabling = %d\n",
+			axid->bufnum1, scfg->wb_expstatsenable);
+
+		if (axid->bufnum1 > 0) {
+			regptr = axid->region;
+
+			for (i = 0; i < axid->bufnum1; i++) {
+
+				CDBG("STATS_ENABLE, phy = 0x%lx\n",
+					regptr->paddr);
+
+				scfg->wb_expstatoutputbuffer[i] =
+					(void *)regptr->paddr;
+				regptr++;
+			}
+
+			cmd_data = scfg;
+
+		} else {
+			rc = -EINVAL;
+			goto config_done;
+		}
+	}
+		break;
+	case CMD_STATS_AF_ENABLE:
+	case CMD_STATS_AF_AXI_CFG: {
+		axid = data;
+		if (!axid) {
+			rc = -EFAULT;
+			goto config_failure;
+		}
+
+		sfcfg =
+			kmalloc(sizeof(struct vfe_stats_af_cfg),
+				GFP_ATOMIC);
+
+		if (!sfcfg) {
+			rc = -ENOMEM;
+			goto config_failure;
+		}
+
+		if (copy_from_user(sfcfg,
+					(void __user *)(vfecmd->value),
+					vfecmd->length)) {
+
+			rc = -EFAULT;
+			goto config_done;
+		}
+
+		CDBG("AF_ENABLE: bufnum = %d, enabling = %d\n",
+			axid->bufnum1, sfcfg->af_enable);
+
+		if (axid->bufnum1 > 0) {
+			regptr = &axid->region[0];
+
+			for (i = 0; i < axid->bufnum1; i++) {
+
+				CDBG("STATS_ENABLE, phy = 0x%lx\n",
+					regptr->paddr);
+
+				sfcfg->af_outbuf[i] =
+					(void *)regptr->paddr;
+
+				regptr++;
+			}
+
+			cmd_data = sfcfg;
+
+		} else {
+			rc = -EINVAL;
+			goto config_done;
+		}
+	}
+		break;
+	case CMD_FRAME_BUF_RELEASE: {
+		struct msm_frame *b;
+		unsigned long p;
+		struct vfe_outputack fack;
+		if (!data)  {
+			rc = -EFAULT;
+			goto config_failure;
+		}
+
+		b = (struct msm_frame *)(cmd->value);
+		p = *(unsigned long *)data;
+
+		fack.header = VFE_FRAME_ACK;
+
+		fack.output2newybufferaddress =
+			(void *)(p + b->y_off);
+
+		fack.output2newcbcrbufferaddress =
+			(void *)(p + b->cbcr_off);
+
+		vfecmd->queue = QDSP_CMDQUEUE;
+		vfecmd->length = sizeof(struct vfe_outputack);
+		cmd_data = &fack;
+	}
+		break;
+	case CMD_SNAP_BUF_RELEASE:
+		break;
+	case CMD_STATS_BUF_RELEASE: {
+		CDBG("vfe_7x_config: CMD_STATS_BUF_RELEASE\n");
+		if (!data) {
+			rc = -EFAULT;
+			goto config_failure;
+		}
+
+		sack.header = STATS_WE_ACK;
+		sack.bufaddr = (void *)*(uint32_t *)data;
+
+		vfecmd->queue  = QDSP_CMDQUEUE;
+		vfecmd->length = sizeof(struct vfe_stats_ack);
+		cmd_data = &sack;
+	}
+		break;
+	case CMD_STATS_AF_BUF_RELEASE: {
+		CDBG("vfe_7x_config: CMD_STATS_AF_BUF_RELEASE\n");
+		if (!data) {
+			rc = -EFAULT;
+			goto config_failure;
+		}
+
+		sack.header = STATS_AF_ACK;
+		sack.bufaddr = (void *)*(uint32_t *)data;
+
+		vfecmd->queue  = QDSP_CMDQUEUE;
+		vfecmd->length = sizeof(struct vfe_stats_ack);
+		cmd_data = &sack;
+	}
+		break;
+	case CMD_GENERAL:
+	case CMD_STATS_DISABLE: {
+		if (vfecmd->length > 256) {
+			cmd_data_alloc =
+			cmd_data = kmalloc(vfecmd->length, GFP_ATOMIC);
+			if (!cmd_data) {
+				rc = -ENOMEM;
+				goto config_failure;
+			}
+		} else
+			cmd_data = buf;
+
+		if (copy_from_user(cmd_data,
+					(void __user *)(vfecmd->value),
+					vfecmd->length)) {
+
+			rc = -EFAULT;
+			goto config_done;
+		}
+
+		if (vfecmd->queue == QDSP_CMDQUEUE) {
+			switch (*(uint32_t *)cmd_data) {
+			case VFE_RESET_CMD:
+				msm_camio_vfe_blk_reset();
+				vfestopped = 0;
+				break;
+			case VFE_START_CMD:
+				_mode = (uint32_t *)cmd_data;
+				op_mode = *(++_mode);
+				if (op_mode & SNAPSHOT_MASK_MODE)
+					msm_camio_set_perf_lvl(S_CAPTURE);
+				else
+					msm_camio_set_perf_lvl(S_PREVIEW);
+				vfestopped = 0;
+				break;
+			case VFE_STOP_CMD:
+				vfestopped = 1;
+				goto config_send;
+
+			default:
+				break;
+			}
+		} /* QDSP_CMDQUEUE */
+	}
+		break;
+	case CMD_AXI_CFG_PREVIEW:
+	case CMD_RAW_PICT_AXI_CFG: {
+		axid = data;
+		if (!axid) {
+			rc = -EFAULT;
+			goto config_failure;
+		}
+
+		axio = kmalloc(sizeof(struct axiout), GFP_ATOMIC);
+		if (!axio) {
+			rc = -ENOMEM;
+			goto config_failure;
+		}
+
+		if (copy_from_user(axio, (void __user *)(vfecmd->value),
+					sizeof(struct axiout))) {
+			rc = -EFAULT;
+			goto config_done;
+		}
+
+		vfe_7x_config_axi(OUTPUT_2, axid, axio);
+		cmd_data = axio;
+	}
+		break;
+	case CMD_AXI_CFG_SNAP: {
+		axid = data;
+		if (!axid) {
+			rc = -EFAULT;
+			goto config_failure;
+		}
+
+		axio = kmalloc(sizeof(struct axiout), GFP_ATOMIC);
+		if (!axio) {
+			rc = -ENOMEM;
+			goto config_failure;
+		}
+
+		if (copy_from_user(axio, (void __user *)(vfecmd->value),
+					sizeof(struct axiout))) {
+			rc = -EFAULT;
+			goto config_done;
+		}
+
+		vfe_7x_config_axi(OUTPUT_1_AND_2, axid, axio);
+
+		cmd_data = axio;
+	}
+		break;
+	default:
+		break;
+	}
+
+	if (vfestopped)
+		goto config_done;
+
+config_send:
+	CDBG("send adsp command = %d\n", *(uint32_t *)cmd_data);
+	rc = msm_adsp_write(vfe_mod, vfecmd->queue,
+				cmd_data, vfecmd->length);
+
+config_done:
+	kfree(cmd_data_alloc);
+
+config_failure:
+	kfree(scfg);
+	kfree(axio);
+	kfree(vfecmd);
+	return rc;
+}
+
+void msm_camvfe_fn_init(struct msm_camvfe_fn *fptr, void *data)
+{
+	mutex_init(&vfe_lock);
+	fptr->vfe_init    = vfe_7x_init;
+	fptr->vfe_enable  = vfe_7x_enable;
+	fptr->vfe_config  = vfe_7x_config;
+	fptr->vfe_disable = vfe_7x_disable;
+	fptr->vfe_release = vfe_7x_release;
+	vfe_syncdata = data;
+}
+
+void msm_camvpe_fn_init(struct msm_camvpe_fn *fptr, void *data)
+{
+	fptr->vpe_reg		= NULL;
+	fptr->send_frame_to_vpe	= NULL;
+	fptr->vpe_config	= NULL;
+	fptr->vpe_cfg_update	= NULL;
+	fptr->dis		= NULL;
+}
diff --git a/drivers/media/video/msm/sec_cam_pmic.c b/drivers/media/video/msm/sec_cam_pmic.c
new file mode 100644
index 0000000..64adb7e
--- /dev/null
+++ b/drivers/media/video/msm/sec_cam_pmic.c
@@ -0,0 +1,197 @@
+
+/***************************************************************
+CAMERA Power control
+****************************************************************/
+
+#include "sec_cam_pmic.h"
+
+#include <mach/gpio.h>
+#include <linux/gpio.h>
+
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <mach/board.h>
+#include <mach/msm_iomap.h>
+
+#include <linux/regulator/consumer.h>
+#include <mach/vreg.h>
+#include <mach/camera.h>
+#include "sec_cam_pmic.h"
+#define CAM_TEST_REV03		/*temp, rev03 */
+
+/*struct regulator *l6, *l15, *l17*/
+struct regulator *l6, *l15, *l17;
+struct regulator *s2, *s3;
+
+/*
+#ifdef CAM_TEST_REV03
+struct regulator *l8, *l15, *l10, *lvs0,  *s2, *lvs1;//temp
+#else
+struct regulator *l8, *l15, *l24, *lvs0,  *s2, *lvs1;
+#endif
+*/
+
+/* CAM power
+	CAM_SENSOR_A_2.8		:  VREG_L17		: l17
+	CAM_SENSOR_IO_1.8	: VREG_L15		: l15
+	3M_CORE_1.2			: VREG_L6		: l6
+
+	3M_AF_2.8			: VREG_L15A		: l15
+	VT_CORE_1.8			: VREG_L10A		: 10
+	VT_CAM_1.5			: VREG_L10A		: l10
+*/
+void cam_ldo_power_on2(void)
+{
+	int ret;
+	pr_info("#### cam_ldo_power_on ####\n");
+}
+
+
+#if defined(CONFIG_SR300PC20)
+/* CAM power
+	CAM_SENSOR_A_2.8		:  VREG_L17		: l17
+	CAM_SENSOR_IO_1.8	: VREG_L15		: l15
+	3M_CORE_1.2			: VREG_L6		: l6
+*/
+void cam_ldo_power_on(void)
+{
+	int ret;
+	struct vreg *l6, *l15, *l17;
+	unsigned int mclk_cfg;
+	pr_info("#### cam_ldo_power_on ####\n");
+
+	l15 = vreg_get(NULL, "vcamio");
+
+	if (!l15)
+		pr_err("[SR300PC20]%s: VREG L15 get failed\n", __func__);
+
+	if (vreg_set_level(l15, 1800))
+		pr_err("[SR300PC20]%s: vreg_set_level failed\n", __func__);
+
+	if (vreg_enable(l15))
+		pr_err("[SR300PC20]%s: reg_enable failed\n", __func__);
+
+	usleep(10);
+
+	l17 = vreg_get(NULL, "vcama");
+
+	if (!l17)
+		pr_err("[SR300PC20]%s: VREG L17 get failed\n", __func__);
+
+	if (vreg_set_level(l17, 2800))
+		pr_err("[SR300PC20]%s: vreg_set_level failed\n", __func__);
+
+	if (vreg_enable(l17))
+		pr_err("![SR300PC20]%s: reg_enable failed\n", __func__);
+
+	usleep(10);
+
+	l6 = vreg_get(NULL, "vcamc");
+
+	if (!l6)
+		pr_err("[SR300PC20]%s: VREG L6 get failed\n", __func__);
+
+	if (vreg_set_level(l6, 1200))
+		pr_err("[SR300PC20]%s: vreg_set_level failed\n", __func__);
+
+	if (vreg_enable(l6))
+		pr_err("!![SR300PC20]%s:   reg_enable failed\n", __func__);
+
+	usleep(10);
+}
+
+void cam_ldo_power_off(void)
+{
+	int ret;
+	struct vreg *l6, *l15, *l17;
+
+	pr_info("#### cam_ldo_power_off ####\n");
+
+	l6 = vreg_get(NULL, "vcamc");
+	l15 = vreg_get(NULL, "vcamio");
+	l17 = vreg_get(NULL, "vcama");
+
+	vreg_disable(l6);
+	usleep(10);
+
+	vreg_disable(l17);
+	usleep(10);
+
+	vreg_disable(l15);
+	usleep(10);
+
+	gpio_set_value_cansleep(CAM_IO_EN, LOW);
+
+}
+#else  /* no CONFIG_SR300PC20 */
+void cam_ldo_power_on(void)
+{
+	int ret;
+	struct vreg *l6, *l15, *l17;
+	unsigned int mclk_cfg;
+	pr_info("#### cam_ldo_power_on ####\n");
+
+	l17 = vreg_get(NULL, "vcama");
+
+	if (!l17)
+		pr_info("[S5K5CCAF]%s: VREG L17 get failed\n", __func__);
+
+	if (vreg_set_level(l17, 2800))
+		pr_info("[S5K5CCAF]%s: vreg_set_level failed\n", __func__);
+
+	if (vreg_enable(l17))
+		pr_info("![S5K5CCAF]%s: reg_enable failed\n", __func__);
+
+	usleep(10000);
+
+	l6 = vreg_get(NULL, "vcamc");
+
+	if (!l6)
+		pr_info("[S5K5CCAF]%s: VREG L6 get failed\n", __func__);
+
+	if (vreg_set_level(l6, 1200))
+		pr_info("[S5K5CCAF]%s: vreg_set_level failed\n", __func__);
+
+	if (vreg_enable(l6))
+		pr_info("!![S5K5CCAF]%s:   reg_enable failed\n", __func__);
+
+	usleep(10000);
+
+	l15 = vreg_get(NULL, "vcamio");
+
+	if (!l15)
+		pr_info("[S5K5CCAF]%s: VREG L15 get failed\n", __func__);
+
+	if (vreg_set_level(l15, 1800))
+		pr_info("[S5K5CCAF]%s: vreg_set_level failed\n", __func__);
+
+	if (vreg_enable(l15))
+		pr_info("[S5K5CCAF]%s: reg_enable failed\n", __func__);
+
+	usleep(10000);
+}
+
+void cam_ldo_power_off(void)
+{
+	int ret;
+	struct vreg *l6, *l15, *l17;
+
+	pr_info("#### cam_ldo_power_off ####\n");
+
+	l6 = vreg_get(NULL, "vcamc");
+	l15 = vreg_get(NULL, "vcama");
+	l17 = vreg_get(NULL, "vcamio");
+
+	vreg_disable(l6);
+	usleep(1000);
+
+	vreg_disable(l15);
+	usleep(1000);
+
+	vreg_disable(l17);
+	usleep(1000);
+
+	gpio_set_value_cansleep(CAM_IO_EN, LOW);
+
+}
+#endif	/* end CONFIG_SR300PC20 */
diff --git a/drivers/media/video/msm/sec_cam_pmic.h b/drivers/media/video/msm/sec_cam_pmic.h
new file mode 100644
index 0000000..fc68eb6
--- /dev/null
+++ b/drivers/media/video/msm/sec_cam_pmic.h
@@ -0,0 +1,34 @@
+
+#ifndef _SEC_CAM_PMIC_H
+#define _SEC_CAM_PMIC_H
+
+
+#if 0
+#define	CAM_8M_RST		50
+#define	CAM_VGA_RST		41
+
+#define	CAM_MEGA_EN		37	
+
+#define	CAM_VGA_EN		42
+
+#define	CAM_PMIC_STBY		37	
+
+#define	CAM_IO_EN		37	
+#endif
+
+
+#define CAM_IO_EN	88
+
+#define	ON		1
+#define	OFF		0
+#define LOW		0
+#define HIGH		1
+
+void cam_ldo_power_on(void);
+void cam_ldo_power_off(void);
+void cam_ldo_power_on2(void);	//temp
+
+void s5k6aafx_ldo_power_on(void);
+
+
+#endif
diff --git a/drivers/media/video/msm/sr300pc20.c b/drivers/media/video/msm/sr300pc20.c
new file mode 100644
index 0000000..b0d05b7
--- /dev/null
+++ b/drivers/media/video/msm/sr300pc20.c
@@ -0,0 +1,1877 @@
+/* Copyright (c) 2011, Code GEIM Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+/* 1/5" sr300pc20*/
+
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/uaccess.h>
+#include <linux/miscdevice.h>
+#include <media/msm_camera.h>
+#include <linux/gpio.h>
+#include <mach/pmic.h>
+#include <linux/module.h>
+
+#if defined(CONFIG_MACH_JENA)
+#include "sr300pc20_jena.h"
+#else
+#include "sr300pc20.h"
+#endif
+
+#include <mach/camera.h>
+#include <mach/vreg.h>
+#include <linux/io.h>
+
+#include "sec_cam_pmic.h"
+
+/*#define SENSOR_DEBUG 0*/
+
+/*#define CONFIG_LOAD_FILE*/
+
+#define PCAM_ENABLE_DEBUG
+
+#ifdef PCAM_ENABLE_DEBUG
+#define CAMDRV_DEBUG(fmt, arg...)\
+	do {					\
+		pr_info("[SR300PC20_DEBUG] %s:%d:" fmt "\n",	\
+			__func__, __LINE__, ##arg);		\
+	}							\
+	while (0)
+#else
+#define CAMDRV_DEBUG(fmt, arg...)
+#endif
+
+#ifdef CONFIG_LOAD_FILE
+#define SR300PC20_WRITE_LIST(A)\
+	sr300pc20_sensor_write_list(A, (sizeof(A) / sizeof(A[0])), #A);
+#define SR300PC20_WRITE_LIST_BURST(A)\
+	sr300pc20_sensor_burst_write_list(A, (sizeof(A) / sizeof(A[0])), #A);
+#else
+#define SR300PC20_WRITE_LIST(A)\
+	sr300pc20_sensor_write_list(A, (sizeof(A) / sizeof(A[0])), #A);
+#define SR300PC20_WRITE_LIST_BURST(A)\
+	sr300pc20_sensor_burst_write_list(A, (sizeof(A) / sizeof(A[0])), #A);
+#endif
+
+#define UPTO_MSEC 1000
+
+static char first_start_camera = 1;	/*  1 is not init a sensor */
+static char set_init0;
+
+static char mEffect = EXT_CFG_EFFECT_NORMAL;
+static char mBrightness = EXT_CFG_BR_STEP_0;
+static char mContrast = EXT_CFG_CR_STEP_0;
+static char mSaturation = EXT_CFG_SA_STEP_0;
+static char mSharpness = EXT_CFG_SP_STEP_0;
+static char mWhiteBalance = EXT_CFG_WB_AUTO;
+static char mISO = EXT_CFG_ISO_AUTO;
+static char mAutoExposure = EXT_CFG_METERING_NORMAL;
+static char mScene = EXT_CFG_SCENE_OFF;
+static char mCameraMode = EXT_CFG_CAMERA_MODE;
+static char mDTP;
+static char mInit;
+
+struct sr300pc20_work {
+	struct work_struct work;
+};
+
+static struct sr300pc20_work *sr300pc20_sensorw;
+static struct i2c_client *sr300pc20_client;
+
+struct sr300pc20_ctrl {
+	const struct msm_camera_sensor_info *sensordata;
+};
+
+static unsigned int config_csi2;
+static struct sr300pc20_ctrl *sr300pc20_ctrl;
+static void sr300pc20_set_power(int status);
+static DECLARE_WAIT_QUEUE_HEAD(sr300pc20_wait_queue);
+DECLARE_MUTEX(sr300pc20_sem);
+
+static void sr300pc20_reset_power(void);
+static int sr300pc20_set_preview(void);
+
+#ifdef CONFIG_LOAD_FILE
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+
+static char *sr300pc20_regs_table;
+
+static int sr300pc20_regs_table_size;
+
+static int sr300pc20_regs_table_write(char *name);
+static int sr300pc20_regs_table_burst_write(char *name);
+
+#define MAX_SETTING_NAME 30
+#define TUNNING_FILE_PATH "/mnt/sdcard/sr300pc20.h"
+
+#endif
+
+#define BURST_MODE_BUFFER_MAX_SIZE 255
+#define BURST_REG 0x0e
+#define DELAY_REG 0xff
+unsigned char sr300pc20_buf_for_burstmode[BURST_MODE_BUFFER_MAX_SIZE];
+
+static int sr300pc20_sensor_read(unsigned char subaddr, unsigned char *data)
+{
+	int ret = 0;
+	unsigned char buf[1] = { 0 };
+	struct i2c_msg msg = { sr300pc20_client->addr, 0, 1, buf };
+
+#if defined(SENSOR_DEBUG)
+	pr_err("[ 0x%x ]\n", subaddr);
+#endif
+
+	buf[0] = (subaddr & 0xFF);
+
+	ret = i2c_transfer(sr300pc20_client->adapter, &msg, 1) == 1 ? 0 : -EIO;
+	if (ret == -EIO) {
+		pr_err("[%s : %d] i2c_transfer fail\n", __func__, __LINE__);
+		goto error;
+	}
+
+	msg.flags = I2C_M_RD;
+
+	ret = i2c_transfer(sr300pc20_client->adapter, &msg, 1) == 1 ? 0 : -EIO;
+	if (ret == -EIO) {
+		pr_err("[%s : %d] i2c_transfer fail\n", __func__, __LINE__);
+		goto error;
+	}
+
+	*data = buf[0];		/*check */
+
+error:
+	return ret;
+}
+
+static int sr300pc20_sensor_write(unsigned char subaddr, unsigned char val)
+{
+	unsigned char buf[2] = { 0 };
+	struct i2c_msg msg = { sr300pc20_client->addr, 0, 2, buf };
+
+#if defined(SENSOR_DEBUG)
+	pr_err("[ 0x%x %x ]\n", subaddr, data);
+#endif
+
+	buf[0] = (subaddr);
+	buf[1] = (val);
+
+	return i2c_transfer(sr300pc20_client->adapter, &msg, 1) == 1 ? 0 : -EIO;
+}
+
+/*static int sr300pc20_sensor_write_list
+(struct samsung_short_t *list,int size, char *name)*/
+static int sr300pc20_sensor_write_list(const u16 *list, int size, char *name)
+{
+	int ret = 0;
+	unsigned char subaddr = 0;
+	unsigned char value = 0;
+	int i = 0;
+	CAMDRV_DEBUG("%s\n", name);
+
+#ifdef CONFIG_LOAD_FILE
+	ret = sr300pc20_regs_table_write(name);
+#else
+
+	for (i = 0; i < size; i++) {
+		subaddr = (list[i] >> 8);	/*address */
+		value = (list[i] & 0xFF);	/*value */
+
+		if (subaddr == DELAY_REG) {
+			msleep(value * 10);	/*one step is 10ms */
+			CAMDRV_DEBUG("[sr300pc20] msleep %d msec\n",
+				     value * 10);
+		} else {
+			if (sr300pc20_sensor_write(subaddr, value) < 0) {
+				pr_err
+				    ("[%s : %d] sr300pc20_sensor_write fail\n",
+				     __func__, __LINE__);
+				return -EIO;
+			}
+		}
+	}
+#endif
+	return ret;
+}
+
+static int sr300pc20_sensor_burst_write_list(const u16 *list, int size,
+					     char *name)
+{
+	int err = -EINVAL;
+	int i = 0;
+	int idx = 0;
+	unsigned short subaddr = 0;
+	unsigned short value = 0;
+	int burst_flag = 0;
+	int burst_cnt = 0;
+	struct i2c_msg msg = { sr300pc20_client->addr,
+		0, 0, sr300pc20_buf_for_burstmode
+	};
+
+	CAMDRV_DEBUG("%s, size = %d\n", name, size);
+
+#ifdef CONFIG_LOAD_FILE
+	err = sr300pc20_regs_table_burst_write(name);
+#else
+	for (i = 0; i < size; i++) {
+		if (idx > (BURST_MODE_BUFFER_MAX_SIZE - 10)) {
+			pr_err("[%s:%d]Burst mode buffer overflow! "
+			       "Burst Count %d\n",
+			       __func__, __LINE__, burst_cnt);
+			pr_err("[%s:%d]count %d, addr %x "
+			       "value %x\n", __func__, __LINE__, i,
+			       (list[i] >> 8) & 0xff, list[i] & 0xFF);
+			pr_err("[%s:%d]addr %x value %x\n",
+			       __func__, __LINE__,
+			       (list[i - 1] >> 8) & 0xff, list[i - 1] & 0xFF);
+			pr_err("[%s:%d]addr %x value %x\n",
+			       __func__, __LINE__,
+			       (list[i - 2] >> 8) & 0xff, list[i - 2] & 0xFF);
+			err = -EIO;
+			return err;
+		}
+		subaddr = (list[i] >> 8);
+		value = (list[i] & 0xFF);
+		if (burst_flag == 0) {
+			switch (subaddr) {
+			case BURST_REG:
+				if (value != 0x00) {
+					burst_flag = 1;
+					burst_cnt++;
+				}
+				break;
+			case DELAY_REG:
+				msleep(value * 10);	/* a step is 10ms */
+				break;
+			default:
+				idx = 0;
+				err = sr300pc20_sensor_write(subaddr, value);
+				break;
+			}
+		} else if (burst_flag == 1) {
+			if (subaddr == BURST_REG && value == 0x00) {
+				msg.len = idx;
+				CAMDRV_DEBUG("burst_cnt %d, idx %d\n",
+					     burst_cnt, idx);
+				err = i2c_transfer(sr300pc20_client->adapter,
+						   &msg, 1);
+				if (err < 0) {
+					pr_err("[%s:%d]Burst write fail!\n",
+					       __func__, __LINE__);
+					return err;
+				}
+				idx = 0;
+				burst_flag = 0;
+			} else {
+				if (idx == 0) {
+					sr300pc20_buf_for_burstmode[idx++] =
+					    subaddr;
+					sr300pc20_buf_for_burstmode[idx++] =
+					    value;
+				} else {
+					sr300pc20_buf_for_burstmode[idx++] =
+					    value;
+				}
+			}
+		}
+	}
+#endif
+
+	if (unlikely(err < 0)) {
+		pr_err("[%s:%d] register set failed\n", __func__, __LINE__);
+		return err;
+	}
+
+	return err;
+}
+
+static int sr300pc20_effect_control(char value)
+{
+	int err = 0;
+
+	CAMDRV_DEBUG("Enter [value = %d]\n", value);
+
+	switch (value) {
+	case EXT_CFG_EFFECT_NORMAL:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_effect_off);
+		}
+		break;
+
+	case EXT_CFG_EFFECT_NEGATIVE:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_effect_negative);
+		}
+		break;
+
+	case EXT_CFG_EFFECT_MONO:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_effect_mono);
+		}
+		break;
+
+	case EXT_CFG_EFFECT_SEPIA:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_effect_sepia);
+		}
+		break;
+
+	default:{
+			pr_warning(" Unexpected Effect mode :" "%d\n", value);
+		}
+		break;
+	}
+
+	if (err != 0)
+		pr_err("[%s : %d] %d fail\n", __func__, __LINE__, value);
+	else
+		CAMDRV_DEBUG("Exit!!\n");
+
+	return err;
+}
+
+static int sr300pc20_whitebalance_control(char value)
+{
+	int err = 0;
+
+	CAMDRV_DEBUG("Enter [value = %d]\n", value);
+
+	switch (value) {
+	case EXT_CFG_WB_AUTO:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_wb_auto);
+		}
+		break;
+
+	case EXT_CFG_WB_DAYLIGHT:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_wb_daylight);
+		}
+		break;
+
+	case EXT_CFG_WB_CLOUDY:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_wb_cloudy);
+		}
+		break;
+
+	case EXT_CFG_WB_FLUORESCENT:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_wb_fluorescent);
+		}
+		break;
+
+	case EXT_CFG_WB_INCANDESCENT:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_wb_incandescent);
+		}
+		break;
+
+	default:{
+			pr_warning(" Unexpected WB mode : %d\n", value);
+		}
+		break;
+
+	}
+
+	if (err != 0)
+		pr_err("[%s : %d] %d fail\n", __func__, __LINE__, value);
+	else
+		CAMDRV_DEBUG("Exit!!\n");
+
+	return err;
+}
+
+static int sr300pc20_brightness_control(char value)
+{
+
+	int err = 0;
+
+	CAMDRV_DEBUG("Enter [value = %d]\n", value);
+
+	switch (value) {
+	case EXT_CFG_BR_STEP_P_4:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_brightness_p_4);
+		}
+		break;
+
+	case EXT_CFG_BR_STEP_P_3:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_brightness_p_3);
+		}
+		break;
+
+	case EXT_CFG_BR_STEP_P_2:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_brightness_p_2);
+		}
+		break;
+
+	case EXT_CFG_BR_STEP_P_1:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_brightness_p_1);
+		}
+		break;
+
+	case EXT_CFG_BR_STEP_0:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_brightness_0);
+		}
+		break;
+
+	case EXT_CFG_BR_STEP_M_1:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_brightness_m_1);
+		}
+		break;
+
+	case EXT_CFG_BR_STEP_M_2:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_brightness_m_2);
+		}
+		break;
+
+	case EXT_CFG_BR_STEP_M_3:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_brightness_m_3);
+		}
+		break;
+
+	case EXT_CFG_BR_STEP_M_4:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_brightness_m_4);
+		}
+		break;
+
+	default:{
+			pr_warning(" Unexpected BR mode : %d\n", value);
+		}
+		break;
+
+	}
+
+	if (err != 0)
+		pr_err("[%s : %d] %d fail\n", __func__, __LINE__, value);
+	else
+		CAMDRV_DEBUG("Exit!!\n");
+
+	return err;
+}
+
+static int sr300pc20_iso_control(char value)
+{
+	int err = 0;
+
+	CAMDRV_DEBUG("Enter [value = %d]\n", value);
+
+	switch (value) {
+	case EXT_CFG_ISO_AUTO:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_iso_auto);
+		}
+		break;
+
+	case EXT_CFG_ISO_50:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_iso_50);
+		}
+		break;
+
+	case EXT_CFG_ISO_100:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_iso_100);
+		}
+		break;
+
+	case EXT_CFG_ISO_200:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_iso_200);
+		}
+		break;
+
+	case EXT_CFG_ISO_400:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_iso_400);
+		}
+		break;
+
+	default:{
+			pr_warning(" Unexpected ISO mode : %d\n", value);
+		}
+		break;
+
+	}
+
+	if (err != 0)
+		pr_err("[%s : %d] %d fail\n", __func__, __LINE__, value);
+	else
+		CAMDRV_DEBUG("Exit!!\n");
+
+	return err;
+}
+
+static int sr300pc20_metering_control(char value)
+{
+	int err = 0;
+
+	CAMDRV_DEBUG("Enter [value = %d]\n", value);
+
+	switch (value) {
+	case EXT_CFG_METERING_NORMAL:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_metering_normal);
+		}
+		break;
+
+	case EXT_CFG_METERING_SPOT:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_metering_spot);
+		}
+		break;
+
+	case EXT_CFG_METERING_CENTER:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_metering_center);
+		}
+		break;
+
+	default:{
+			pr_warning(" Unexpected METERING mode : %d\n", value);
+		}
+		break;
+	}
+
+	if (err != 0)
+		pr_err("[%s : %d] %d fail\n", __func__, __LINE__, value);
+	else
+		CAMDRV_DEBUG("Exit!!\n");
+
+	return err;
+}
+
+static int sr300pc20_scene_control(char value)
+{
+	int err = 0;
+
+	CAMDRV_DEBUG("Enter [value = %d]\n", value);
+
+	err = SR300PC20_WRITE_LIST(sr300pc20_scene_off);
+	if (err != 0)
+		pr_err("[%s : %d] sr300pc20_scene_off control fail\n",
+		       __func__, __LINE__);
+
+
+	if (value != EXT_CFG_SCENE_OFF) {
+		err = SR300PC20_WRITE_LIST(sr300pc20_effect_off);
+		if (err != 0)
+			pr_err("[%s : %d] sr300pc20_effect_off control fail\n",
+					__func__, __LINE__);
+	}
+
+
+
+
+
+	switch (value) {
+	case EXT_CFG_SCENE_OFF:
+		break;
+
+	case EXT_CFG_SCENE_PORTRAIT:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_scene_portrait);
+		}
+		break;
+
+	case EXT_CFG_SCENE_LANDSCAPE:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_scene_landscape);
+		}
+		break;
+
+	case EXT_CFG_SCENE_SPORTS:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_scene_sports);
+		}
+		break;
+
+	case EXT_CFG_SCENE_PARTY:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_scene_party);
+		}
+		break;
+
+	case EXT_CFG_SCENE_BEACH:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_scene_beach);
+		}
+		break;
+
+	case EXT_CFG_SCENE_SUNSET:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_scene_sunset);
+		}
+		break;
+
+	case EXT_CFG_SCENE_DAWN:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_scene_dawn);
+		}
+		break;
+
+	case EXT_CFG_SCENE_FALL:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_scene_fall);
+		}
+		break;
+
+	case EXT_CFG_SCENE_NIGHTSHOT:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_scene_nightshot);
+		}
+		break;
+
+	case EXT_CFG_SCENE_BACKLIGHT:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_scene_backlight);
+		}
+		break;
+
+	case EXT_CFG_SCENE_FIREWORK:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_scene_firework);
+		}
+		break;
+
+	case EXT_CFG_SCENE_TEXT:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_scene_text);
+		}
+		break;
+
+	case EXT_CFG_SCENE_CANDLE:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_scene_candle);
+		}
+		break;
+
+	default:{
+			pr_warning(" Unexpected SCENE mode : %d\n", value);
+		}
+		break;
+	}
+
+	if (err != 0)
+		pr_err("[%s : %d] %d fail\n", __func__, __LINE__, value);
+	else
+		CAMDRV_DEBUG("Exit!!\n");
+
+	return err;
+}
+
+static int sr300pc20_contrast_control(char value)
+{
+	int err = 0;
+
+	CAMDRV_DEBUG("Enter [value = %d]\n", value);
+
+	switch (value) {
+	case EXT_CFG_CR_STEP_M_2:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_contrast_m_2);
+		}
+		break;
+
+	case EXT_CFG_CR_STEP_M_1:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_contrast_m_1);
+		}
+		break;
+
+	case EXT_CFG_CR_STEP_0:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_contrast_0);
+		}
+		break;
+
+	case EXT_CFG_CR_STEP_P_1:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_contrast_p_1);
+		}
+		break;
+
+	case EXT_CFG_CR_STEP_P_2:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_contrast_p_2);
+		}
+		break;
+
+	default:{
+			pr_warning
+			    (" Unexpected EXT_CFG_CR_CONTROL mode :"
+			     "%d\n", value);
+		}
+		break;
+	}
+
+	if (err != 0)
+		pr_err("[%s : %d] %d fail\n", __func__, __LINE__, value);
+	else
+		CAMDRV_DEBUG("Exit!!\n");
+
+	return err;
+}
+
+static int sr300pc20_saturation_control(char value)
+{
+	int err = 0;
+
+	CAMDRV_DEBUG("Enter [value = %d]\n", value);
+
+	switch (value) {
+	case EXT_CFG_SA_STEP_M_2:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_saturation_m_2);
+		}
+		break;
+
+	case EXT_CFG_SA_STEP_M_1:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_saturation_m_1);
+		}
+		break;
+
+	case EXT_CFG_SA_STEP_0:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_saturation_0);
+		}
+		break;
+
+	case EXT_CFG_SA_STEP_P_1:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_saturation_p_1);
+		}
+		break;
+
+	case EXT_CFG_SA_STEP_P_2:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_saturation_p_2);
+		}
+		break;
+
+	default:{
+			pr_warning
+			    (" Unexpected EXT_CFG_SA_CONTROL mode :"
+			     "%d\n", value);
+		}
+		break;
+	}
+
+	if (err != 0)
+		pr_err("[%s : %d] %d fail\n", __func__, __LINE__, value);
+	else
+		CAMDRV_DEBUG("Exit!!\n");
+
+	return err;
+}
+
+static int sr300pc20_sharpness_control(char value)
+{
+	int err = 0;
+
+	CAMDRV_DEBUG("Enter [value = %d]\n", value);
+
+	switch (value) {
+	case EXT_CFG_SP_STEP_M_2:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_sharpness_m_2);
+		}
+		break;
+
+	case EXT_CFG_SP_STEP_M_1:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_sharpness_m_1);
+		}
+		break;
+
+	case EXT_CFG_SP_STEP_0:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_sharpness_0);
+		}
+		break;
+
+	case EXT_CFG_SP_STEP_P_1:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_sharpness_p_1);
+		}
+		break;
+
+	case EXT_CFG_SP_STEP_P_2:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_sharpness_p_2);
+		}
+		break;
+
+	default:{
+			pr_warning
+			    (" Unexpected EXT_CFG_SP_CONTROL mode :"
+			     "%d\n", value);
+		}
+		break;
+	}
+
+	if (err != 0)
+		pr_err("[%s : %d] %d fail\n", __func__, __LINE__, value);
+	else
+		CAMDRV_DEBUG("Exit!!\n");
+
+	return err;
+}
+
+static int sr300pc20_DTP_control(char value)
+{
+	int err = 0;
+
+	CAMDRV_DEBUG("[%s]\n", value ? "DTP ON" : "DTP OFF");
+
+	switch (value) {
+	case EXT_CFG_DTP_OFF:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_dtp_off);
+			first_start_camera = 1;
+			/*sr300pc20_set_preview(); */
+		}
+		break;
+
+	case EXT_CFG_DTP_ON:{
+			err = SR300PC20_WRITE_LIST(sr300pc20_dtp_on);
+		}
+		break;
+
+	default:{
+			pr_warning(" unexpected DTP control\n");
+		}
+		break;
+	}
+
+	if (err != 0)
+		pr_err("[%s : %d] %d fail\n", __func__, __LINE__, value);
+	else
+		CAMDRV_DEBUG("Exit!!\n");
+
+	return err;
+}
+
+static int sr300pc20_sensor_ext_config(void __user *arg)
+{
+	int err = 0;
+	ioctl_pcam_info_8bit ctrl_info;
+
+	if (copy_from_user
+	    ((void *)&ctrl_info, (const void *)arg, sizeof(ctrl_info))) {
+		pr_err(" %s fail copy_from_user!\n", __func__);
+	}
+
+	CAMDRV_DEBUG("%d %d %d %d %d\n",
+		     ctrl_info.mode, ctrl_info.address, ctrl_info.value_1,
+		     ctrl_info.value_2, ctrl_info.value_3);
+
+	if (mScene != EXT_CFG_SCENE_OFF) {
+		if (ctrl_info.mode == EXT_CFG_EFFECT_CONTROL ||
+		    ctrl_info.mode == EXT_CFG_WB_CONTROL ||
+		    ctrl_info.mode == EXT_CFG_BR_CONTROL ||
+		    ctrl_info.mode == EXT_CFG_ISO_CONTROL ||
+		    ctrl_info.mode == EXT_CFG_METERING_CONTROL ||
+		    ctrl_info.mode == EXT_CFG_CR_CONTROL ||
+		    ctrl_info.mode == EXT_CFG_SA_CONTROL ||
+		    ctrl_info.mode == EXT_CFG_SP_CONTROL) {
+			pr_warn("[%s : %d]It doesn't accept this control "
+				"because now scene mode is set!!\n",
+				__func__, __LINE__);
+			pr_warn("[%s : %d]This mode is %d\n\n",
+				__func__, __LINE__, ctrl_info.mode);
+			return err;
+		}
+	}
+
+	switch (ctrl_info.mode) {
+	case EXT_CFG_GET_INFO:{
+/* EXT_CFG_GET_INFO cmd means driver transfers sensor information*/
+/* to upper layer. In case of this exposure time and ISO */
+			unsigned short lsb = 0, msb = 0;
+			unsigned short a_gain = 0;
+			unsigned char data = 0;
+
+			/* page mode 0x20 */
+			sr300pc20_sensor_write(0x03, 0x20);
+
+			/* read exposure time */
+			sr300pc20_sensor_read(0xa0, &data);
+			msb = (unsigned short)data;
+			sr300pc20_sensor_read(0xa1, &data);
+			msb = (msb << 8) | (unsigned short)data;
+			sr300pc20_sensor_read(0xa2, &data);
+			lsb = (unsigned short)data;
+			sr300pc20_sensor_read(0xa3, &data);
+			lsb = (lsb << 8) | (unsigned short)data;
+
+			/* read ISO gain */
+			sr300pc20_sensor_read(0x50, &data);
+			a_gain = (unsigned short)data;
+
+			ctrl_info.value_1 = lsb;
+			ctrl_info.value_2 = msb;
+			ctrl_info.value_3 = a_gain;
+			CAMDRV_DEBUG("exposure %x\n", (msb << 16) | lsb);
+			CAMDRV_DEBUG("ISO gain is %x\n", a_gain);
+		}
+		break;
+
+	case EXT_CFG_FRAME_CONTROL:
+		{
+			switch (ctrl_info.value_1) {
+
+			case EXT_CFG_FRAME_FIX_15:{
+					err = SR300PC20_WRITE_LIST
+					    (sr300pc20_fps_15fix);
+				}
+				break;
+
+			case EXT_CFG_FRAME_FIX_24:{
+					err = SR300PC20_WRITE_LIST
+					    (sr300pc20_fps_24fix);
+				}
+				break;
+
+			case EXT_CFG_FRAME_FIX_30:{
+					err = SR300PC20_WRITE_LIST
+					    (sr300pc20_fps_30fix);
+				}
+				break;
+
+			default:{
+					pr_warning
+					    (" Unexpected"
+					     "EXT_CFG_FRAME_CONTROL mode :"
+					     "%d\n", ctrl_info.value_1);
+				}
+				break;
+
+			}
+		}
+		break;
+
+	case EXT_CFG_EFFECT_CONTROL:
+		{
+			mEffect = ctrl_info.value_1;
+			err = sr300pc20_effect_control(mEffect);
+
+		}
+		break;
+
+	case EXT_CFG_WB_CONTROL:
+		{
+			mWhiteBalance = ctrl_info.value_1;
+			err = sr300pc20_whitebalance_control(mWhiteBalance);
+
+		}
+		break;
+
+	case EXT_CFG_BR_CONTROL:
+		{
+			mBrightness = ctrl_info.value_1;
+			if (mInit)
+				err = sr300pc20_brightness_control(mBrightness);
+
+		}
+		break;
+
+	case EXT_CFG_ISO_CONTROL:
+		{
+			mISO = ctrl_info.value_1;
+			err = sr300pc20_iso_control(mISO);
+
+		}
+		break;
+
+	case EXT_CFG_METERING_CONTROL:
+		{
+			mAutoExposure = ctrl_info.value_1;
+			err = sr300pc20_metering_control(mAutoExposure);
+
+		}
+		break;
+
+	case EXT_CFG_SCENE_CONTROL:
+		{
+			mScene = ctrl_info.value_1;
+			err = sr300pc20_scene_control(mScene);
+
+		}
+		break;
+
+	case EXT_CFG_AE_AWB_CONTROL:
+		{
+			switch (ctrl_info.value_1) {
+			case EXT_CFG_AE_LOCK:{
+					err =
+					    SR300PC20_WRITE_LIST
+					    (sr300pc20_ae_lock);
+				}
+				break;
+
+			case EXT_CFG_AE_UNLOCK:{
+					err = SR300PC20_WRITE_LIST
+					    (sr300pc20_ae_unlock);
+				}
+				break;
+
+			case EXT_CFG_AWB_LOCK:{
+					err = SR300PC20_WRITE_LIST
+					    (sr300pc20_awb_lock);
+				}
+				break;
+
+			case EXT_CFG_AWB_UNLOCK:{
+					err = SR300PC20_WRITE_LIST
+					    (sr300pc20_awb_unlock);
+				}
+				break;
+
+			case EXT_CFG_AE_AWB_LOCK:{
+					if (mWhiteBalance == 0) {
+						err = SR300PC20_WRITE_LIST
+						    (sr300pc20_ae_lock);
+						err = SR300PC20_WRITE_LIST
+						    (sr300pc20_awb_lock);
+					} else {
+						err = SR300PC20_WRITE_LIST
+						    (sr300pc20_ae_lock);
+					}
+				}
+				break;
+
+			case EXT_CFG_AE_AWB_UNLOCK:{
+					if (mWhiteBalance == 0) {
+						err = SR300PC20_WRITE_LIST
+						    (sr300pc20_ae_unlock);
+						err = SR300PC20_WRITE_LIST
+						    (sr300pc20_awb_unlock);
+					} else {
+						err = SR300PC20_WRITE_LIST
+						    (sr300pc20_ae_unlock);
+					}
+				}
+				break;
+
+			default:{
+					pr_warning
+					    (" Unexpected AWB_AE mode :"
+					     "%d\n", ctrl_info.value_1);
+				}
+				break;
+
+			}
+		}
+		break;
+
+	case EXT_CFG_CR_CONTROL:
+		{
+			mContrast = ctrl_info.value_1;
+			if (mInit)
+				err = sr300pc20_contrast_control(mContrast);
+		}
+		break;
+
+	case EXT_CFG_SA_CONTROL:
+		{
+			mSaturation = ctrl_info.value_1;
+			if (mInit)
+				err = sr300pc20_saturation_control(mSaturation);
+		}
+		break;
+
+	case EXT_CFG_SP_CONTROL:
+		{
+			mSharpness = ctrl_info.value_1;
+			if (mInit)
+				err = sr300pc20_sharpness_control(mSharpness);
+		}
+		break;
+
+	case EXT_CFG_DTP_CONTROL:
+		{
+			if (mInit == 0) {
+				if (ctrl_info.value_1 == 0)
+					ctrl_info.value_3 = 2;
+
+				else if (ctrl_info.value_1 == 1)
+					ctrl_info.value_3 = 3;
+
+				mDTP = 1;
+			}
+
+			else {
+				err = sr300pc20_DTP_control(ctrl_info.value_1);
+
+				if (ctrl_info.value_1 == 0)
+					ctrl_info.value_3 = 2;
+
+				else if (ctrl_info.value_1 == 1)
+					ctrl_info.value_3 = 3;
+
+				mDTP = 0;
+			}
+
+		}
+		break;
+
+	case EXT_CFG_GET_MODULE_STATUS:
+		{
+			unsigned short id = 0;	/*CAM FOR FW */
+			/*ctrl_info.value_3 = gpio_get_value(0); */
+
+			ctrl_info.value_3 = id;
+
+			CAMDRV_DEBUG
+			    (" check current module status : %x\n",
+			     ctrl_info.value_3);
+			CAMDRV_DEBUG(" PINON/OFF : %d\n", gpio_get_value(0));
+		}
+		break;
+
+	case EXT_CFG_SET_CAM_MODE:
+		{
+			mCameraMode = ctrl_info.value_1;
+			if (mCameraMode == EXT_CFG_CAMCORDER_MODE) {
+				pr_err("[%s : %d] Record is starting!!\n",
+				       __func__, __LINE__);
+			} else {
+				pr_err("[%s : %d] Record stopped!!\n",
+				       __func__, __LINE__);
+			}
+		}
+		break;
+
+	default:{
+			pr_warning
+			    (" Unexpected mode on sensor_rough_control :"
+			     "%d\n", ctrl_info.mode);
+		}
+		break;
+	}
+
+	if (copy_to_user
+	    ((void *)arg, (const void *)&ctrl_info, sizeof(ctrl_info))) {
+		pr_err(" %s fail on copy_to_user!\n", __func__);
+	}
+
+	if (err != 0)
+		pr_err("[%s : %d] fail %d %d %d %d %d\n", __func__,
+		       __LINE__, ctrl_info.mode, ctrl_info.address,
+		       ctrl_info.value_1, ctrl_info.value_2, ctrl_info.value_3);
+	else
+		CAMDRV_DEBUG("Exit!!\n");
+
+	return err;
+}
+
+static int sr300pc20_mipi_mode(int mode)
+{
+	int rc = 0;
+	struct msm_camera_csi_params sr300pc20_csi_params;
+
+	CAMDRV_DEBUG("Enter!!\n");
+
+	if (!config_csi2) {
+		sr300pc20_csi_params.lane_cnt = 1;
+		sr300pc20_csi_params.data_format = CSI_8BIT;
+		sr300pc20_csi_params.lane_assign = 0xe4;
+		sr300pc20_csi_params.dpcm_scheme = 0;
+		sr300pc20_csi_params.settle_cnt = 0x14;	/*lyon.cho 24->0x14 */
+		rc = msm_camio_csi_config(&sr300pc20_csi_params);
+		if (rc < 0) {
+			pr_err("config csi controller failed\n");
+			return -EIO;
+		}
+		config_csi2 = 1;
+	}
+	CAMDRV_DEBUG("Exit!!\n");
+	return rc;
+}
+
+static int sr300pc20_set_preview(void)
+{
+	int err = 0;
+	int first_awb_delay = 0;
+
+	CAMDRV_DEBUG("mDTP = %d\n", mDTP);
+
+	err = sr300pc20_mipi_mode(1);
+	if (err != 0) {
+		pr_err("[%s : %d] sr300pc20_mipi_mode fail\n", __func__,
+		       __LINE__);
+		return -EIO;
+	}
+
+	msleep(30);		/*=> Please add some delay*/
+
+	if (first_start_camera) {
+		err = SR300PC20_WRITE_LIST_BURST(sr300pc20_init0);
+		if (err != 0) {
+			pr_err("[%s : %d] sr300pc20_init0 failed\n", __func__,
+			       __LINE__);
+			return -EIO;
+		}
+		CAMDRV_DEBUG("sr300pc20_init0 is writing done\n");
+
+		msleep(20);
+		first_start_camera = 0;
+		mInit = 1;
+		first_awb_delay = 1;
+
+		err = sr300pc20_brightness_control(mBrightness);
+		err = sr300pc20_effect_control(mEffect);
+		err = sr300pc20_whitebalance_control(mWhiteBalance);
+		err = sr300pc20_iso_control(mISO);
+	}
+
+	if (mDTP == 1) {
+		err = SR300PC20_WRITE_LIST(sr300pc20_dtp_on);
+	} else {
+		err = SR300PC20_WRITE_LIST(sr300pc20_update_preview_setting);
+		if (err != 0)
+			pr_err("[%s : %d] sr300pc20_update_preview_setting "
+			       "fail\n", __func__, __LINE__);
+		pr_err("[%s:%d] Preivew setting is done!!", __func__, __LINE__);
+	}
+
+	if (err != 0)
+		pr_err("[%s : %d] fail\n", __func__, __LINE__);
+	else
+		CAMDRV_DEBUG("Exit!!\n");
+
+	return err;
+}
+
+static int sr300pc20_set_capture(void)
+{
+	int err = 0;
+
+	CAMDRV_DEBUG("Enter!!\n");
+
+	if (mScene == EXT_CFG_SCENE_NIGHTSHOT) {
+		unsigned char lux_val = 0;
+
+		/* page mode 0x20 */
+		sr300pc20_sensor_write(0x03, 0x20);
+
+		/* read lux value */
+		sr300pc20_sensor_read(0xb1, &lux_val);
+
+		CAMDRV_DEBUG("[Nightshot] lux_val = 0x%x\n", lux_val);
+
+		if (lux_val < 0x16) {
+			err = SR300PC20_WRITE_LIST
+				(sr300pc20_night_snapshot);
+		} else {
+			err = SR300PC20_WRITE_LIST(sr300pc20_snapshot);
+		}
+	} else if (mScene == EXT_CFG_SCENE_FIREWORK) {
+		unsigned char lux_val = 0;
+
+		/* page mode 0x20 */
+		sr300pc20_sensor_write(0x03, 0x20);
+
+		/* read lux value */
+		sr300pc20_sensor_read(0xb1, &lux_val);
+
+		CAMDRV_DEBUG("[Nightshot] lux_val = 0x%x\n", lux_val);
+
+		if (lux_val < 0x16) {
+			err = SR300PC20_WRITE_LIST
+			    (sr300pc20_fireworks_snapshot);
+		} else {
+			err = SR300PC20_WRITE_LIST(sr300pc20_snapshot);
+		}
+	} else {
+		err = SR300PC20_WRITE_LIST(sr300pc20_snapshot);
+	}
+
+	if (err != 0)
+		pr_err("[%s : %d] fail\n", __func__, __LINE__);
+	else
+		CAMDRV_DEBUG("Exit!!\n");
+
+	return err;
+}
+
+static long sr300pc20_set_sensor_mode(int mode)
+{
+	int err = 0;
+
+	CAMDRV_DEBUG("Enter [mode = %d]\n", mode);
+
+	switch (mode) {
+	case SENSOR_PREVIEW_MODE:
+		err = sr300pc20_set_preview();
+		break;
+	case SENSOR_SNAPSHOT_MODE:
+		err = sr300pc20_set_capture();
+		break;
+	case SENSOR_RAW_SNAPSHOT_MODE:
+		pr_err("RAW_SNAPSHOT NOT SUPPORT!!");
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (err != 0)
+		pr_err("[%s : %d] mode is %d fail\n", __func__, __LINE__, mode);
+	else
+		CAMDRV_DEBUG("Exit!!\n");
+
+	return err;
+}
+
+static void sr300pc20_reset_power(void)
+{
+	pr_err("[%s : %d] entered\n", __func__, __LINE__);
+	sr300pc20_set_power(0);
+	/*add delay */
+	usleep(10 * UPTO_MSEC);	/* 10 msec */
+	sr300pc20_set_power(1);
+	pr_err("[%s : %d] exit\n", __func__, __LINE__);
+}
+
+void sr300pc20_set_power(int status)
+{
+	pr_err("[SR300PC20 %s]\n", status ? "POWER ON" : "POWER OFF");
+
+	if (status == 1) {	/*POWER ON */
+		cam_ldo_power_on();
+#if defined(CONFIG_MACH_JENA)
+		usleep(75 * UPTO_MSEC);	/* delay 75msec */
+#else
+		usleep(25 * UPTO_MSEC);	/* delay 25msec */
+#endif
+
+		/* Enable MCLK */
+		msm_camio_clk_rate_set(24000000);	/* 24 Mhz */
+		usleep(10);
+		msm_camio_clk_enable(CAMIO_CAM_MCLK_CLK);
+		usleep(23 * UPTO_MSEC);	/* delay 23msec */
+
+		gpio_set_value(96, 1);	/*standby */
+		usleep(12 * UPTO_MSEC);	/* delay 12msec */
+
+		gpio_set_value(85, 1);	/*reset */
+		usleep(1 * UPTO_MSEC);	/* delay 1msec  */
+
+	} else {		/*POWER OFF */
+		usleep(1 * UPTO_MSEC);	/* 1 msec */
+		gpio_set_value_cansleep(85, LOW);	/* reset */
+		usleep(10 * UPTO_MSEC);	/* >10 msec */
+
+		msm_camio_clk_disable(CAMIO_CAM_MCLK_CLK);
+		usleep(1 * UPTO_MSEC);	/* 1 msec */
+
+		gpio_set_value_cansleep(96, LOW);	/* standby */
+		usleep(10);
+		cam_ldo_power_off();
+	}
+}
+
+static int sr300pc20_check_sensor_id(void)
+{
+	int err = 0;
+	unsigned char id = 0;
+	const char page_mode_big = 0x03, page_mode_little = 0x00;
+	const char read_addr = 0x04;
+
+	CAMDRV_DEBUG("Enter!!\n");
+
+	/* read device id */
+	err = sr300pc20_sensor_write(page_mode_big, page_mode_little);
+	if (err != 0)
+		pr_err("[%s : %d] sr300pc20_sensor_write fail\n", __func__,
+		       __LINE__);
+
+	err = sr300pc20_sensor_read(read_addr, &id);	/*address */
+	if (err != 0)
+		pr_err("[%s : %d] sr300pc20_sensor_read fail\n", __func__,
+		       __LINE__);
+
+	if (id != 0xa4) {
+		pr_err("[SR300PC20] WRONG SENSOR FW => id 0x%x\n", id);
+		err = -1;
+	} else {
+		CAMDRV_DEBUG("[SR300PC20] CURRENT SENSOR FW => id 0x%x\n", id);
+	}
+	if (err != 0)
+		pr_err("[%s : %d] fail\n", __func__, __LINE__);
+	else
+		CAMDRV_DEBUG("Exit!!\n");
+
+	return err;
+}
+
+#ifdef CONFIG_LOAD_FILE
+
+static int sr300pc20_regs_table_init(void)
+{
+	struct file *filp;
+	char *dp = NULL;
+	long l = 0;
+	loff_t pos;
+	int ret = -1;
+	mm_segment_t fs = get_fs();
+
+	pr_err("[%s : %d] Entered\n", __func__, __LINE__);
+
+	set_fs(get_ds());
+
+	filp = filp_open(TUNNING_FILE_PATH, O_RDONLY, 0);
+
+	if (IS_ERR(filp)) {
+		pr_err("[%s : %d]file open error\n", __func__, __LINE__);
+		return -ret;
+	}
+	l = filp->f_path.dentry->d_inode->i_size;
+	pr_info("l = %ld\n", l);
+	dp = vmalloc(l);
+	if (dp == NULL) {
+		pr_err("[%s : %d] Out of Memory\n", __func__, __LINE__);
+		filp_close(filp, current->files);
+		return ret;
+	}
+	pos = 0;
+	memset(dp, 0, l);
+	ret = vfs_read(filp, (char __user *)dp, l, &pos);
+	if (ret != l) {
+		pr_err("[%s : %d] Failed to read file ret = %d\n",
+		       __func__, __LINE__, ret);
+		if (dp != NULL)
+			vfree(dp);
+		filp_close(filp, current->files);
+		ret = -EIO;
+		return ret;
+	}
+
+	filp_close(filp, current->files);
+
+	set_fs(fs);
+
+	sr300pc20_regs_table = dp;
+
+	sr300pc20_regs_table_size = l;
+
+	*((sr300pc20_regs_table + sr300pc20_regs_table_size) - 1) = '\0';
+
+	pr_err("Exit!!\n");
+
+	ret = 0;
+	return ret;
+}
+
+void sr300pc20_regs_table_exit(void)
+{
+	CAMDRV_DEBUG("Enter!!\n");
+	if (sr300pc20_regs_table != NULL) {
+		vfree(sr300pc20_regs_table);
+		sr300pc20_regs_table = NULL;
+	}
+	CAMDRV_DEBUG("Exit!!\n");
+}
+
+static int sr300pc20_is_hexnum(char *num)
+{
+	int i = 0;
+	for (i = 2; num[i] != '\0'; i++) {
+		if (!((num[i] >= '0' && num[5] <= '9')
+		      || (num[5] >= 'a' && num[5] <= 'f') || (num[5] >= 'A'
+							      && num[5] <=
+							      'F'))) {
+			return 0;
+		}
+	}
+	return 1;
+}
+
+static int sr300pc20_regs_table_write(char *name)
+{
+	char *start = NULL, *end = NULL, *reg = NULL, *temp = NULL;
+	unsigned char addr = 0, value = 0;
+	unsigned short data = 0;
+	char data_buf[7] = { 0 };
+	int err = 0;
+
+	CAMDRV_DEBUG("Enter!!\n");
+
+	addr = value = 0;
+
+	*(data_buf + 6) = '\0';
+
+	start = strnstr(sr300pc20_regs_table, name, sr300pc20_regs_table_size);
+	if (start == NULL) {
+		pr_err("[%s : %d] start is NULL\n", __func__, __LINE__);
+		err = -EIO;
+		return err;
+	}
+
+	end = strnstr(start, "};", sr300pc20_regs_table_size);
+	if (end == NULL) {
+		pr_err("[%s : %d] end is NULL\n", __func__, __LINE__);
+		err = -EIO;
+		return err;
+	}
+
+	while (1) {
+		/* Find Address */
+		reg = strnstr(start, "0x", sr300pc20_regs_table_size);
+		if (reg)
+			start = (reg + 6);
+
+		if ((reg == NULL) || (reg > end)) {
+			pr_err("[%s : %d] write end of %s\n",
+			       __func__, __LINE__, name);
+			break;
+		}
+		/* Write Value to Address */
+		memcpy(data_buf, reg, 6);
+
+		if (sr300pc20_is_hexnum(data_buf) == 0) {
+			pr_err("[%s : %d] it's not hex number %s\n",
+			       __func__, __LINE__, data_buf);
+			continue;
+		}
+
+		err = kstrtou16(data_buf, 16, &data);
+		if (err < 0) {
+			pr_err("[%s : %d] kstrtou16 failed\n",
+			       __func__, __LINE__);
+		}
+		addr = (data >> 8);
+		value = (data & 0xff);
+
+		if (addr == 0xff) {
+			msleep(value * 10);	/*one step is 10ms */
+			CAMDRV_DEBUG("delay %d msec\n", value * 10);
+		} else {
+			if (sr300pc20_sensor_write(addr, value) < 0) {
+				pr_err
+				    ("[%s : %d] fail on sensor_write :"
+				     "addr[0x%04x], value[0x%04x]\n",
+				     __func__, __LINE__, addr, value);
+				err = -EIO;
+				return err;
+			}
+			CAMDRV_DEBUG
+			    ("success on sensor_write :"
+			     "addr[0x%04x], value[0x%04x]\n", addr, value);
+		}
+	}
+
+	CAMDRV_DEBUG("Exit!!\n");
+
+	return err;
+}
+
+static int sr300pc20_regs_table_burst_write(char *name)
+{
+	char *start = NULL, *end = NULL;
+	char *reg = NULL, *temp = NULL;
+	unsigned char addr = 0, value = 0;
+	unsigned short data = 0;
+	char data_buf[7] = { 0 };
+	int idx = 0;
+	int err = 0;
+	int burst_flag = 0;
+	int burst_cnt = 0;
+	struct i2c_msg msg = { sr300pc20_client->addr,
+		0, 0, sr300pc20_buf_for_burstmode
+	};
+
+	CAMDRV_DEBUG("Enter!!\n");
+
+	addr = value = 0;
+
+	*(data_buf + 6) = '\0';
+
+	start = strnstr(sr300pc20_regs_table, name, sr300pc20_regs_table_size);
+	if (start == NULL) {
+		pr_err("[%s : %d] start is NULL\n", __func__, __LINE__);
+		err = -EIO;
+		return err;
+	}
+
+	end = strnstr(start, "};", sr300pc20_regs_table_size);
+	if (end == NULL) {
+		pr_err("[%s : %d] end is NULL\n", __func__, __LINE__);
+		err = -EIO;
+		return err;
+	}
+
+	while (1) {
+		/* Find Address */
+		reg = strnstr(start, "0x", sr300pc20_regs_table_size);
+		if (reg)
+			start = (reg + 6);
+
+		if ((reg == NULL) || (reg > end)) {
+			pr_err("[%s : %d] write end of %s\n",
+			       __func__, __LINE__, name);
+			break;
+		}
+		/* Write Value to Address */
+		memcpy(data_buf, reg, 6);
+
+		if (sr300pc20_is_hexnum(data_buf) == 0) {
+			pr_err("[%s : %d] it's not hex number %s\n",
+			       __func__, __LINE__, data_buf);
+			continue;
+		}
+
+		err = kstrtou16(data_buf, 16, &data);
+		if (err < 0) {
+			pr_err("[%s : %d] kstrtou16 failed\n",
+			       __func__, __LINE__);
+		}
+		addr = (data >> 8);
+		value = (data & 0xff);
+
+		if (idx > (BURST_MODE_BUFFER_MAX_SIZE - 10)) {
+			pr_err("[%s : %d]Burst mode buffer overflow! "
+			       "Burst Count %d\n",
+			       __func__, __LINE__, burst_cnt);
+			pr_err("[%s : %d] addr %x "
+			       "value %x\n", __func__, __LINE__,
+			       (data >> 8) & 0xff, data & 0xFF);
+
+			err = -EIO;
+			return err;
+		}
+
+		if (burst_flag == 0) {
+			switch (addr) {
+			case BURST_REG:
+				if (value != 0x00) {
+					burst_flag = 1;
+					burst_cnt++;
+				}
+				break;
+			case DELAY_REG:
+				msleep(value * 10);	/* a step is 10ms */
+				break;
+			default:
+				idx = 0;
+				err = sr300pc20_sensor_write(addr, value);
+				break;
+			}
+		} else if (burst_flag == 1) {
+			if (addr == BURST_REG && value == 0x00) {
+				msg.len = idx;
+				err = i2c_transfer(sr300pc20_client->adapter,
+						   &msg, 1) == 1 ? 0 : -EIO;
+				idx = 0;
+				burst_flag = 0;
+			} else {
+				if (idx == 0) {
+					sr300pc20_buf_for_burstmode[idx++] =
+					    addr;
+					sr300pc20_buf_for_burstmode[idx++] =
+					    value;
+				} else
+					sr300pc20_buf_for_burstmode[idx++] =
+					    value;
+			}
+		}
+	}
+
+	CAMDRV_DEBUG("Exit!!\n");
+
+	return err;
+}
+
+#endif
+
+int sr300pc20_sensor_init(const struct msm_camera_sensor_info *data)
+{
+	int rc = 0;
+
+	CAMDRV_DEBUG("Enter!!\n");
+
+	sr300pc20_ctrl = kzalloc(sizeof(struct sr300pc20_ctrl), GFP_KERNEL);
+	if (!sr300pc20_ctrl) {
+		pr_err("sr300pc20_init failed!\n");
+		rc = -ENOMEM;
+		goto init_done;
+	}
+
+	if (data)
+		sr300pc20_ctrl->sensordata = data;
+
+	first_start_camera = 1;
+	config_csi2 = 0;
+#ifdef CONFIG_LOAD_FILE
+	rc = sr300pc20_regs_table_init();
+	if (rc < 0) {
+		pr_err("[%s : %d] sr300pc20_regs_table_init fail\n",
+		       __func__, __LINE__);
+		goto init_fail;
+	}
+#endif
+	sr300pc20_set_power(1);
+	usleep(1 * UPTO_MSEC);	/* 1msec */
+
+	rc = sr300pc20_check_sensor_id();
+	if (rc < 0) {
+		pr_err("[%s : %d] sr300pc20_check_sensor_id fail\n",
+		       __func__, __LINE__);
+		goto init_fail;
+	}
+	rc = SR300PC20_WRITE_LIST(sr300pc20_pre_init0);
+	if (rc < 0) {
+		pr_err("[%s : %d] sr300pc20_pre_init0 set fail\n",
+		       __func__, __LINE__);
+		goto init_fail;
+	}
+
+init_done:
+	CAMDRV_DEBUG("Exit!!\n");
+	return rc;
+
+init_fail:
+	kfree(sr300pc20_ctrl);
+	return rc;
+}
+
+static int sr300pc20_init_client(struct i2c_client *client)
+{
+	/* Initialize the MSM_CAMI2C Chip */
+	init_waitqueue_head(&sr300pc20_wait_queue);
+	return 0;
+}
+
+int sr300pc20_sensor_config(void __user *argp)
+{
+	struct sensor_cfg_data cfg_data;
+	long rc = 0;
+
+	if (copy_from_user(&cfg_data,
+			   (void *)argp, sizeof(struct sensor_cfg_data)))
+		return -EFAULT;
+
+	pr_err("[%s : %d] cfgtype = %d, mode = %d\n",
+	       __func__, __LINE__, cfg_data.cfgtype, cfg_data.mode);
+
+	switch (cfg_data.cfgtype) {
+	case CFG_SET_MODE:
+		rc = sr300pc20_set_sensor_mode(cfg_data.mode);
+		break;
+
+	case CFG_SET_EFFECT:
+		/*rc = sr300pc20_set_effect
+		   (cfg_data.mode, cfg_data.cfg.effect); */
+		break;
+
+	default:
+		rc = -EINVAL;
+		pr_err("sr300pc20_sensor_config : Invalid cfgtype ! %d\n",
+		       cfg_data.cfgtype);
+		break;
+	}
+	if (rc != 0)
+		pr_err("[%s : %d] fail\n", __func__, __LINE__);
+
+	return rc;
+}
+
+int sr300pc20_sensor_release(void)
+{
+	int rc = 0;
+	/*int *switch_i2c_addr; //TEMP Dirty Code, Do not use it! */
+
+	first_start_camera = 1;
+	set_init0 = 0;
+
+	/*If did not init below that, it can keep the previous status.
+	   it depend on concept by PCAM */
+	mEffect = EXT_CFG_EFFECT_NORMAL;
+	mBrightness = EXT_CFG_BR_STEP_0;
+	mContrast = EXT_CFG_CR_STEP_0;
+	mSaturation = EXT_CFG_SA_STEP_0;
+	mSharpness = EXT_CFG_SP_STEP_0;
+	mWhiteBalance = EXT_CFG_WB_AUTO;
+	mISO = EXT_CFG_ISO_AUTO;
+	mAutoExposure = EXT_CFG_METERING_NORMAL;
+	mScene = EXT_CFG_SCENE_OFF;
+	mDTP = 0;
+	mInit = 0;
+
+	CAMDRV_DEBUG("Enter!!\n");
+
+	kfree(sr300pc20_ctrl);
+
+#ifdef CONFIG_LOAD_FILE
+	sr300pc20_regs_table_exit();
+#endif
+
+	sr300pc20_set_power(0);
+
+	CAMDRV_DEBUG("Exit!!\n");
+
+	return rc;
+}
+
+static int sr300pc20_i2c_probe(struct i2c_client *client,
+			       const struct i2c_device_id *id)
+{
+	int rc = 0;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		rc = -ENOTSUPP;
+		goto probe_failure;
+	}
+
+	sr300pc20_sensorw = kzalloc(sizeof(struct sr300pc20_work), GFP_KERNEL);
+
+	if (!sr300pc20_sensorw) {
+		rc = -ENOMEM;
+		goto probe_failure;
+	}
+
+	i2c_set_clientdata(client, sr300pc20_sensorw);
+	sr300pc20_init_client(client);
+	sr300pc20_client = client;
+
+	pr_err("sr300pc20_probe succeeded!\n");
+
+	return 0;
+
+probe_failure:
+	kfree(sr300pc20_sensorw);
+	sr300pc20_sensorw = NULL;
+	pr_err("sr300pc20_probe failed!\n");
+	return rc;
+}
+
+static const struct i2c_device_id sr300pc20_i2c_id[] = {
+	{"sr300pc20", 0},
+	{},
+};
+
+static struct i2c_driver sr300pc20_i2c_driver = {
+	.id_table = sr300pc20_i2c_id,
+	.probe = sr300pc20_i2c_probe,
+	.remove = __exit_p(sr300pc20_i2c_remove),
+	.driver = {
+		   .name = "sr300pc20",
+		   },
+};
+
+static int sr300pc20_sensor_probe(const struct msm_camera_sensor_info *info,
+				  struct msm_sensor_ctrl *s)
+{
+	int rc = i2c_add_driver(&sr300pc20_i2c_driver);
+	if (rc < 0 || sr300pc20_client == NULL) {
+		rc = -ENOTSUPP;
+		goto probe_done;
+	}
+
+	s->s_init = sr300pc20_sensor_init;
+	s->s_release = sr300pc20_sensor_release;
+	s->s_config = sr300pc20_sensor_config;
+	s->s_ext_config = sr300pc20_sensor_ext_config;
+
+	s->s_camera_type = BACK_CAMERA_2D;
+	s->s_mount_angle = 90;
+
+probe_done:
+	pr_info("%s:%d\n", __func__, __LINE__);
+	return rc;
+}
+
+static int __sr300pc20_probe(struct platform_device *pdev)
+{
+	pr_err("############# SR300PC20 probe ##############\n");
+	return msm_camera_drv_start(pdev, sr300pc20_sensor_probe);
+}
+
+static struct platform_driver msm_camera_driver = {
+	.probe = __sr300pc20_probe,
+	.driver = {
+		   .name = "msm_camera_sr300pc20",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int __init sr300pc20_init(void)
+{
+	return platform_driver_register(&msm_camera_driver);
+}
+
+module_init(sr300pc20_init);
diff --git a/drivers/media/video/msm/sr300pc20.h b/drivers/media/video/msm/sr300pc20.h
new file mode 100644
index 0000000..363cd4c
--- /dev/null
+++ b/drivers/media/video/msm/sr300pc20.h
@@ -0,0 +1,9090 @@
+#ifndef _SAMSUNG_sr300pc20_H_
+#define _SAMSUNG_sr300pc20_H_
+
+static const u16 sr300pc20_init_60hz[] = {
+	0xff00,
+};
+
+static const u16 sr300pc20_pre_init0[] = {
+	0xff00,
+};
+
+static const u16 sr300pc20_init0[] = {
+	0x0300,
+	0x01f1,
+	0x01f1,
+	0x01f3,
+	0x01f1,
+	0x027f,
+	0x0300,
+	0x0725,
+	0x086c,
+	0x0982,
+	0x07a5,
+	0x07a5,
+	0x09a2,
+	0x0A01,
+	0x0A00,
+	0x0A01,
+	0x0A00,
+	0x0320,
+	0x3a00,
+	0x3b00,
+	0x3c00,
+	0x0330,
+	0x3086,
+	0x3100,
+	0x320c,
+	0xe000,
+	0x1080,
+	0x108a,
+	0x1108,
+	0x1100,
+	0x0307,
+	0x1201,
+	0x4035,
+	0x470B,
+	0x2E00,
+	0x2F20,
+	0x3000,
+	0x31D6,
+	0x3200,
+	0x33FF,
+	0x1002,
+	0x8C08,
+	0x8F20,
+	0x9200,
+	0x9354,
+	0x9400,
+	0x9511,
+	0x0300,
+	0xff05,
+	0x0307,
+	0x2E03,
+	0x2F20,
+	0x3020,
+	0x31A6,
+	0x3201,
+	0x3300,
+	0x1002,
+	0x0300,
+	0xff05,
+	0x0307,
+	0x1200,
+	0x9800,
+	0x9701,
+	0x0330,
+	0x100a,
+	0x0300,
+	0x0B02,
+	0x1000,
+	0x1180,
+	0x1380,
+	0x1430,
+	0x1503,
+	0x1704,
+	0x2000,
+	0x2104,
+	0x2200,
+	0x230a,
+	0x2406,
+	0x2500,
+	0x2608,
+	0x2700,
+	0x5001,
+	0x5140,
+	0x5200,
+	0x5321,
+	0x8002,
+	0x8187,
+	0x8228,
+	0x8308,
+	0x848c,
+	0x850c,
+	0x8600,
+	0x8700,
+	0x8898,
+	0x8910,
+	0x8a80,
+	0x8b00,
+	0x8e80,
+	0x8f0f,
+	0x900f,
+	0x910f,
+	0x92a0,
+	0x9390,
+	0x96fe,
+	0x97E0,
+	0x9820,
+	0xa182,
+	0xa283,
+	0xa387,
+	0xa582,
+	0xa683,
+	0xa787,
+	0xbb20,
+	0x0302,
+	0x1a00,
+	0x2033,
+	0x2101,
+	0x2222,
+	0x2330,
+	0x2433,
+	0x2777,
+	0x31f0,
+	0x3222,
+	0x3302,
+	0x3430,
+	0x3500,
+	0x3608,
+	0x3720,
+	0x4001,
+	0x418a,
+	0x4200,
+	0x483C,
+	0x4910,
+	0x54c0,
+	0x5540,
+	0x5b00,
+	0x7802,
+	0x7936,
+	0x7a02,
+	0x7b3a,
+	0xa001,
+	0xa1c4,
+	0xa202,
+	0xa3de,
+	0xa403,
+	0xa53b,
+	0xa608,
+	0xa7ee,
+	0xa800,
+	0xa9cd,
+	0xaa01,
+	0xabba,
+	0xac02,
+	0xad8a,
+	0xae05,
+	0xaF96,
+	0xb000,
+	0xb176,
+	0xb200,
+	0xb3e6,
+	0xb400,
+	0xb52d,
+	0xb601,
+	0xb7b8,
+	0xb800,
+	0xb967,
+	0xba00,
+	0xbbe7,
+	0xbc00,
+	0xbd03,
+	0xbe03,
+	0xbF01,
+	0xc000,
+	0xc176,
+	0xc200,
+	0xc3e8,
+	0xc400,
+	0xc52d,
+	0xc601,
+	0xc7ba,
+	0xc800,
+	0xc967,
+	0xca00,
+	0xcbeb,
+	0xcc00,
+	0xcd03,
+	0xce03,
+	0xcf05,
+	0xd40f,
+	0xd50f,
+	0xd6a8,
+	0xd7a0,
+	0xEF65,
+	0xF00c,
+	0xF40a,
+	0x0303,
+	0x1000,
+	0x11dc,
+	0x1200,
+	0x1382,
+	0x1402,
+	0x15d3,
+	0x1602,
+	0x17db,
+	0x1801,
+	0x1919,
+	0x1a02,
+	0x1b3c,
+	0x1c01,
+	0x1d19,
+	0x1e02,
+	0x1F3c,
+	0x2001,
+	0x2119,
+	0x2201,
+	0x234a,
+	0x2401,
+	0x2519,
+	0x2601,
+	0x274a,
+	0x2801,
+	0x2919,
+	0x2a01,
+	0x2b4b,
+	0x2c01,
+	0x2d19,
+	0x2e01,
+	0x2F4b,
+	0x3000,
+	0x3101,
+	0x3205,
+	0x33b1,
+	0x3400,
+	0x3501,
+	0x3605,
+	0x37b1,
+	0x3800,
+	0x3901,
+	0x3a03,
+	0x3b1d,
+	0x3c00,
+	0x3d01,
+	0x3e03,
+	0x3F05,
+	0x4000,
+	0x4104,
+	0x4200,
+	0x4344,
+	0x4400,
+	0x4502,
+	0x4600,
+	0x4773,
+	0x4800,
+	0x4906,
+	0x4a00,
+	0x4b42,
+	0x4c00,
+	0x4d06,
+	0x4e00,
+	0x4F42,
+	0x5000,
+	0x5108,
+	0x5200,
+	0x532d,
+	0x5400,
+	0x5508,
+	0x5600,
+	0x572d,
+	0x5800,
+	0x5908,
+	0x5a00,
+	0x5b2d,
+	0x5c00,
+	0x5d06,
+	0x5e00,
+	0x5F44,
+	0x6800,
+	0x6904,
+	0x6a00,
+	0x6b46,
+	0x7000,
+	0x71e8,
+	0x7202,
+	0x7338,
+	0x7400,
+	0x75ed,
+	0x7601,
+	0x7715,
+	0x7802,
+	0x7936,
+	0x7a02,
+	0x7b3a,
+	0x7c02,
+	0x7d36,
+	0x7e02,
+	0x7F3a,
+	0x8001,
+	0x81cc,
+	0x8202,
+	0x8312,
+	0x8402,
+	0x8536,
+	0x8602,
+	0x873a,
+	0x8802,
+	0x8936,
+	0x8a02,
+	0x8b3a,
+	0x8c00,
+	0x8dea,
+	0x8e01,
+	0x8F18,
+	0x9000,
+	0x91e8,
+	0x9202,
+	0x9332,
+	0x9400,
+	0x95e8,
+	0x9602,
+	0x9732,
+	0x9802,
+	0x9932,
+	0x9a00,
+	0x9be8,
+	0x9c02,
+	0x9d32,
+	0x9e00,
+	0x9Fe8,
+	0xa000,
+	0xa10a,
+	0xa200,
+	0xa306,
+	0xa400,
+	0xa50a,
+	0xa600,
+	0xa706,
+	0xa800,
+	0xa9F5,
+	0xaa00,
+	0xabe6,
+	0xac00,
+	0xadF5,
+	0xae00,
+	0xaFe6,
+	0xc000,
+	0xc148,
+	0xc200,
+	0xc36E,
+	0xc400,
+	0xc548,
+	0xc600,
+	0xc76E,
+	0xc800,
+	0xc94a,
+	0xca00,
+	0xcb6c,
+	0xcc00,
+	0xcd4a,
+	0xce00,
+	0xcF6c,
+	0xd000,
+	0xd14c,
+	0xd200,
+	0xd36a,
+	0xd400,
+	0xd54c,
+	0xd600,
+	0xd76a,
+	0xd800,
+	0xd94e,
+	0xda00,
+	0xdb68,
+	0xdc00,
+	0xdd4e,
+	0xde00,
+	0xdF68,
+	0xe000,
+	0xe1ed,
+	0xe201,
+	0xe354,
+	0xe401,
+	0xe568,
+	0xe602,
+	0xe759,
+	0xe801,
+	0xe917,
+	0xea01,
+	0xebc8,
+	0xec00,
+	0xeddd,
+	0xee00,
+	0xef00,
+	0xf000,
+	0xf134,
+	0x0310,
+	0x1001,
+	0x1230,
+	0x130a,
+	0x2080,
+	0x410a,
+	0x50a0,
+	0x6003,
+	0x700c,
+	0x7100,
+	0x727a,
+	0x7328,
+	0x7414,
+	0x750d,
+	0x7640,
+	0x7749,
+	0x7899,
+	0x794c,
+	0x7acc,
+	0x7b49,
+	0x7c99,
+	0x7d14,
+	0x7e28,
+	0x7f50,
+	0xe0ff,
+	0xe13f,
+	0xe2ff,
+	0xe3ff,
+	0xe4f7,
+	0xe579,
+	0xe6ce,
+	0xe71f,
+	0xe85f,
+	0xf03f,
+	0x0311,
+	0x1013,
+	0xf040,
+	0xf26e,
+	0xf364,
+	0xf4fe,
+	0xf5fd,
+	0xf600,
+	0xf700,
+	0x0312,
+	0x1208,
+	0x2b08,
+	0x2c08,
+	0x2d08,
+	0x2e06,
+	0x3309,
+	0x3503,
+	0x360f,
+	0x370d,
+	0x3802,
+	0x6021,
+	0x610e,
+	0x6270,
+	0x6370,
+	0x6501,
+	0xE158,
+	0xEC32,
+	0xEE03,
+	0x0313,
+	0x1033,
+	0xa00f,
+	0xe107,
+	0x0314,
+	0x1027,
+	0x1102,
+	0x1240,
+	0x2082,
+	0x3082,
+	0x4084,
+	0x5084,
+	0x0300,
+	0xff01,
+	0x0315,
+	0x1082,
+	0x0307,
+	0x1204,
+	0x3400,
+	0x3500,
+	0x1385,
+	0x1305,
+	0x374f,
+	0x3750,
+	0x374c,
+	0x3746,
+	0x373f,
+	0x3739,
+	0x3734,
+	0x3730,
+	0x372e,
+	0x372e,
+	0x372f,
+	0x3732,
+	0x3737,
+	0x373d,
+	0x3743,
+	0x3749,
+	0x374f,
+	0x374f,
+	0x374f,
+	0x374f,
+	0x3749,
+	0x3742,
+	0x373b,
+	0x3734,
+	0x372e,
+	0x372a,
+	0x3728,
+	0x3727,
+	0x3729,
+	0x372c,
+	0x3732,
+	0x3739,
+	0x3740,
+	0x3747,
+	0x374e,
+	0x374e,
+	0x374a,
+	0x3749,
+	0x3741,
+	0x3738,
+	0x3730,
+	0x3728,
+	0x3722,
+	0x371d,
+	0x371b,
+	0x371a,
+	0x371c,
+	0x3720,
+	0x3725,
+	0x372d,
+	0x3736,
+	0x373e,
+	0x3747,
+	0x3748,
+	0x3744,
+	0x3743,
+	0x3739,
+	0x3730,
+	0x3726,
+	0x371e,
+	0x3717,
+	0x3713,
+	0x3711,
+	0x3710,
+	0x3712,
+	0x3715,
+	0x371b,
+	0x3723,
+	0x372d,
+	0x3736,
+	0x3740,
+	0x3742,
+	0x373f,
+	0x373d,
+	0x3733,
+	0x3728,
+	0x371e,
+	0x3715,
+	0x370f,
+	0x370a,
+	0x3708,
+	0x3708,
+	0x3709,
+	0x370d,
+	0x3713,
+	0x371b,
+	0x3725,
+	0x372f,
+	0x373a,
+	0x373d,
+	0x373c,
+	0x3739,
+	0x372e,
+	0x3723,
+	0x3719,
+	0x3710,
+	0x3709,
+	0x3705,
+	0x3702,
+	0x3702,
+	0x3704,
+	0x3708,
+	0x370e,
+	0x3716,
+	0x3720,
+	0x372a,
+	0x3736,
+	0x3739,
+	0x373a,
+	0x3736,
+	0x372b,
+	0x3720,
+	0x3716,
+	0x370d,
+	0x3706,
+	0x3702,
+	0x3700,
+	0x3700,
+	0x3701,
+	0x3705,
+	0x370b,
+	0x3713,
+	0x371c,
+	0x3727,
+	0x3733,
+	0x3737,
+	0x3739,
+	0x3736,
+	0x372a,
+	0x371f,
+	0x3715,
+	0x370c,
+	0x3706,
+	0x3701,
+	0x3700,
+	0x3700,
+	0x3701,
+	0x3704,
+	0x370a,
+	0x3712,
+	0x371c,
+	0x3727,
+	0x3732,
+	0x3736,
+	0x373a,
+	0x3737,
+	0x372b,
+	0x3721,
+	0x3717,
+	0x370e,
+	0x3708,
+	0x3703,
+	0x3701,
+	0x3701,
+	0x3702,
+	0x3706,
+	0x370c,
+	0x3714,
+	0x371e,
+	0x3728,
+	0x3734,
+	0x3738,
+	0x373b,
+	0x3739,
+	0x372e,
+	0x3724,
+	0x371b,
+	0x3712,
+	0x370c,
+	0x3707,
+	0x3705,
+	0x3704,
+	0x3706,
+	0x370a,
+	0x3710,
+	0x3718,
+	0x3721,
+	0x372c,
+	0x3737,
+	0x373a,
+	0x373e,
+	0x373d,
+	0x3733,
+	0x3729,
+	0x3720,
+	0x3718,
+	0x3712,
+	0x370d,
+	0x370b,
+	0x370b,
+	0x370c,
+	0x3710,
+	0x3716,
+	0x371e,
+	0x3727,
+	0x3731,
+	0x373a,
+	0x373d,
+	0x3743,
+	0x3741,
+	0x3739,
+	0x3730,
+	0x3728,
+	0x3721,
+	0x371b,
+	0x3717,
+	0x3714,
+	0x3714,
+	0x3716,
+	0x3719,
+	0x371f,
+	0x3726,
+	0x372f,
+	0x3738,
+	0x3740,
+	0x3741,
+	0x3746,
+	0x3746,
+	0x373f,
+	0x3739,
+	0x3731,
+	0x372b,
+	0x3725,
+	0x3722,
+	0x371f,
+	0x371f,
+	0x3721,
+	0x3724,
+	0x3729,
+	0x3730,
+	0x3737,
+	0x373f,
+	0x3745,
+	0x3746,
+	0x3746,
+	0x3747,
+	0x3741,
+	0x373b,
+	0x3735,
+	0x372f,
+	0x372a,
+	0x3727,
+	0x3725,
+	0x3724,
+	0x3726,
+	0x3729,
+	0x372e,
+	0x3733,
+	0x373a,
+	0x3740,
+	0x3746,
+	0x3746,
+	0x375d,
+	0x375e,
+	0x3757,
+	0x374f,
+	0x3747,
+	0x3740,
+	0x373a,
+	0x3735,
+	0x3733,
+	0x3733,
+	0x3735,
+	0x3739,
+	0x373e,
+	0x3745,
+	0x374d,
+	0x3753,
+	0x3759,
+	0x3759,
+	0x375c,
+	0x375c,
+	0x3754,
+	0x374b,
+	0x3742,
+	0x373a,
+	0x3733,
+	0x372e,
+	0x372c,
+	0x372c,
+	0x372e,
+	0x3732,
+	0x3738,
+	0x3740,
+	0x3748,
+	0x3750,
+	0x3758,
+	0x3758,
+	0x3755,
+	0x3754,
+	0x374a,
+	0x3740,
+	0x3736,
+	0x372c,
+	0x3725,
+	0x3720,
+	0x371d,
+	0x371d,
+	0x371f,
+	0x3724,
+	0x372a,
+	0x3733,
+	0x373d,
+	0x3747,
+	0x3750,
+	0x3752,
+	0x374f,
+	0x374c,
+	0x3741,
+	0x3736,
+	0x372b,
+	0x3721,
+	0x3719,
+	0x3714,
+	0x3712,
+	0x3711,
+	0x3713,
+	0x3718,
+	0x371f,
+	0x3728,
+	0x3733,
+	0x373e,
+	0x3748,
+	0x374b,
+	0x3749,
+	0x3746,
+	0x373a,
+	0x372d,
+	0x3722,
+	0x3718,
+	0x3710,
+	0x370b,
+	0x3709,
+	0x3708,
+	0x370a,
+	0x370f,
+	0x3716,
+	0x371f,
+	0x372a,
+	0x3736,
+	0x3742,
+	0x3745,
+	0x3744,
+	0x3741,
+	0x3734,
+	0x3728,
+	0x371c,
+	0x3712,
+	0x370a,
+	0x3705,
+	0x3703,
+	0x3703,
+	0x3705,
+	0x3709,
+	0x3710,
+	0x3719,
+	0x3724,
+	0x3730,
+	0x373d,
+	0x3741,
+	0x3742,
+	0x373e,
+	0x3731,
+	0x3725,
+	0x3719,
+	0x370e,
+	0x3707,
+	0x3702,
+	0x3700,
+	0x3700,
+	0x3701,
+	0x3706,
+	0x370c,
+	0x3715,
+	0x3721,
+	0x372d,
+	0x373a,
+	0x373f,
+	0x3741,
+	0x373d,
+	0x3730,
+	0x3724,
+	0x3718,
+	0x370e,
+	0x3706,
+	0x3701,
+	0x3700,
+	0x3700,
+	0x3701,
+	0x3705,
+	0x370c,
+	0x3715,
+	0x3720,
+	0x372c,
+	0x3739,
+	0x373e,
+	0x3742,
+	0x373e,
+	0x3732,
+	0x3726,
+	0x371a,
+	0x3710,
+	0x3709,
+	0x3704,
+	0x3701,
+	0x3701,
+	0x3703,
+	0x3707,
+	0x370e,
+	0x3717,
+	0x3722,
+	0x372e,
+	0x373b,
+	0x373f,
+	0x3744,
+	0x3741,
+	0x3735,
+	0x372a,
+	0x371f,
+	0x3715,
+	0x370d,
+	0x3708,
+	0x3706,
+	0x3706,
+	0x3708,
+	0x370c,
+	0x3712,
+	0x371b,
+	0x3726,
+	0x3732,
+	0x373e,
+	0x3742,
+	0x3748,
+	0x3745,
+	0x373b,
+	0x3730,
+	0x3725,
+	0x371c,
+	0x3715,
+	0x3710,
+	0x370d,
+	0x370d,
+	0x370f,
+	0x3713,
+	0x371a,
+	0x3723,
+	0x372d,
+	0x3738,
+	0x3743,
+	0x3746,
+	0x374c,
+	0x374b,
+	0x3742,
+	0x3738,
+	0x372e,
+	0x3726,
+	0x371f,
+	0x371a,
+	0x3717,
+	0x3717,
+	0x3719,
+	0x371d,
+	0x3724,
+	0x372c,
+	0x3736,
+	0x373f,
+	0x3749,
+	0x374b,
+	0x3751,
+	0x3750,
+	0x3749,
+	0x3741,
+	0x3739,
+	0x3731,
+	0x372b,
+	0x3727,
+	0x3724,
+	0x3724,
+	0x3726,
+	0x372a,
+	0x3730,
+	0x3737,
+	0x3740,
+	0x3748,
+	0x374f,
+	0x3750,
+	0x3750,
+	0x3751,
+	0x374b,
+	0x3744,
+	0x373d,
+	0x3736,
+	0x3730,
+	0x372d,
+	0x372a,
+	0x372a,
+	0x372c,
+	0x3730,
+	0x3735,
+	0x373c,
+	0x3743,
+	0x374a,
+	0x3751,
+	0x3751,
+	0x3746,
+	0x3748,
+	0x3744,
+	0x373f,
+	0x3739,
+	0x3734,
+	0x372f,
+	0x372b,
+	0x3729,
+	0x3728,
+	0x372a,
+	0x372c,
+	0x3730,
+	0x3735,
+	0x373b,
+	0x3740,
+	0x3744,
+	0x3744,
+	0x3746,
+	0x3747,
+	0x3742,
+	0x373c,
+	0x3735,
+	0x372f,
+	0x372a,
+	0x3726,
+	0x3724,
+	0x3723,
+	0x3724,
+	0x3727,
+	0x372c,
+	0x3731,
+	0x3737,
+	0x373d,
+	0x3743,
+	0x3743,
+	0x3741,
+	0x3740,
+	0x3739,
+	0x3733,
+	0x372b,
+	0x3725,
+	0x371f,
+	0x371b,
+	0x3718,
+	0x3718,
+	0x3719,
+	0x371c,
+	0x3721,
+	0x3727,
+	0x372e,
+	0x3735,
+	0x373c,
+	0x373d,
+	0x373b,
+	0x373a,
+	0x3732,
+	0x372b,
+	0x3723,
+	0x371b,
+	0x3716,
+	0x3711,
+	0x370f,
+	0x370e,
+	0x3710,
+	0x3713,
+	0x3718,
+	0x371f,
+	0x3727,
+	0x372e,
+	0x3735,
+	0x3737,
+	0x3736,
+	0x3734,
+	0x372c,
+	0x3724,
+	0x371b,
+	0x3714,
+	0x370e,
+	0x370a,
+	0x3707,
+	0x3707,
+	0x3709,
+	0x370c,
+	0x3711,
+	0x3718,
+	0x3720,
+	0x3728,
+	0x3730,
+	0x3733,
+	0x3733,
+	0x3731,
+	0x3728,
+	0x371f,
+	0x3716,
+	0x370f,
+	0x3709,
+	0x3705,
+	0x3703,
+	0x3703,
+	0x3704,
+	0x3707,
+	0x370c,
+	0x3713,
+	0x371b,
+	0x3724,
+	0x372d,
+	0x3730,
+	0x3731,
+	0x372f,
+	0x3726,
+	0x371d,
+	0x3714,
+	0x370c,
+	0x3706,
+	0x3702,
+	0x3700,
+	0x3700,
+	0x3702,
+	0x3705,
+	0x370a,
+	0x3711,
+	0x3719,
+	0x3722,
+	0x372b,
+	0x372e,
+	0x3730,
+	0x372e,
+	0x3725,
+	0x371c,
+	0x3713,
+	0x370b,
+	0x3706,
+	0x3702,
+	0x3700,
+	0x3700,
+	0x3701,
+	0x3704,
+	0x3709,
+	0x3710,
+	0x3718,
+	0x3721,
+	0x372a,
+	0x372e,
+	0x3732,
+	0x372f,
+	0x3726,
+	0x371d,
+	0x3715,
+	0x370d,
+	0x3707,
+	0x3704,
+	0x3701,
+	0x3701,
+	0x3703,
+	0x3706,
+	0x370b,
+	0x3712,
+	0x371a,
+	0x3723,
+	0x372c,
+	0x372f,
+	0x3734,
+	0x3732,
+	0x3729,
+	0x3721,
+	0x3719,
+	0x3711,
+	0x370b,
+	0x3707,
+	0x3705,
+	0x3705,
+	0x3706,
+	0x370a,
+	0x370f,
+	0x3716,
+	0x371e,
+	0x3726,
+	0x372f,
+	0x3732,
+	0x3737,
+	0x3736,
+	0x372e,
+	0x3726,
+	0x371e,
+	0x3717,
+	0x3711,
+	0x370d,
+	0x370a,
+	0x370a,
+	0x370c,
+	0x370f,
+	0x3715,
+	0x371c,
+	0x3723,
+	0x372b,
+	0x3733,
+	0x3735,
+	0x373c,
+	0x373b,
+	0x3734,
+	0x372d,
+	0x3725,
+	0x371f,
+	0x3719,
+	0x3715,
+	0x3712,
+	0x3712,
+	0x3714,
+	0x3717,
+	0x371c,
+	0x3723,
+	0x372a,
+	0x3731,
+	0x3738,
+	0x3739,
+	0x3740,
+	0x3740,
+	0x373a,
+	0x3734,
+	0x372d,
+	0x3727,
+	0x3722,
+	0x371e,
+	0x371c,
+	0x371b,
+	0x371d,
+	0x3720,
+	0x3725,
+	0x372b,
+	0x3731,
+	0x3737,
+	0x373d,
+	0x373d,
+	0x3740,
+	0x3740,
+	0x373c,
+	0x3736,
+	0x3730,
+	0x372a,
+	0x3725,
+	0x3722,
+	0x3720,
+	0x371f,
+	0x3721,
+	0x3724,
+	0x3729,
+	0x372e,
+	0x3734,
+	0x3739,
+	0x373e,
+	0x373e,
+	0x374f,
+	0x3750,
+	0x374c,
+	0x3746,
+	0x373f,
+	0x3739,
+	0x3734,
+	0x3730,
+	0x372e,
+	0x372e,
+	0x372f,
+	0x3732,
+	0x3737,
+	0x373d,
+	0x3743,
+	0x3749,
+	0x374f,
+	0x374f,
+	0x374f,
+	0x374f,
+	0x3749,
+	0x3742,
+	0x373b,
+	0x3734,
+	0x372e,
+	0x372a,
+	0x3728,
+	0x3727,
+	0x3729,
+	0x372c,
+	0x3732,
+	0x3739,
+	0x3740,
+	0x3747,
+	0x374e,
+	0x374e,
+	0x374a,
+	0x3749,
+	0x3741,
+	0x3738,
+	0x3730,
+	0x3728,
+	0x3722,
+	0x371d,
+	0x371b,
+	0x371a,
+	0x371c,
+	0x3720,
+	0x3725,
+	0x372d,
+	0x3736,
+	0x373e,
+	0x3747,
+	0x3748,
+	0x3744,
+	0x3743,
+	0x3739,
+	0x3730,
+	0x3726,
+	0x371e,
+	0x3717,
+	0x3713,
+	0x3711,
+	0x3710,
+	0x3712,
+	0x3715,
+	0x371b,
+	0x3723,
+	0x372d,
+	0x3736,
+	0x3740,
+	0x3742,
+	0x373f,
+	0x373d,
+	0x3733,
+	0x3728,
+	0x371e,
+	0x3715,
+	0x370f,
+	0x370a,
+	0x3708,
+	0x3708,
+	0x3709,
+	0x370d,
+	0x3713,
+	0x371b,
+	0x3725,
+	0x372f,
+	0x373a,
+	0x373d,
+	0x373c,
+	0x3739,
+	0x372e,
+	0x3723,
+	0x3719,
+	0x3710,
+	0x3709,
+	0x3705,
+	0x3702,
+	0x3702,
+	0x3704,
+	0x3708,
+	0x370e,
+	0x3716,
+	0x3720,
+	0x372a,
+	0x3736,
+	0x3739,
+	0x373a,
+	0x3736,
+	0x372b,
+	0x3720,
+	0x3716,
+	0x370d,
+	0x3706,
+	0x3702,
+	0x3700,
+	0x3700,
+	0x3701,
+	0x3705,
+	0x370b,
+	0x3713,
+	0x371c,
+	0x3727,
+	0x3733,
+	0x3737,
+	0x3739,
+	0x3736,
+	0x372a,
+	0x371f,
+	0x3715,
+	0x370c,
+	0x3706,
+	0x3701,
+	0x3700,
+	0x3700,
+	0x3701,
+	0x3704,
+	0x370a,
+	0x3712,
+	0x371c,
+	0x3727,
+	0x3732,
+	0x3736,
+	0x373a,
+	0x3737,
+	0x372b,
+	0x3721,
+	0x3717,
+	0x370e,
+	0x3708,
+	0x3703,
+	0x3701,
+	0x3701,
+	0x3702,
+	0x3706,
+	0x370c,
+	0x3714,
+	0x371e,
+	0x3728,
+	0x3734,
+	0x3738,
+	0x373b,
+	0x3739,
+	0x372e,
+	0x3724,
+	0x371b,
+	0x3712,
+	0x370c,
+	0x3707,
+	0x3705,
+	0x3704,
+	0x3706,
+	0x370a,
+	0x3710,
+	0x3718,
+	0x3721,
+	0x372c,
+	0x3737,
+	0x373a,
+	0x373e,
+	0x373d,
+	0x3733,
+	0x3729,
+	0x3720,
+	0x3718,
+	0x3712,
+	0x370d,
+	0x370b,
+	0x370b,
+	0x370c,
+	0x3710,
+	0x3716,
+	0x371e,
+	0x3727,
+	0x3731,
+	0x373a,
+	0x373d,
+	0x3743,
+	0x3741,
+	0x3739,
+	0x3730,
+	0x3728,
+	0x3721,
+	0x371b,
+	0x3717,
+	0x3714,
+	0x3714,
+	0x3716,
+	0x3719,
+	0x371f,
+	0x3726,
+	0x372f,
+	0x3738,
+	0x3740,
+	0x3741,
+	0x3746,
+	0x3746,
+	0x373f,
+	0x3739,
+	0x3731,
+	0x372b,
+	0x3725,
+	0x3722,
+	0x371f,
+	0x371f,
+	0x3721,
+	0x3724,
+	0x3729,
+	0x3730,
+	0x3737,
+	0x373f,
+	0x3745,
+	0x3746,
+	0x3746,
+	0x3747,
+	0x3741,
+	0x373b,
+	0x3735,
+	0x372f,
+	0x372a,
+	0x3727,
+	0x3725,
+	0x3724,
+	0x3726,
+	0x3729,
+	0x372e,
+	0x3733,
+	0x373a,
+	0x3740,
+	0x3746,
+	0x3746,
+	0x1200,
+	0x1300,
+	0x0315,
+	0x1083,
+	0x0316,
+	0x100f,
+	0x60ff,
+	0x8a68,
+	0x8b7c,
+	0x8c7f,
+	0x8d7f,
+	0x8e7f,
+	0x8f7f,
+	0x907f,
+	0x917f,
+	0x927f,
+	0x937f,
+	0x947a,
+	0x9578,
+	0x9674,
+	0x9770,
+	0x986c,
+	0x9968,
+	0x9a64,
+	0xa081,
+	0xa100,
+	0xa258,
+	0xa382,
+	0xa6f0,
+	0xa8f0,
+	0xF009,
+	0xF180,
+	0xF280,
+	0xF380,
+	0xF480,
+	0x0317,
+	0x1001,
+	0x0318,
+	0x1000,
+	0x0320,
+	0x108f,
+	0x122d,
+	0x17a0,
+	0x1f1f,
+	0x2000,
+	0x211b,
+	0x2277,
+	0x2340,
+	0x2400,
+	0x2566,
+	0x26ff,
+	0x2730,
+	0x2800,
+	0x2913,
+	0x2a88,
+	0x3008,
+	0x313d,
+	0x3260,
+	0x3306,
+	0x34dd,
+	0x35d0,
+	0x3600,
+	0x3709,
+	0x38c4,
+	0x4000,
+	0x4106,
+	0x42dd,
+	0x51f0,
+	0x5224,
+	0x7184,
+	0x7280,
+	0x8032,
+	0x0330,
+	0x1200,
+	0x2008,
+	0x5000,
+	0xe002,
+	0xf000,
+	0x1105,
+	0x03c0,
+	0xe4A0,
+	0x0330,
+	0x7c2c,
+	0x7dce,
+	0x7e2c,
+	0x7fd1,
+	0x8024,
+	0x8170,
+	0x8224,
+	0x8373,
+	0x8421,
+	0x85a6,
+	0x8621,
+	0x87a9,
+	0x8827,
+	0x893a,
+	0x8a27,
+	0x8b3d,
+	0x8c2a,
+	0x8d04,
+	0x8e2a,
+	0x8f07,
+	0x03C0,
+	0x2Ff0,
+	0x3120,
+	0x3320,
+	0x3201,
+	0x03C0,
+	0x2Ff0,
+	0x3120,
+	0x3320,
+	0x3201,
+	0x0300,
+	0x1013,
+	0x01F0,
+	0x0330,
+	0xDE20,
+	0xDFA5,
+	0x03E7,
+	0x1F18,
+	0x209c,
+	0x210F,
+	0x2250,
+	0x03CD,
+	0x4700,
+	0x1280,
+	0x1380,
+	0x148C,
+	0x1580,
+	0x168C,
+	0x10B9,
+	0x031f,
+	0x1100,
+	0x1260,
+	0x1314,
+	0x1410,
+	0x1500,
+	0x2018,
+	0x2114,
+	0x228C,
+	0x2360,
+	0x2818,
+	0x2902,
+	0x3B18,
+	0x3C8C,
+	0x1019,
+	0x03c4,
+	0x1290,
+	0x1510,
+	0x160a,
+	0x1708,
+	0x1804,
+	0x193c,
+	0x1e00,
+	0x1f1b,
+	0x2077,
+	0x2140,
+	0x1a46,
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x1b5c,
+	0x2600,
+	0x2744,
+	0x28aa,
+	0x2920,
+	0x3611,
+	0x03c3,
+	0x1000,
+	0x38FF,
+	0x39FF,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+	0xE125,
+	0xE203,
+	0x03d5,
+	0x1199,
+	0x1e04,
+	0x8608,
+	0x1f01,
+	0x2040,
+	0x2109,
+	0x22c4,
+	0x8c01,
+	0x8d40,
+	0x9209,
+	0x93c4,
+	0x3300,
+	0x03c0,
+	0x1680,
+	0x1681,
+	0x03c5,
+	0x0e01,
+	0x1030,
+	0x11a5,
+	0x1293,
+	0x131d,
+	0x1402,
+	0x150A,
+	0x1606,
+	0x1708,
+	0x180a,
+	0x1903,
+	0x1aa0,
+	0x1b08,
+	0x1c10,
+	0x1d40,
+	0x1e00,
+	0x1fc8,
+	0x2000,
+	0x219b,
+	0x2200,
+	0x23c8,
+	0x2400,
+	0x25a5,
+	0x2601,
+	0x2709,
+	0x2800,
+	0x2955,
+	0x2a00,
+	0x2bd2,
+	0x2c00,
+	0x2d55,
+	0x2e00,
+	0x2f02,
+	0x300f,
+	0x3158,
+	0x3200,
+	0x3302,
+	0x3451,
+	0x3543,
+	0x3600,
+	0x3707,
+	0x38B9,
+	0x398A,
+	0x3a00,
+	0x3b0F,
+	0x3c73,
+	0x3d14,
+	0x3e02,
+	0x3f02,
+	0x40FB,
+	0x41F0,
+	0x4202,
+	0x4369,
+	0x44FB,
+	0x4520,
+	0x4600,
+	0x4707,
+	0x48B9,
+	0x498A,
+	0x4a00,
+	0x4b0F,
+	0x4c73,
+	0x4d14,
+	0x4e00,
+	0x4f00,
+	0x5055,
+	0x5155,
+	0x5255,
+	0x5355,
+	0x5455,
+	0x5555,
+	0x5655,
+	0x5755,
+	0x5855,
+	0x5955,
+	0x5aaa,
+	0x5b55,
+	0x5c55,
+	0x5daa,
+	0x5e55,
+	0x5f55,
+	0x60aa,
+	0x6155,
+	0x6255,
+	0x6355,
+	0x6455,
+	0x6555,
+	0x6655,
+	0x6755,
+	0x6855,
+	0x6955,
+	0x6a55,
+	0x6b16,
+	0x6c25,
+	0x6d29,
+	0x6e30,
+	0x6f33,
+	0x7039,
+	0x7142,
+	0x724e,
+	0x7359,
+	0x7464,
+	0x75ad,
+	0x76C0,
+	0x7783,
+	0x7871,
+	0x795C,
+	0x7a4E,
+	0x7b45,
+	0x7c3e,
+	0x7d3a,
+	0x7e37,
+	0x7f35,
+	0x802a,
+	0x81D0,
+	0x82A7,
+	0x839F,
+	0x8486,
+	0x857c,
+	0x8671,
+	0x8762,
+	0x884f,
+	0x8945,
+	0x8a3f,
+	0x8b31,
+	0x8c16,
+	0x8d24,
+	0x8e27,
+	0x8f2b,
+	0x902e,
+	0x9132,
+	0x9237,
+	0x933e,
+	0x9447,
+	0x9562,
+	0x96ad,
+	0x97C8,
+	0x989F,
+	0x9990,
+	0x9a83,
+	0x9b73,
+	0x9c68,
+	0x9d5A,
+	0x9e50,
+	0x9f45,
+	0xa03b,
+	0xa12d,
+	0xa232,
+	0xa337,
+	0xa441,
+	0xa546,
+	0xa64b,
+	0xa750,
+	0xa85a,
+	0xa96e,
+	0xaa03,
+	0xab03,
+	0xac03,
+	0xad03,
+	0xae00,
+	0xaf00,
+	0xb000,
+	0xb100,
+	0xb294,
+	0xb394,
+	0xb494,
+	0xb594,
+	0xb600,
+	0xb781,
+	0xb881,
+	0xb981,
+	0xba00,
+	0xbb00,
+	0xbc00,
+	0xbd00,
+	0xbe00,
+	0xbf00,
+	0xc000,
+	0xc100,
+	0xc200,
+	0xc300,
+	0xc400,
+	0xc500,
+	0xc600,
+	0xc700,
+	0xc800,
+	0xc900,
+	0xca00,
+	0xcb00,
+	0xcc00,
+	0xcd00,
+	0xce20,
+	0xcf80,
+	0xd020,
+	0xd100,
+	0xd20a,
+	0xd319,
+	0xd42d,
+	0xd53c,
+	0xd64b,
+	0xd755,
+	0xd864,
+	0xd964,
+	0xda5a,
+	0xdb4b,
+	0xdc3c,
+	0xdd28,
+	0xde1e,
+	0xdf14,
+	0xe00a,
+	0xe10a,
+	0xe2ff,
+	0xe3ff,
+	0xe4ff,
+	0xe5ff,
+	0xe6ff,
+	0xe7ff,
+	0xe880,
+	0xe930,
+	0xea1e,
+	0xeb1e,
+	0xec1e,
+	0xed80,
+	0xee80,
+	0xef80,
+	0xf080,
+	0xf180,
+	0xf240,
+	0xf320,
+	0xf40a,
+	0xf50a,
+	0xf60a,
+	0xf70a,
+	0xf832,
+	0xf902,
+	0xfa32,
+	0xfb28,
+	0xfc64,
+	0xfd1E,
+	0x0e00,
+	0x03c6,
+	0x0e01,
+	0x1028,
+	0x1150,
+	0x121e,
+	0x1332,
+	0x144B,
+	0x151e,
+	0x1608,
+	0x17e0,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba4,
+	0x1c0a,
+	0x1d04,
+	0x1e14,
+	0x1f29,
+	0x202E,
+	0x2134,
+	0x223B,
+	0x2343,
+	0x244A,
+	0x2551,
+	0x2659,
+	0x2761,
+	0x28A0,
+	0x299F,
+	0x2a58,
+	0x2b54,
+	0x2c4F,
+	0x2d49,
+	0x2e46,
+	0x2f44,
+	0x3042,
+	0x3141,
+	0x3240,
+	0x333C,
+	0x34AA,
+	0x3568,
+	0x3666,
+	0x3764,
+	0x3862,
+	0x395F,
+	0x3a5C,
+	0x3b59,
+	0x3c53,
+	0x3d50,
+	0x3e4A,
+	0x3f14,
+	0x402A,
+	0x4130,
+	0x4237,
+	0x433E,
+	0x4446,
+	0x454D,
+	0x4654,
+	0x475B,
+	0x4861,
+	0x49A0,
+	0x4aA5,
+	0x4b5F,
+	0x4c5C,
+	0x4d57,
+	0x4e54,
+	0x4f50,
+	0x504E,
+	0x514B,
+	0x5248,
+	0x5347,
+	0x5443,
+	0x5550,
+	0x5655,
+	0x575a,
+	0x585f,
+	0x5964,
+	0x5a69,
+	0x5b6e,
+	0x5c73,
+	0x5d00,
+	0x5e00,
+	0x5f00,
+	0x6000,
+	0x6100,
+	0x6200,
+	0x6300,
+	0x6400,
+	0x6500,
+	0x6600,
+	0x6700,
+	0x6800,
+	0x6900,
+	0x6a00,
+	0x6b00,
+	0x6c00,
+	0x6d00,
+	0x6e00,
+	0x6f00,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7a00,
+	0x7b00,
+	0x7c00,
+	0x7d00,
+	0x7e00,
+	0x7f00,
+	0x8011,
+	0x8122,
+	0x8222,
+	0x8333,
+	0x8433,
+	0x8512,
+	0x861e,
+	0x8728,
+	0x882d,
+	0x892d,
+	0x8a12,
+	0x8b0a,
+	0x8c15,
+	0x8d1f,
+	0x8e16,
+	0x8f15,
+	0x900a,
+	0x910a,
+	0x920a,
+	0x930a,
+	0x940a,
+	0x95ff,
+	0x96ff,
+	0x97ff,
+	0x98ff,
+	0x99ff,
+	0x9aff,
+	0x9bff,
+	0x9cff,
+	0x9dff,
+	0x9eff,
+	0x9fff,
+	0xa008,
+	0xa108,
+	0xa208,
+	0xa30d,
+	0xa410,
+	0xa512,
+	0xa612,
+	0xa712,
+	0xa813,
+	0xa913,
+	0xaa14,
+	0xab0a,
+	0xac01,
+	0xad14,
+	0xae19,
+	0xaf55,
+	0xb01E,
+	0xb128,
+	0xb21E,
+	0xb350,
+	0xb41e,
+	0xb53c,
+	0xb61e,
+	0xb708,
+	0xb8d2,
+	0xb960,
+	0xba66,
+	0xbb66,
+	0xbc80,
+	0xbd0a,
+	0xbe04,
+	0x0e00,
+	0x03d4,
+	0x315e,
+	0x326a,
+	0x356c,
+	0x367e,
+	0x375e,
+	0x3872,
+	0x3b6c,
+	0x3c7b,
+	0x3d46,
+	0x3e90,
+	0x4140,
+	0x42a7,
+	0x03c9,
+	0x4268,
+	0x4340,
+	0x4470,
+	0x03CD,
+	0x4706,
+	0x10B8,
+	0x03cf,
+	0x0e01,
+	0x1000,
+	0x1105,
+	0x1201,
+	0x1302,
+	0x149d,
+	0x157a,
+	0x16b8,
+	0x1700,
+	0x18D5,
+	0x19B7,
+	0x1aea,
+	0x1b00,
+	0x1c07,
+	0x1dB9,
+	0x1e8A,
+	0x1f00,
+	0x2000,
+	0x2120,
+	0x22F6,
+	0x2378,
+	0x2458,
+	0x2538,
+	0x2660,
+	0x2740,
+	0x2801,
+	0x2900,
+	0x2a00,
+	0x2b00,
+	0x2c00,
+	0x2d00,
+	0x2eC6,
+	0x2f44,
+	0x30d6,
+	0x3100,
+	0x3200,
+	0x3300,
+	0x3400,
+	0x3500,
+	0x3600,
+	0x3700,
+	0x3800,
+	0x3900,
+	0x3a14,
+	0x3b00,
+	0x3c00,
+	0x3d00,
+	0x3e00,
+	0x3f28,
+	0x4028,
+	0x4128,
+	0x422e,
+	0x432e,
+	0x442e,
+	0x4533,
+	0x4633,
+	0x4733,
+	0x4833,
+	0x4933,
+	0x4a33,
+	0x4b80,
+	0x4c80,
+	0x4d80,
+	0x4e80,
+	0x4f80,
+	0x5080,
+	0x5180,
+	0x5280,
+	0x5380,
+	0x5480,
+	0x5580,
+	0x5680,
+	0x5700,
+	0x5800,
+	0x5900,
+	0x5a00,
+	0x5b00,
+	0x5c00,
+	0x5d00,
+	0x5e00,
+	0x5f00,
+	0x6000,
+	0x6100,
+	0x6200,
+	0x6300,
+	0x6402,
+	0x6504,
+	0x660a,
+	0x6711,
+	0x6823,
+	0x6936,
+	0x6a46,
+	0x6b57,
+	0x6c64,
+	0x6d6f,
+	0x6e78,
+	0x6f80,
+	0x7087,
+	0x718c,
+	0x7291,
+	0x7396,
+	0x749a,
+	0x759f,
+	0x76a3,
+	0x77a8,
+	0x78af,
+	0x79b6,
+	0x7abc,
+	0x7bc6,
+	0x7cd1,
+	0x7ddb,
+	0x7ee2,
+	0x7fe9,
+	0x80f0,
+	0x81f6,
+	0x82fa,
+	0x83fe,
+	0x84ff,
+	0x8500,
+	0x8602,
+	0x8704,
+	0x880a,
+	0x8911,
+	0x8a23,
+	0x8b36,
+	0x8c46,
+	0x8d57,
+	0x8e64,
+	0x8f6f,
+	0x9078,
+	0x9180,
+	0x9287,
+	0x938c,
+	0x9491,
+	0x9596,
+	0x969a,
+	0x979f,
+	0x98a3,
+	0x99a8,
+	0x9aaf,
+	0x9bb6,
+	0x9cbc,
+	0x9dc6,
+	0x9ed1,
+	0x9fdb,
+	0xa0e2,
+	0xa1e9,
+	0xa2f0,
+	0xa3f6,
+	0xa4fa,
+	0xa5fe,
+	0xa6ff,
+	0xa700,
+	0xa802,
+	0xa904,
+	0xaa0a,
+	0xab11,
+	0xac23,
+	0xad36,
+	0xae46,
+	0xaf57,
+	0xb064,
+	0xb16f,
+	0xb278,
+	0xb380,
+	0xb487,
+	0xb58c,
+	0xb691,
+	0xb796,
+	0xb89a,
+	0xb99f,
+	0xbaa3,
+	0xbba8,
+	0xbcaf,
+	0xbdb6,
+	0xbebc,
+	0xbfc6,
+	0xc0d1,
+	0xc1db,
+	0xc2e2,
+	0xc3e9,
+	0xc4f0,
+	0xc5f6,
+	0xc6fa,
+	0xc7fe,
+	0xc8ff,
+	0xc900,
+	0xca02,
+	0xcb04,
+	0xcc0a,
+	0xcd15,
+	0xce24,
+	0xcf34,
+	0xd044,
+	0xd151,
+	0xd25f,
+	0xd36b,
+	0xd475,
+	0xd57d,
+	0xd685,
+	0xd78a,
+	0xd88f,
+	0xd993,
+	0xda98,
+	0xdb9c,
+	0xdca0,
+	0xdda5,
+	0xdeab,
+	0xdfb2,
+	0xe0ba,
+	0xe1c6,
+	0xe2d3,
+	0xe3de,
+	0xe4e7,
+	0xe5ed,
+	0xe6f3,
+	0xe7f7,
+	0xe8fa,
+	0xe9fe,
+	0xeaff,
+	0xeb00,
+	0xec02,
+	0xed04,
+	0xee0a,
+	0xef15,
+	0xf024,
+	0xf134,
+	0xf244,
+	0xf351,
+	0xf45f,
+	0xf56b,
+	0xf675,
+	0xf77d,
+	0xf885,
+	0xf98a,
+	0xfa8f,
+	0xfb93,
+	0xfc98,
+	0xfd9c,
+	0x0e00,
+	0x03d0,
+	0x0e01,
+	0x10a0,
+	0x11a5,
+	0x12ab,
+	0x13b2,
+	0x14ba,
+	0x15c6,
+	0x16d3,
+	0x17de,
+	0x18e7,
+	0x19ed,
+	0x1af3,
+	0x1bf7,
+	0x1cfa,
+	0x1dfe,
+	0x1eff,
+	0x1f00,
+	0x2002,
+	0x2104,
+	0x220a,
+	0x2315,
+	0x2424,
+	0x2534,
+	0x2644,
+	0x2751,
+	0x285f,
+	0x296b,
+	0x2a75,
+	0x2b7d,
+	0x2c85,
+	0x2d8a,
+	0x2e8f,
+	0x2f93,
+	0x3098,
+	0x319c,
+	0x32a0,
+	0x33a5,
+	0x34ab,
+	0x35b2,
+	0x36ba,
+	0x37c6,
+	0x38d3,
+	0x39de,
+	0x3ae7,
+	0x3bed,
+	0x3cf3,
+	0x3df7,
+	0x3efa,
+	0x3ffe,
+	0x40ff,
+	0x4100,
+	0x4201,
+	0x4304,
+	0x440a,
+	0x4514,
+	0x4623,
+	0x4730,
+	0x4840,
+	0x494d,
+	0x4a57,
+	0x4b62,
+	0x4c6b,
+	0x4d73,
+	0x4e7a,
+	0x4f82,
+	0x5089,
+	0x518e,
+	0x5294,
+	0x5399,
+	0x549e,
+	0x55a2,
+	0x56aa,
+	0x57b1,
+	0x58b9,
+	0x59c4,
+	0x5ace,
+	0x5bd6,
+	0x5cdc,
+	0x5de1,
+	0x5ee6,
+	0x5fec,
+	0x60f1,
+	0x61f5,
+	0x62f9,
+	0x6300,
+	0x6401,
+	0x6504,
+	0x660a,
+	0x6714,
+	0x6823,
+	0x6930,
+	0x6a40,
+	0x6b4d,
+	0x6c57,
+	0x6d62,
+	0x6e6b,
+	0x6f73,
+	0x707a,
+	0x7182,
+	0x7289,
+	0x738e,
+	0x7494,
+	0x7599,
+	0x769e,
+	0x77a2,
+	0x78aa,
+	0x79b1,
+	0x7ab9,
+	0x7bc4,
+	0x7cce,
+	0x7dd6,
+	0x7edc,
+	0x7fe1,
+	0x80e6,
+	0x81ec,
+	0x82f1,
+	0x83f5,
+	0x84f9,
+	0x8500,
+	0x8601,
+	0x8704,
+	0x880a,
+	0x8914,
+	0x8a23,
+	0x8b30,
+	0x8c40,
+	0x8d4d,
+	0x8e57,
+	0x8f62,
+	0x906b,
+	0x9173,
+	0x927a,
+	0x9382,
+	0x9489,
+	0x958e,
+	0x9694,
+	0x9799,
+	0x989e,
+	0x99a2,
+	0x9aaa,
+	0x9bb1,
+	0x9cb9,
+	0x9dc4,
+	0x9ece,
+	0x9fd6,
+	0xa0dc,
+	0xa1e1,
+	0xa2e6,
+	0xa3ec,
+	0xa4f1,
+	0xa5f5,
+	0xa6f9,
+	0xa700,
+	0xa801,
+	0xa904,
+	0xaa0a,
+	0xab14,
+	0xac23,
+	0xad30,
+	0xae40,
+	0xaf4d,
+	0xb057,
+	0xb162,
+	0xb26b,
+	0xb373,
+	0xb47a,
+	0xb582,
+	0xb689,
+	0xb78e,
+	0xb894,
+	0xb999,
+	0xba9e,
+	0xbba2,
+	0xbcaa,
+	0xbdb1,
+	0xbeb9,
+	0xbfc4,
+	0xc0ce,
+	0xc1d6,
+	0xc2dc,
+	0xc3e1,
+	0xc4e6,
+	0xc5ec,
+	0xc6f1,
+	0xc7f5,
+	0xc8f9,
+	0xc900,
+	0xca01,
+	0xcb04,
+	0xcc0a,
+	0xcd14,
+	0xce23,
+	0xcf30,
+	0xd040,
+	0xd14d,
+	0xd257,
+	0xd362,
+	0xd46b,
+	0xd573,
+	0xd67a,
+	0xd782,
+	0xd889,
+	0xd98e,
+	0xda94,
+	0xdb99,
+	0xdc9e,
+	0xdda2,
+	0xdeaa,
+	0xdfb1,
+	0xe0b9,
+	0xe1c4,
+	0xe2ce,
+	0xe3d6,
+	0xe4dc,
+	0xe5e1,
+	0xe6e6,
+	0xe7ec,
+	0xe8f1,
+	0xe9f5,
+	0xeaf9,
+	0xeb00,
+	0xec01,
+	0xed04,
+	0xee0a,
+	0xef14,
+	0xf023,
+	0xf130,
+	0xf240,
+	0xf34d,
+	0xf457,
+	0xf562,
+	0xf66b,
+	0xf773,
+	0xf87a,
+	0xf982,
+	0xfa89,
+	0xfb8e,
+	0xfc94,
+	0xfd99,
+	0x0e00,
+	0x03d1,
+	0x0e01,
+	0x109e,
+	0x11a2,
+	0x12aa,
+	0x13b1,
+	0x14b9,
+	0x15c4,
+	0x16ce,
+	0x17d6,
+	0x18dc,
+	0x19e1,
+	0x1ae6,
+	0x1bec,
+	0x1cf1,
+	0x1df5,
+	0x1ef9,
+	0x1f80,
+	0x2080,
+	0x2180,
+	0x2280,
+	0x2380,
+	0x2480,
+	0x2580,
+	0x2680,
+	0x2780,
+	0x2880,
+	0x2980,
+	0x2a80,
+	0x2b88,
+	0x2c88,
+	0x2d88,
+	0x2e88,
+	0x2f88,
+	0x308c,
+	0x3198,
+	0x3298,
+	0x3398,
+	0x3498,
+	0x3598,
+	0x3698,
+	0x3780,
+	0x3880,
+	0x3980,
+	0x3a78,
+	0x3b88,
+	0x3c84,
+	0x3d8c,
+	0x3e8c,
+	0x3f8c,
+	0x408c,
+	0x418c,
+	0x428c,
+	0x432f,
+	0x4468,
+	0x4529,
+	0x4601,
+	0x4719,
+	0x486c,
+	0x4913,
+	0x4a13,
+	0x4b1e,
+	0x4c71,
+	0x4d2f,
+	0x4e68,
+	0x4f29,
+	0x5001,
+	0x5119,
+	0x526c,
+	0x5313,
+	0x5413,
+	0x551e,
+	0x5671,
+	0x572f,
+	0x5868,
+	0x5929,
+	0x5a01,
+	0x5b19,
+	0x5c6c,
+	0x5d13,
+	0x5e13,
+	0x5f1e,
+	0x6071,
+	0x612f,
+	0x626a,
+	0x6332,
+	0x6408,
+	0x651a,
+	0x666c,
+	0x6712,
+	0x6803,
+	0x6930,
+	0x6a73,
+	0x6b2f,
+	0x6c68,
+	0x6d29,
+	0x6e01,
+	0x6f17,
+	0x706c,
+	0x7115,
+	0x7201,
+	0x7330,
+	0x7471,
+	0x752f,
+	0x7668,
+	0x7729,
+	0x7801,
+	0x7917,
+	0x7a6c,
+	0x7b15,
+	0x7c01,
+	0x7d30,
+	0x7e71,
+	0x7f2f,
+	0x806a,
+	0x813c,
+	0x8212,
+	0x8321,
+	0x8470,
+	0x850f,
+	0x8606,
+	0x872d,
+	0x8873,
+	0x892f,
+	0x8a6a,
+	0x8b3c,
+	0x8c12,
+	0x8d21,
+	0x8e70,
+	0x8f0f,
+	0x9006,
+	0x912d,
+	0x9273,
+	0x932f,
+	0x946a,
+	0x953c,
+	0x9612,
+	0x9721,
+	0x9870,
+	0x990f,
+	0x9a06,
+	0x9b2d,
+	0x9c73,
+	0x9d2f,
+	0x9e6a,
+	0x9f3c,
+	0xa012,
+	0xa121,
+	0xa270,
+	0xa30f,
+	0xa406,
+	0xa52d,
+	0xa673,
+	0xa72f,
+	0xa86a,
+	0xa93c,
+	0xaa12,
+	0xab21,
+	0xac70,
+	0xad0f,
+	0xae06,
+	0xaf2d,
+	0xb073,
+	0xb12f,
+	0xb26a,
+	0xb33c,
+	0xb412,
+	0xb521,
+	0xb670,
+	0xb70f,
+	0xb806,
+	0xb92d,
+	0xba73,
+	0xbb80,
+	0xbc00,
+	0xbd80,
+	0xbe00,
+	0xbf35,
+	0xc013,
+	0xc180,
+	0xc200,
+	0xc376,
+	0xc41c,
+	0xc580,
+	0xc600,
+	0xc7ac,
+	0xc81c,
+	0xc980,
+	0xca00,
+	0xcb4c,
+	0xcc20,
+	0xcd80,
+	0xce00,
+	0xcf76,
+	0xd01c,
+	0xd180,
+	0xd200,
+	0xd352,
+	0xd41d,
+	0xd580,
+	0xd600,
+	0xd780,
+	0xd800,
+	0xd935,
+	0xda13,
+	0xdb80,
+	0xdc00,
+	0xdd76,
+	0xde1c,
+	0xdf80,
+	0xe000,
+	0xe1ac,
+	0xe21c,
+	0xe380,
+	0xe400,
+	0xe54c,
+	0xe620,
+	0xe780,
+	0xe800,
+	0xe976,
+	0xea1c,
+	0xeb80,
+	0xec00,
+	0xed52,
+	0xee1d,
+	0xef80,
+	0xf000,
+	0xf180,
+	0xf200,
+	0xf335,
+	0xf413,
+	0xf580,
+	0xf600,
+	0xf776,
+	0xf81c,
+	0xf980,
+	0xfa00,
+	0xfbac,
+	0xfc1c,
+	0xfd80,
+	0x0e00,
+	0x03d2,
+	0x0e01,
+	0x1000,
+	0x114c,
+	0x1220,
+	0x1380,
+	0x1400,
+	0x1576,
+	0x161c,
+	0x1780,
+	0x1800,
+	0x1952,
+	0x1a1d,
+	0x1b80,
+	0x1c00,
+	0x1d70,
+	0x1e04,
+	0x1f36,
+	0x200d,
+	0x21b0,
+	0x2210,
+	0x236b,
+	0x241c,
+	0x2570,
+	0x2600,
+	0x27af,
+	0x281c,
+	0x2980,
+	0x2a87,
+	0x2b51,
+	0x2c1c,
+	0x2db0,
+	0x2e10,
+	0x2f76,
+	0x301c,
+	0x3180,
+	0x3200,
+	0x339a,
+	0x3414,
+	0x3580,
+	0x3600,
+	0x3780,
+	0x380a,
+	0x3932,
+	0x3a0f,
+	0x3b90,
+	0x3c14,
+	0x3d6a,
+	0x3e14,
+	0x3f70,
+	0x408e,
+	0x41af,
+	0x421c,
+	0x439a,
+	0x4400,
+	0x4551,
+	0x4618,
+	0x47a9,
+	0x4810,
+	0x497c,
+	0x4a18,
+	0x4ba0,
+	0x4c00,
+	0x4d99,
+	0x4e1e,
+	0x4f80,
+	0x5000,
+	0x5178,
+	0x5208,
+	0x5332,
+	0x540f,
+	0x5590,
+	0x560a,
+	0x576a,
+	0x5814,
+	0x5970,
+	0x5a88,
+	0x5baf,
+	0x5c1c,
+	0x5d9a,
+	0x5e00,
+	0x5f4b,
+	0x6018,
+	0x6190,
+	0x6210,
+	0x637c,
+	0x6418,
+	0x65a0,
+	0x6600,
+	0x6799,
+	0x681e,
+	0x6980,
+	0x6a00,
+	0x6b60,
+	0x6c08,
+	0x6d34,
+	0x6e0c,
+	0x6f93,
+	0x7010,
+	0x715e,
+	0x7214,
+	0x73a0,
+	0x7488,
+	0x75af,
+	0x7628,
+	0x7780,
+	0x788a,
+	0x7948,
+	0x7a14,
+	0x7b80,
+	0x7c0c,
+	0x7d72,
+	0x7e14,
+	0x7f80,
+	0x8000,
+	0x819a,
+	0x8214,
+	0x8380,
+	0x8400,
+	0x8560,
+	0x8608,
+	0x8734,
+	0x880c,
+	0x8993,
+	0x8a10,
+	0x8b5e,
+	0x8c14,
+	0x8da0,
+	0x8e88,
+	0x8faf,
+	0x9028,
+	0x9180,
+	0x928a,
+	0x9348,
+	0x9414,
+	0x9580,
+	0x960c,
+	0x9772,
+	0x9814,
+	0x9980,
+	0x9a00,
+	0x9b9a,
+	0x9c14,
+	0x9d80,
+	0x9e00,
+	0x9f60,
+	0xa008,
+	0xa134,
+	0xa20c,
+	0xa393,
+	0xa410,
+	0xa55e,
+	0xa614,
+	0xa7a0,
+	0xa888,
+	0xa9af,
+	0xaa28,
+	0xab80,
+	0xac8a,
+	0xad48,
+	0xae14,
+	0xaf80,
+	0xb00c,
+	0xb172,
+	0xb214,
+	0xb380,
+	0xb400,
+	0xb59a,
+	0xb614,
+	0xb780,
+	0xb800,
+	0xb960,
+	0xba08,
+	0xbb34,
+	0xbc0c,
+	0xbd93,
+	0xbe10,
+	0xbf5e,
+	0xc014,
+	0xc1a0,
+	0xc288,
+	0xc3af,
+	0xc428,
+	0xc580,
+	0xc68a,
+	0xc748,
+	0xc814,
+	0xc980,
+	0xca0c,
+	0xcb72,
+	0xcc14,
+	0xcd80,
+	0xce00,
+	0xcf9a,
+	0xd014,
+	0xd180,
+	0xd200,
+	0xd360,
+	0xd408,
+	0xd534,
+	0xd60c,
+	0xd793,
+	0xd810,
+	0xd95e,
+	0xda14,
+	0xdba0,
+	0xdc88,
+	0xddaf,
+	0xde28,
+	0xdf80,
+	0xe08a,
+	0xe148,
+	0xe214,
+	0xe380,
+	0xe40c,
+	0xe572,
+	0xe614,
+	0xe780,
+	0xe800,
+	0xe99a,
+	0xea14,
+	0xeb80,
+	0xec00,
+	0xed60,
+	0xee08,
+	0xef34,
+	0xf00c,
+	0xf193,
+	0xf210,
+	0xf35e,
+	0xf414,
+	0xf5a0,
+	0xf688,
+	0xf7af,
+	0xf828,
+	0xf980,
+	0xfa8a,
+	0xfb48,
+	0xfc14,
+	0xfd80,
+	0x0e00,
+	0x03d3,
+	0x0e01,
+	0x100c,
+	0x1172,
+	0x1214,
+	0x1380,
+	0x1400,
+	0x159a,
+	0x1614,
+	0x1700,
+	0x1800,
+	0x1900,
+	0x1a00,
+	0x1b5c,
+	0x1c60,
+	0x1d60,
+	0x1e5c,
+	0x1f00,
+	0x2000,
+	0x2100,
+	0x2200,
+	0x235c,
+	0x2460,
+	0x2560,
+	0x265c,
+	0x2700,
+	0x2800,
+	0x2900,
+	0x2a00,
+	0x2b5c,
+	0x2c60,
+	0x2d60,
+	0x2e5c,
+	0x2f00,
+	0x3000,
+	0x3100,
+	0x3200,
+	0x3380,
+	0x3480,
+	0x3576,
+	0x3680,
+	0x3700,
+	0x3800,
+	0x3900,
+	0x3a00,
+	0x3b80,
+	0x3c80,
+	0x3d76,
+	0x3e80,
+	0x3f00,
+	0x4000,
+	0x4100,
+	0x4200,
+	0x4380,
+	0x4480,
+	0x4576,
+	0x4680,
+	0x4700,
+	0x4800,
+	0x4900,
+	0x4a00,
+	0x4b80,
+	0x4c80,
+	0x4d80,
+	0x4e80,
+	0x4f00,
+	0x5000,
+	0x5100,
+	0x5200,
+	0x5380,
+	0x5480,
+	0x5580,
+	0x5680,
+	0x5700,
+	0x5800,
+	0x5900,
+	0x5a00,
+	0x5b80,
+	0x5c80,
+	0x5d80,
+	0x5e80,
+	0x5f00,
+	0x6000,
+	0x6100,
+	0x6200,
+	0x6380,
+	0x6480,
+	0x6580,
+	0x6680,
+	0x6700,
+	0x6800,
+	0x6900,
+	0x6a00,
+	0x6b80,
+	0x6c80,
+	0x6d80,
+	0x6e80,
+	0x6f00,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7380,
+	0x7480,
+	0x7580,
+	0x7680,
+	0x7760,
+	0x7820,
+	0x7960,
+	0x7a40,
+	0x7b20,
+	0x7c00,
+	0x7d02,
+	0x7e0f,
+	0x7f58,
+	0x8000,
+	0x8100,
+	0x82c3,
+	0x8350,
+	0x8478,
+	0x8562,
+	0x8608,
+	0x8702,
+	0x8800,
+	0x8900,
+	0x8a00,
+	0x8b00,
+	0x8c80,
+	0x8d80,
+	0x8e80,
+	0x8f80,
+	0x9050,
+	0x9150,
+	0x0e00,
+	0x03d9,
+	0x0e01,
+	0x1003,
+	0x1110,
+	0x1261,
+	0x1380,
+	0x1462,
+	0x1580,
+	0x1640,
+	0x1700,
+	0x1848,
+	0x1980,
+	0x1a03,
+	0x1b16,
+	0x1c30,
+	0x1d7f,
+	0x1e31,
+	0x1f42,
+	0x2032,
+	0x2103,
+	0x2233,
+	0x2322,
+	0x2434,
+	0x257b,
+	0x2635,
+	0x2719,
+	0x2836,
+	0x2901,
+	0x2a37,
+	0x2b43,
+	0x2c38,
+	0x2d84,
+	0x2e70,
+	0x2f80,
+	0x3071,
+	0x3100,
+	0x3272,
+	0x339b,
+	0x3473,
+	0x3505,
+	0x3674,
+	0x3734,
+	0x3875,
+	0x391e,
+	0x3a76,
+	0x3ba6,
+	0x3c77,
+	0x3d10,
+	0x3e78,
+	0x3f69,
+	0x4079,
+	0x411e,
+	0x427a,
+	0x4380,
+	0x447b,
+	0x4580,
+	0x467c,
+	0x47ad,
+	0x487d,
+	0x491e,
+	0x4a7e,
+	0x4b98,
+	0x4c7f,
+	0x4d80,
+	0x4e80,
+	0x4f51,
+	0x5081,
+	0x511e,
+	0x5282,
+	0x5380,
+	0x5483,
+	0x550c,
+	0x5684,
+	0x5723,
+	0x5885,
+	0x591e,
+	0x5a86,
+	0x5bb3,
+	0x5c87,
+	0x5d8a,
+	0x5e88,
+	0x5f52,
+	0x6089,
+	0x611e,
+	0x6203,
+	0x6317,
+	0x6420,
+	0x6500,
+	0x6621,
+	0x6702,
+	0x6822,
+	0x6904,
+	0x6a23,
+	0x6b09,
+	0x6c24,
+	0x6d12,
+	0x6e25,
+	0x6f23,
+	0x7026,
+	0x7137,
+	0x7227,
+	0x7347,
+	0x7428,
+	0x7557,
+	0x7629,
+	0x7761,
+	0x782a,
+	0x796b,
+	0x7a2b,
+	0x7b71,
+	0x7c2c,
+	0x7d76,
+	0x7e2d,
+	0x7f7a,
+	0x802e,
+	0x817f,
+	0x822f,
+	0x8384,
+	0x8430,
+	0x8588,
+	0x8631,
+	0x878c,
+	0x8832,
+	0x8991,
+	0x8a33,
+	0x8b94,
+	0x8c34,
+	0x8d98,
+	0x8e35,
+	0x8f9f,
+	0x9036,
+	0x91a6,
+	0x9237,
+	0x93ae,
+	0x9438,
+	0x95bb,
+	0x9639,
+	0x97c9,
+	0x983a,
+	0x99d3,
+	0x9a3b,
+	0x9bdc,
+	0x9c3c,
+	0x9de2,
+	0x9e3d,
+	0x9fe8,
+	0xa03e,
+	0xa1ed,
+	0xa23f,
+	0xa3f4,
+	0xa440,
+	0xa5fa,
+	0xa641,
+	0xa7ff,
+	0xa803,
+	0xa920,
+	0xaa39,
+	0xab40,
+	0xac03,
+	0xad15,
+	0xae24,
+	0xaf00,
+	0xb025,
+	0xb100,
+	0xb226,
+	0xb300,
+	0xb427,
+	0xb500,
+	0xb628,
+	0xb780,
+	0xb829,
+	0xb980,
+	0xba2a,
+	0xbb80,
+	0xbc2b,
+	0xbd80,
+	0xbe11,
+	0xbf40,
+	0x0e00,
+	0x03da,
+	0x0e01,
+	0x1003,
+	0x1111,
+	0x1210,
+	0x1313,
+	0x1411,
+	0x1525,
+	0x1612,
+	0x1722,
+	0x1813,
+	0x1911,
+	0x1a14,
+	0x1b21,
+	0x1c30,
+	0x1d20,
+	0x1e31,
+	0x1f20,
+	0x2032,
+	0x2170,
+	0x2233,
+	0x234a,
+	0x2434,
+	0x252a,
+	0x2635,
+	0x272b,
+	0x2836,
+	0x2916,
+	0x2a37,
+	0x2b1b,
+	0x2c38,
+	0x2d14,
+	0x2e39,
+	0x2f10,
+	0x303a,
+	0x3110,
+	0x323b,
+	0x332c,
+	0x343c,
+	0x3560,
+	0x363d,
+	0x3738,
+	0x383e,
+	0x3968,
+	0x3a3f,
+	0x3b68,
+	0x3c40,
+	0x3d68,
+	0x3e41,
+	0x3f1a,
+	0x4042,
+	0x411a,
+	0x4243,
+	0x431a,
+	0x4444,
+	0x4530,
+	0x4645,
+	0x4730,
+	0x4846,
+	0x4940,
+	0x4a47,
+	0x4b40,
+	0x4c48,
+	0x4d40,
+	0x4e49,
+	0x4ff0,
+	0x504a,
+	0x51f0,
+	0x524b,
+	0x53f0,
+	0x544c,
+	0x55f0,
+	0x564d,
+	0x57f0,
+	0x584e,
+	0x59f0,
+	0x5a4f,
+	0x5bf0,
+	0x5c50,
+	0x5df0,
+	0x5e51,
+	0x5f60,
+	0x6052,
+	0x6160,
+	0x6253,
+	0x6360,
+	0x6454,
+	0x6560,
+	0x6655,
+	0x6760,
+	0x6856,
+	0x6960,
+	0x6a57,
+	0x6b60,
+	0x6c58,
+	0x6d60,
+	0x6e59,
+	0x6f80,
+	0x705a,
+	0x7180,
+	0x725b,
+	0x7380,
+	0x745c,
+	0x7580,
+	0x765d,
+	0x7780,
+	0x785e,
+	0x7980,
+	0x7a5f,
+	0x7b80,
+	0x7c60,
+	0x7d80,
+	0x7e61,
+	0x7ff0,
+	0x8062,
+	0x81fc,
+	0x8263,
+	0x8360,
+	0x8464,
+	0x8520,
+	0x8665,
+	0x8724,
+	0x8866,
+	0x8924,
+	0x8a67,
+	0x8b1a,
+	0x8c68,
+	0x8d5a,
+	0x8e69,
+	0x8f24,
+	0x906a,
+	0x9124,
+	0x926b,
+	0x9324,
+	0x946c,
+	0x951a,
+	0x966d,
+	0x975c,
+	0x986e,
+	0x9920,
+	0x9a6f,
+	0x9b26,
+	0x9c70,
+	0x9d26,
+	0x9e71,
+	0x9f30,
+	0xa072,
+	0xa15c,
+	0xa273,
+	0xa320,
+	0xa474,
+	0xa590,
+	0xa675,
+	0xa790,
+	0xa876,
+	0xa980,
+	0xaa77,
+	0xab40,
+	0xac78,
+	0xad26,
+	0xae79,
+	0xaf90,
+	0xb07a,
+	0xb190,
+	0xb27b,
+	0xb380,
+	0xb47c,
+	0xb538,
+	0xb67d,
+	0xb71c,
+	0xb87e,
+	0xb968,
+	0xba7f,
+	0xbb58,
+	0xbc80,
+	0xbd48,
+	0xbe81,
+	0xbf32,
+	0xc082,
+	0xc110,
+	0xc283,
+	0xc368,
+	0xc484,
+	0xc558,
+	0xc685,
+	0xc748,
+	0xc886,
+	0xc91c,
+	0xca87,
+	0xcb08,
+	0xcc88,
+	0xcd64,
+	0xce89,
+	0xcf64,
+	0xd08a,
+	0xd148,
+	0xd290,
+	0xd302,
+	0xd491,
+	0xd548,
+	0xd692,
+	0xd700,
+	0xd893,
+	0xd904,
+	0xda94,
+	0xdb02,
+	0xdc95,
+	0xdd64,
+	0xde96,
+	0xdf14,
+	0xe097,
+	0xe190,
+	0xe2b0,
+	0xe360,
+	0xe4b1,
+	0xe590,
+	0xe6b2,
+	0xe710,
+	0xe8b3,
+	0xe908,
+	0xeab4,
+	0xeb04,
+	0xec03,
+	0xed12,
+	0xee10,
+	0xef03,
+	0xf011,
+	0xf129,
+	0xf212,
+	0xf330,
+	0xf440,
+	0xf537,
+	0xf641,
+	0xf724,
+	0xf842,
+	0xf900,
+	0xfa43,
+	0xfb62,
+	0xfc44,
+	0xfd02,
+	0x0e00,
+	0x03db,
+	0x0e01,
+	0x1045,
+	0x110a,
+	0x1246,
+	0x1340,
+	0x1460,
+	0x1502,
+	0x1661,
+	0x1704,
+	0x1862,
+	0x194b,
+	0x1a63,
+	0x1b41,
+	0x1c64,
+	0x1d14,
+	0x1e65,
+	0x1f00,
+	0x2068,
+	0x210a,
+	0x2269,
+	0x2304,
+	0x246a,
+	0x250a,
+	0x266b,
+	0x270a,
+	0x286c,
+	0x2924,
+	0x2a6d,
+	0x2b01,
+	0x2c70,
+	0x2d01,
+	0x2e71,
+	0x2f3d,
+	0x3080,
+	0x3180,
+	0x3281,
+	0x338a,
+	0x3482,
+	0x350a,
+	0x3683,
+	0x3712,
+	0x3884,
+	0x39c8,
+	0x3a85,
+	0x3b92,
+	0x3c86,
+	0x3d20,
+	0x3e87,
+	0x3f00,
+	0x4088,
+	0x4170,
+	0x4289,
+	0x43aa,
+	0x448a,
+	0x4550,
+	0x468b,
+	0x4710,
+	0x488c,
+	0x4904,
+	0x4a8d,
+	0x4b02,
+	0x4ce6,
+	0x4dff,
+	0x4ee7,
+	0x4f18,
+	0x50e8,
+	0x5120,
+	0x52e9,
+	0x5304,
+	0x5403,
+	0x5513,
+	0x5610,
+	0x573f,
+	0x5820,
+	0x5920,
+	0x5a21,
+	0x5b30,
+	0x5c22,
+	0x5d36,
+	0x5e23,
+	0x5f6a,
+	0x6024,
+	0x61a0,
+	0x6225,
+	0x63c0,
+	0x6426,
+	0x65e0,
+	0x6627,
+	0x670a,
+	0x6828,
+	0x690a,
+	0x6a29,
+	0x6b0a,
+	0x6c2a,
+	0x6d08,
+	0x6e2b,
+	0x6f06,
+	0x702c,
+	0x7105,
+	0x722d,
+	0x7304,
+	0x742e,
+	0x7503,
+	0x762f,
+	0x7701,
+	0x7830,
+	0x7902,
+	0x7a31,
+	0x7b78,
+	0x7c32,
+	0x7d01,
+	0x7e33,
+	0x7f80,
+	0x8034,
+	0x81f0,
+	0x8235,
+	0x8310,
+	0x8436,
+	0x85f0,
+	0x86a0,
+	0x8707,
+	0x88a8,
+	0x8924,
+	0x8aa9,
+	0x8b24,
+	0x8caa,
+	0x8d20,
+	0x8eab,
+	0x8f02,
+	0x90c0,
+	0x9127,
+	0x92c2,
+	0x9308,
+	0x94c3,
+	0x9508,
+	0x96c4,
+	0x9740,
+	0x98c5,
+	0x9978,
+	0x9ac6,
+	0x9bf0,
+	0x9cc7,
+	0x9d10,
+	0x9ec8,
+	0x9f44,
+	0xa0c9,
+	0xa187,
+	0xa2ca,
+	0xa3ff,
+	0xa4cb,
+	0xa520,
+	0xa6cc,
+	0xa761,
+	0xa8cd,
+	0xa987,
+	0xaace,
+	0xab8a,
+	0xaccf,
+	0xada5,
+	0xae03,
+	0xaf14,
+	0xb011,
+	0xb102,
+	0xb211,
+	0xb302,
+	0xb412,
+	0xb560,
+	0xb613,
+	0xb762,
+	0xb814,
+	0xb920,
+	0xba15,
+	0xbb30,
+	0xbc16,
+	0xbd30,
+	0xbe17,
+	0xbf30,
+	0xc018,
+	0xc154,
+	0xc219,
+	0xc354,
+	0xc41a,
+	0xc540,
+	0xc620,
+	0xc7d2,
+	0xc821,
+	0xc903,
+	0xca22,
+	0xcb04,
+	0xcc23,
+	0xcd04,
+	0xce24,
+	0xcf05,
+	0xd025,
+	0xd132,
+	0xd226,
+	0xd330,
+	0xd427,
+	0xd520,
+	0xd628,
+	0xd73c,
+	0xd829,
+	0xd900,
+	0xda2a,
+	0xdb16,
+	0xdc2b,
+	0xdd16,
+	0xde2c,
+	0xdf16,
+	0xe02d,
+	0xe154,
+	0xe22e,
+	0xe354,
+	0xe42f,
+	0xe554,
+	0xe630,
+	0xe782,
+	0xe831,
+	0xe902,
+	0xea32,
+	0xeb04,
+	0xec33,
+	0xed04,
+	0xee34,
+	0xef0a,
+	0xf035,
+	0xf146,
+	0xf236,
+	0xf332,
+	0xf437,
+	0xf528,
+	0xf638,
+	0xf712,
+	0xf839,
+	0xf900,
+	0xfa3a,
+	0xfb24,
+	0xfc3b,
+	0xfd24,
+	0x0e00,
+	0x03dc,
+	0x0e01,
+	0x103c,
+	0x1124,
+	0x123d,
+	0x1324,
+	0x143e,
+	0x1524,
+	0x163f,
+	0x1714,
+	0x1840,
+	0x1982,
+	0x1a41,
+	0x1b1a,
+	0x1c42,
+	0x1d70,
+	0x1e43,
+	0x1f20,
+	0x2044,
+	0x2126,
+	0x2245,
+	0x231e,
+	0x2446,
+	0x2524,
+	0x2647,
+	0x2718,
+	0x2848,
+	0x290a,
+	0x2a49,
+	0x2b10,
+	0x2c50,
+	0x2d82,
+	0x2e51,
+	0x2f38,
+	0x3052,
+	0x31f0,
+	0x3253,
+	0x3378,
+	0x3454,
+	0x3524,
+	0x3655,
+	0x3724,
+	0x3856,
+	0x3924,
+	0x3a57,
+	0x3b10,
+	0x3c58,
+	0x3d14,
+	0x3e59,
+	0x3f10,
+	0x4060,
+	0x4101,
+	0x4261,
+	0x43a0,
+	0x4462,
+	0x4598,
+	0x4663,
+	0x47e4,
+	0x4864,
+	0x49a4,
+	0x4a65,
+	0x4b7d,
+	0x4c66,
+	0x4d4b,
+	0x4e70,
+	0x4f10,
+	0x5071,
+	0x5110,
+	0x5272,
+	0x5310,
+	0x5473,
+	0x5510,
+	0x5674,
+	0x5710,
+	0x5875,
+	0x5910,
+	0x5a76,
+	0x5b38,
+	0x5c77,
+	0x5d38,
+	0x5e78,
+	0x5f38,
+	0x6079,
+	0x6158,
+	0x627a,
+	0x6358,
+	0x647b,
+	0x6558,
+	0x6603,
+	0x6710,
+	0x6860,
+	0x6903,
+	0x6a70,
+	0x6b0c,
+	0x6c71,
+	0x6d00,
+	0x6e72,
+	0x6f7a,
+	0x7073,
+	0x7128,
+	0x7274,
+	0x7314,
+	0x7475,
+	0x750d,
+	0x7676,
+	0x7740,
+	0x7877,
+	0x7949,
+	0x7a78,
+	0x7b99,
+	0x7c79,
+	0x7d4c,
+	0x7e7a,
+	0x7fcc,
+	0x807b,
+	0x8149,
+	0x827c,
+	0x8399,
+	0x847d,
+	0x8514,
+	0x867e,
+	0x8728,
+	0x887f,
+	0x8950,
+	0x8a03,
+	0x8b16,
+	0x8c8a,
+	0x8d68,
+	0x8e8b,
+	0x8f7c,
+	0x908c,
+	0x917f,
+	0x928d,
+	0x937f,
+	0x948e,
+	0x957f,
+	0x968f,
+	0x977f,
+	0x9890,
+	0x997f,
+	0x9a91,
+	0x9b7f,
+	0x9c92,
+	0x9d7f,
+	0x0e00,
+	0x03dd,
+	0x0e01,
+	0x1003,
+	0x1111,
+	0x1210,
+	0x1313,
+	0x1411,
+	0x1508,
+	0x1612,
+	0x171e,
+	0x1813,
+	0x190e,
+	0x1a14,
+	0x1b31,
+	0x1c30,
+	0x1d20,
+	0x1e31,
+	0x1f20,
+	0x2032,
+	0x2152,
+	0x2233,
+	0x233b,
+	0x2434,
+	0x251d,
+	0x2635,
+	0x2721,
+	0x2836,
+	0x291b,
+	0x2a37,
+	0x2b21,
+	0x2c38,
+	0x2d18,
+	0x2e39,
+	0x2f18,
+	0x303a,
+	0x3118,
+	0x323b,
+	0x3318,
+	0x343c,
+	0x351a,
+	0x363d,
+	0x371a,
+	0x383e,
+	0x3920,
+	0x3a3f,
+	0x3b22,
+	0x3c40,
+	0x3d20,
+	0x3e41,
+	0x3f10,
+	0x4042,
+	0x4110,
+	0x4243,
+	0x4310,
+	0x4444,
+	0x4510,
+	0x4645,
+	0x4718,
+	0x4846,
+	0x4918,
+	0x4a47,
+	0x4b40,
+	0x4c48,
+	0x4d40,
+	0x4e49,
+	0x4fe0,
+	0x504a,
+	0x51f0,
+	0x524b,
+	0x53fc,
+	0x544c,
+	0x55fc,
+	0x564d,
+	0x57fc,
+	0x584e,
+	0x59f0,
+	0x5a4f,
+	0x5bf0,
+	0x5c50,
+	0x5df0,
+	0x5e51,
+	0x5f68,
+	0x6052,
+	0x6168,
+	0x6253,
+	0x6368,
+	0x6454,
+	0x6568,
+	0x6655,
+	0x6768,
+	0x6856,
+	0x6968,
+	0x6a57,
+	0x6b68,
+	0x6c58,
+	0x6d68,
+	0x6e59,
+	0x6f70,
+	0x705a,
+	0x7170,
+	0x725b,
+	0x7370,
+	0x745c,
+	0x7570,
+	0x765d,
+	0x7770,
+	0x785e,
+	0x7970,
+	0x7a5f,
+	0x7b70,
+	0x7c60,
+	0x7d70,
+	0x7e61,
+	0x7fc0,
+	0x8062,
+	0x81f0,
+	0x8263,
+	0x8380,
+	0x8464,
+	0x8540,
+	0x8665,
+	0x8780,
+	0x8866,
+	0x8980,
+	0x8a67,
+	0x8b80,
+	0x8c68,
+	0x8d80,
+	0x8e69,
+	0x8f40,
+	0x906a,
+	0x9180,
+	0x926b,
+	0x9380,
+	0x946c,
+	0x9580,
+	0x966d,
+	0x9780,
+	0x986e,
+	0x9940,
+	0x9a6f,
+	0x9b80,
+	0x9c70,
+	0x9d60,
+	0x9e71,
+	0x9f40,
+	0xa072,
+	0xa16e,
+	0xa273,
+	0xa33a,
+	0xa474,
+	0xa580,
+	0xa675,
+	0xa780,
+	0xa876,
+	0xa940,
+	0xaa77,
+	0xab6e,
+	0xac78,
+	0xad66,
+	0xae79,
+	0xaf60,
+	0xb07a,
+	0xb130,
+	0xb27b,
+	0xb320,
+	0xb47c,
+	0xb55c,
+	0xb67d,
+	0xb730,
+	0xb87e,
+	0xb960,
+	0xba7f,
+	0xbb60,
+	0xbc80,
+	0xbd20,
+	0xbe81,
+	0xbf62,
+	0xc082,
+	0xc126,
+	0xc283,
+	0xc360,
+	0xc484,
+	0xc560,
+	0xc685,
+	0xc760,
+	0xc886,
+	0xc962,
+	0xca87,
+	0xcb26,
+	0xcc88,
+	0xcd60,
+	0xce89,
+	0xcf60,
+	0xd08a,
+	0xd160,
+	0xd290,
+	0xd300,
+	0xd491,
+	0xd54e,
+	0xd692,
+	0xd700,
+	0xd893,
+	0xd916,
+	0xda94,
+	0xdb01,
+	0xdc95,
+	0xdd80,
+	0xde96,
+	0xdf55,
+	0xe097,
+	0xe18d,
+	0xe2b0,
+	0xe360,
+	0xe4b1,
+	0xe5b0,
+	0xe6b2,
+	0xe788,
+	0xe8b3,
+	0xe910,
+	0xeab4,
+	0xeb04,
+	0xec03,
+	0xed12,
+	0xee10,
+	0xef03,
+	0xf011,
+	0xf129,
+	0xf212,
+	0xf308,
+	0xf440,
+	0xf533,
+	0xf641,
+	0xf70a,
+	0xf842,
+	0xf96a,
+	0xfa43,
+	0xfb80,
+	0xfc44,
+	0xfd02,
+	0x0e00,
+	0x03de,
+	0x0e01,
+	0x1045,
+	0x110a,
+	0x1246,
+	0x1380,
+	0x1460,
+	0x1521,
+	0x1661,
+	0x170e,
+	0x1862,
+	0x1970,
+	0x1a63,
+	0x1b70,
+	0x1c64,
+	0x1d14,
+	0x1e65,
+	0x1f01,
+	0x2068,
+	0x210a,
+	0x2269,
+	0x2304,
+	0x246a,
+	0x250a,
+	0x266b,
+	0x270a,
+	0x286c,
+	0x2924,
+	0x2a6d,
+	0x2b01,
+	0x2c70,
+	0x2d01,
+	0x2e71,
+	0x2f3d,
+	0x3080,
+	0x3180,
+	0x3281,
+	0x3388,
+	0x3482,
+	0x3508,
+	0x3683,
+	0x370c,
+	0x3884,
+	0x3990,
+	0x3a85,
+	0x3b92,
+	0x3c86,
+	0x3d20,
+	0x3e87,
+	0x3f00,
+	0x4088,
+	0x4170,
+	0x4289,
+	0x43aa,
+	0x448a,
+	0x4550,
+	0x468b,
+	0x4710,
+	0x488c,
+	0x4904,
+	0x4a8d,
+	0x4b02,
+	0x4ce6,
+	0x4dff,
+	0x4ee7,
+	0x4f18,
+	0x50e8,
+	0x5120,
+	0x52e9,
+	0x5306,
+	0x5403,
+	0x5513,
+	0x5610,
+	0x5733,
+	0x5820,
+	0x5920,
+	0x5a21,
+	0x5b30,
+	0x5c22,
+	0x5d36,
+	0x5e23,
+	0x5f6a,
+	0x6024,
+	0x61a0,
+	0x6225,
+	0x63c0,
+	0x6426,
+	0x65e0,
+	0x6627,
+	0x6702,
+	0x6828,
+	0x6903,
+	0x6a29,
+	0x6b03,
+	0x6c2a,
+	0x6d10,
+	0x6e2b,
+	0x6f10,
+	0x702c,
+	0x7104,
+	0x722d,
+	0x7303,
+	0x742e,
+	0x7503,
+	0x762f,
+	0x7718,
+	0x7830,
+	0x7903,
+	0x7a31,
+	0x7b03,
+	0x7c32,
+	0x7d03,
+	0x7e33,
+	0x7f40,
+	0x8034,
+	0x8180,
+	0x8235,
+	0x8300,
+	0x8436,
+	0x85f0,
+	0x86a0,
+	0x8707,
+	0x88a8,
+	0x8924,
+	0x8aa9,
+	0x8b24,
+	0x8caa,
+	0x8d20,
+	0x8eab,
+	0x8f02,
+	0x90c0,
+	0x9127,
+	0x92c2,
+	0x9308,
+	0x94c3,
+	0x9508,
+	0x96c4,
+	0x9740,
+	0x98c5,
+	0x9938,
+	0x9ac6,
+	0x9bf0,
+	0x9cc7,
+	0x9d10,
+	0x9ec8,
+	0x9f44,
+	0xa0c9,
+	0xa187,
+	0xa2ca,
+	0xa3ff,
+	0xa4cb,
+	0xa520,
+	0xa6cc,
+	0xa761,
+	0xa8cd,
+	0xa987,
+	0xaace,
+	0xab8a,
+	0xaccf,
+	0xada5,
+	0xae03,
+	0xaf14,
+	0xb011,
+	0xb102,
+	0xb211,
+	0xb302,
+	0xb412,
+	0xb540,
+	0xb613,
+	0xb798,
+	0xb814,
+	0xb93a,
+	0xba15,
+	0xbb30,
+	0xbc16,
+	0xbd30,
+	0xbe17,
+	0xbf30,
+	0xc018,
+	0xc158,
+	0xc219,
+	0xc360,
+	0xc41a,
+	0xc560,
+	0xc620,
+	0xc782,
+	0xc821,
+	0xc903,
+	0xca22,
+	0xcb05,
+	0xcc23,
+	0xcd07,
+	0xce24,
+	0xcf0a,
+	0xd025,
+	0xd146,
+	0xd226,
+	0xd332,
+	0xd427,
+	0xd51e,
+	0xd628,
+	0xd710,
+	0xd829,
+	0xd900,
+	0xda2a,
+	0xdb18,
+	0xdc2b,
+	0xdd18,
+	0xde2c,
+	0xdf18,
+	0xe02d,
+	0xe130,
+	0xe22e,
+	0xe330,
+	0xe42f,
+	0xe530,
+	0xe630,
+	0xe782,
+	0xe831,
+	0xe902,
+	0xea32,
+	0xeb04,
+	0xec33,
+	0xed04,
+	0xee34,
+	0xef0a,
+	0xf035,
+	0xf146,
+	0xf236,
+	0xf332,
+	0xf437,
+	0xf528,
+	0xf638,
+	0xf712,
+	0xf839,
+	0xf900,
+	0xfa3a,
+	0xfb20,
+	0xfc3b,
+	0xfd30,
+	0x0e00,
+	0x03df,
+	0x0e01,
+	0x103c,
+	0x1120,
+	0x123d,
+	0x1318,
+	0x143e,
+	0x1528,
+	0x163f,
+	0x1714,
+	0x1840,
+	0x1984,
+	0x1a41,
+	0x1b10,
+	0x1c42,
+	0x1d70,
+	0x1e43,
+	0x1f20,
+	0x2044,
+	0x2118,
+	0x2245,
+	0x2318,
+	0x2446,
+	0x2510,
+	0x2647,
+	0x2718,
+	0x2848,
+	0x290a,
+	0x2a49,
+	0x2b10,
+	0x2c50,
+	0x2d84,
+	0x2e51,
+	0x2f30,
+	0x3052,
+	0x31b0,
+	0x3253,
+	0x3337,
+	0x3454,
+	0x3533,
+	0x3655,
+	0x3733,
+	0x3856,
+	0x3933,
+	0x3a57,
+	0x3b10,
+	0x3c58,
+	0x3d20,
+	0x3e59,
+	0x3f20,
+	0x4060,
+	0x4101,
+	0x4261,
+	0x43a0,
+	0x4462,
+	0x4598,
+	0x4663,
+	0x47e4,
+	0x4864,
+	0x49a4,
+	0x4a65,
+	0x4b7d,
+	0x4c66,
+	0x4d4b,
+	0x4e70,
+	0x4f10,
+	0x5071,
+	0x5110,
+	0x5272,
+	0x5310,
+	0x5473,
+	0x5510,
+	0x5674,
+	0x5710,
+	0x5875,
+	0x5910,
+	0x5a76,
+	0x5b38,
+	0x5c77,
+	0x5d38,
+	0x5e78,
+	0x5f38,
+	0x6079,
+	0x6170,
+	0x627a,
+	0x6370,
+	0x647b,
+	0x6570,
+	0x6603,
+	0x6710,
+	0x6860,
+	0x6903,
+	0x6a70,
+	0x6b0c,
+	0x6c71,
+	0x6d00,
+	0x6e72,
+	0x6f83,
+	0x7073,
+	0x7199,
+	0x7274,
+	0x731b,
+	0x7475,
+	0x750b,
+	0x7676,
+	0x773c,
+	0x7877,
+	0x7943,
+	0x7a78,
+	0x7b33,
+	0x7c79,
+	0x7d4c,
+	0x7e7a,
+	0x7fcc,
+	0x807b,
+	0x8149,
+	0x827c,
+	0x8399,
+	0x847d,
+	0x850e,
+	0x867e,
+	0x871e,
+	0x887f,
+	0x893c,
+	0x8a03,
+	0x8b16,
+	0x8c8a,
+	0x8d68,
+	0x8e8b,
+	0x8f7c,
+	0x908c,
+	0x917f,
+	0x928d,
+	0x937f,
+	0x948e,
+	0x957f,
+	0x968f,
+	0x977f,
+	0x9890,
+	0x997f,
+	0x9a91,
+	0x9b7f,
+	0x9c92,
+	0x9d7f,
+	0x0e00,
+	0x03e0,
+	0x0e01,
+	0x1003,
+	0x1111,
+	0x1210,
+	0x1313,
+	0x1411,
+	0x1508,
+	0x1612,
+	0x171e,
+	0x1813,
+	0x190e,
+	0x1a14,
+	0x1b31,
+	0x1c30,
+	0x1d20,
+	0x1e31,
+	0x1f20,
+	0x2032,
+	0x2152,
+	0x2233,
+	0x233b,
+	0x2434,
+	0x251d,
+	0x2635,
+	0x2721,
+	0x2836,
+	0x291b,
+	0x2a37,
+	0x2b21,
+	0x2c38,
+	0x2d18,
+	0x2e39,
+	0x2f18,
+	0x303a,
+	0x3120,
+	0x323b,
+	0x3328,
+	0x343c,
+	0x3520,
+	0x363d,
+	0x3720,
+	0x383e,
+	0x391e,
+	0x3a3f,
+	0x3b1e,
+	0x3c40,
+	0x3d1e,
+	0x3e41,
+	0x3f10,
+	0x4042,
+	0x4110,
+	0x4243,
+	0x4320,
+	0x4444,
+	0x452a,
+	0x4645,
+	0x4730,
+	0x4846,
+	0x4950,
+	0x4a47,
+	0x4b40,
+	0x4c48,
+	0x4d40,
+	0x4e49,
+	0x4f60,
+	0x504a,
+	0x5180,
+	0x524b,
+	0x53a0,
+	0x544c,
+	0x55a0,
+	0x564d,
+	0x57a0,
+	0x584e,
+	0x5990,
+	0x5a4f,
+	0x5b90,
+	0x5c50,
+	0x5d90,
+	0x5e51,
+	0x5f68,
+	0x6052,
+	0x6168,
+	0x6253,
+	0x6368,
+	0x6454,
+	0x6568,
+	0x6655,
+	0x6768,
+	0x6856,
+	0x6968,
+	0x6a57,
+	0x6b68,
+	0x6c58,
+	0x6d68,
+	0x6e59,
+	0x6f70,
+	0x705a,
+	0x7170,
+	0x725b,
+	0x7370,
+	0x745c,
+	0x7570,
+	0x765d,
+	0x7770,
+	0x785e,
+	0x7970,
+	0x7a5f,
+	0x7b70,
+	0x7c60,
+	0x7d70,
+	0x7e61,
+	0x7fc0,
+	0x8062,
+	0x81f0,
+	0x8263,
+	0x8380,
+	0x8464,
+	0x8540,
+	0x8665,
+	0x8740,
+	0x8866,
+	0x8940,
+	0x8a67,
+	0x8b40,
+	0x8c68,
+	0x8d80,
+	0x8e69,
+	0x8f40,
+	0x906a,
+	0x9140,
+	0x926b,
+	0x9340,
+	0x946c,
+	0x9540,
+	0x966d,
+	0x9780,
+	0x986e,
+	0x9940,
+	0x9a6f,
+	0x9b50,
+	0x9c70,
+	0x9d50,
+	0x9e71,
+	0x9f50,
+	0xa072,
+	0xa16e,
+	0xa273,
+	0xa33a,
+	0xa474,
+	0xa550,
+	0xa675,
+	0xa750,
+	0xa876,
+	0xa950,
+	0xaa77,
+	0xab6e,
+	0xac78,
+	0xad66,
+	0xae79,
+	0xaf40,
+	0xb07a,
+	0xb140,
+	0xb27b,
+	0xb340,
+	0xb47c,
+	0xb55c,
+	0xb67d,
+	0xb730,
+	0xb87e,
+	0xb940,
+	0xba7f,
+	0xbb40,
+	0xbc80,
+	0xbd40,
+	0xbe81,
+	0xbf62,
+	0xc082,
+	0xc126,
+	0xc283,
+	0xc340,
+	0xc484,
+	0xc540,
+	0xc685,
+	0xc740,
+	0xc886,
+	0xc962,
+	0xca87,
+	0xcb26,
+	0xcc88,
+	0xcd30,
+	0xce89,
+	0xcf30,
+	0xd08a,
+	0xd130,
+	0xd290,
+	0xd300,
+	0xd491,
+	0xd54e,
+	0xd692,
+	0xd700,
+	0xd893,
+	0xd916,
+	0xda94,
+	0xdb01,
+	0xdc95,
+	0xdd80,
+	0xde96,
+	0xdf55,
+	0xe097,
+	0xe18d,
+	0xe2b0,
+	0xe360,
+	0xe4b1,
+	0xe5b0,
+	0xe6b2,
+	0xe788,
+	0xe8b3,
+	0xe910,
+	0xeab4,
+	0xeb04,
+	0xec03,
+	0xed12,
+	0xee10,
+	0xef03,
+	0xf011,
+	0xf129,
+	0xf212,
+	0xf304,
+	0xf440,
+	0xf533,
+	0xf641,
+	0xf70a,
+	0xf842,
+	0xf96a,
+	0xfa43,
+	0xfb80,
+	0xfc44,
+	0xfd02,
+	0x0e00,
+	0x03e1,
+	0x0e01,
+	0x1045,
+	0x110a,
+	0x1246,
+	0x1380,
+	0x1460,
+	0x1521,
+	0x1661,
+	0x170e,
+	0x1862,
+	0x1970,
+	0x1a63,
+	0x1b70,
+	0x1c64,
+	0x1d14,
+	0x1e65,
+	0x1f01,
+	0x2068,
+	0x210a,
+	0x2269,
+	0x2304,
+	0x246a,
+	0x250a,
+	0x266b,
+	0x270a,
+	0x286c,
+	0x2924,
+	0x2a6d,
+	0x2b01,
+	0x2c70,
+	0x2d01,
+	0x2e71,
+	0x2f3d,
+	0x3080,
+	0x3180,
+	0x3281,
+	0x3388,
+	0x3482,
+	0x3508,
+	0x3683,
+	0x370c,
+	0x3884,
+	0x3990,
+	0x3a85,
+	0x3b92,
+	0x3c86,
+	0x3d20,
+	0x3e87,
+	0x3f00,
+	0x4088,
+	0x4170,
+	0x4289,
+	0x43aa,
+	0x448a,
+	0x4550,
+	0x468b,
+	0x4710,
+	0x488c,
+	0x4904,
+	0x4a8d,
+	0x4b02,
+	0x4ce6,
+	0x4dff,
+	0x4ee7,
+	0x4f18,
+	0x50e8,
+	0x5120,
+	0x52e9,
+	0x5306,
+	0x5403,
+	0x5513,
+	0x5610,
+	0x5731,
+	0x5820,
+	0x5920,
+	0x5a21,
+	0x5b30,
+	0x5c22,
+	0x5d36,
+	0x5e23,
+	0x5f6a,
+	0x6024,
+	0x61a0,
+	0x6225,
+	0x63c0,
+	0x6426,
+	0x65e0,
+	0x6627,
+	0x6702,
+	0x6828,
+	0x6903,
+	0x6a29,
+	0x6b03,
+	0x6c2a,
+	0x6d02,
+	0x6e2b,
+	0x6f04,
+	0x702c,
+	0x7104,
+	0x722d,
+	0x7303,
+	0x742e,
+	0x7503,
+	0x762f,
+	0x7714,
+	0x7830,
+	0x7903,
+	0x7a31,
+	0x7b03,
+	0x7c32,
+	0x7d03,
+	0x7e33,
+	0x7f40,
+	0x8034,
+	0x8180,
+	0x8235,
+	0x8300,
+	0x8436,
+	0x85f0,
+	0x86a0,
+	0x8707,
+	0x88a8,
+	0x8924,
+	0x8aa9,
+	0x8b24,
+	0x8caa,
+	0x8d20,
+	0x8eab,
+	0x8f02,
+	0x90c0,
+	0x9127,
+	0x92c2,
+	0x9308,
+	0x94c3,
+	0x9508,
+	0x96c4,
+	0x9740,
+	0x98c5,
+	0x9938,
+	0x9ac6,
+	0x9bf0,
+	0x9cc7,
+	0x9d10,
+	0x9ec8,
+	0x9f44,
+	0xa0c9,
+	0xa187,
+	0xa2ca,
+	0xa3ff,
+	0xa4cb,
+	0xa520,
+	0xa6cc,
+	0xa761,
+	0xa8cd,
+	0xa987,
+	0xaace,
+	0xab8a,
+	0xaccf,
+	0xada5,
+	0xae03,
+	0xaf14,
+	0xb011,
+	0xb104,
+	0xb211,
+	0xb304,
+	0xb412,
+	0xb540,
+	0xb613,
+	0xb798,
+	0xb814,
+	0xb93a,
+	0xba15,
+	0xbb30,
+	0xbc16,
+	0xbd30,
+	0xbe17,
+	0xbf30,
+	0xc018,
+	0xc138,
+	0xc219,
+	0xc340,
+	0xc41a,
+	0xc540,
+	0xc620,
+	0xc784,
+	0xc821,
+	0xc903,
+	0xca22,
+	0xcb05,
+	0xcc23,
+	0xcd07,
+	0xce24,
+	0xcf0a,
+	0xd025,
+	0xd146,
+	0xd226,
+	0xd332,
+	0xd427,
+	0xd51e,
+	0xd628,
+	0xd710,
+	0xd829,
+	0xd900,
+	0xda2a,
+	0xdb18,
+	0xdc2b,
+	0xdd18,
+	0xde2c,
+	0xdf18,
+	0xe02d,
+	0xe130,
+	0xe22e,
+	0xe330,
+	0xe42f,
+	0xe530,
+	0xe630,
+	0xe784,
+	0xe831,
+	0xe902,
+	0xea32,
+	0xeb04,
+	0xec33,
+	0xed04,
+	0xee34,
+	0xef0a,
+	0xf035,
+	0xf146,
+	0xf236,
+	0xf332,
+	0xf437,
+	0xf528,
+	0xf638,
+	0xf712,
+	0xf839,
+	0xf900,
+	0xfa3a,
+	0xfb20,
+	0xfc3b,
+	0xfd20,
+	0x0e00,
+	0x03e2,
+	0x0e01,
+	0x103c,
+	0x1120,
+	0x123d,
+	0x1310,
+	0x143e,
+	0x1518,
+	0x163f,
+	0x1714,
+	0x1840,
+	0x1904,
+	0x1a41,
+	0x1b10,
+	0x1c42,
+	0x1d70,
+	0x1e43,
+	0x1f20,
+	0x2044,
+	0x2110,
+	0x2245,
+	0x230c,
+	0x2446,
+	0x2510,
+	0x2647,
+	0x2718,
+	0x2848,
+	0x290a,
+	0x2a49,
+	0x2b10,
+	0x2c50,
+	0x2d85,
+	0x2e51,
+	0x2f30,
+	0x3052,
+	0x31b0,
+	0x3253,
+	0x3337,
+	0x3454,
+	0x3533,
+	0x3655,
+	0x3733,
+	0x3856,
+	0x3933,
+	0x3a57,
+	0x3b10,
+	0x3c58,
+	0x3d14,
+	0x3e59,
+	0x3f10,
+	0x4060,
+	0x4101,
+	0x4261,
+	0x43a0,
+	0x4462,
+	0x4598,
+	0x4663,
+	0x47e4,
+	0x4864,
+	0x49a4,
+	0x4a65,
+	0x4b7d,
+	0x4c66,
+	0x4d4b,
+	0x4e70,
+	0x4f10,
+	0x5071,
+	0x5110,
+	0x5272,
+	0x5310,
+	0x5473,
+	0x5510,
+	0x5674,
+	0x5710,
+	0x5875,
+	0x5910,
+	0x5a76,
+	0x5b38,
+	0x5c77,
+	0x5d38,
+	0x5e78,
+	0x5f38,
+	0x6079,
+	0x6170,
+	0x627a,
+	0x6370,
+	0x647b,
+	0x6570,
+	0x6603,
+	0x6710,
+	0x6860,
+	0x6903,
+	0x6a70,
+	0x6b0c,
+	0x6c71,
+	0x6d05,
+	0x6e72,
+	0x6f5f,
+	0x7073,
+	0x7133,
+	0x7274,
+	0x731b,
+	0x7475,
+	0x7503,
+	0x7676,
+	0x7720,
+	0x7877,
+	0x7933,
+	0x7a78,
+	0x7b33,
+	0x7c79,
+	0x7d46,
+	0x7e7a,
+	0x7f66,
+	0x807b,
+	0x8143,
+	0x827c,
+	0x8333,
+	0x847d,
+	0x850e,
+	0x867e,
+	0x871e,
+	0x887f,
+	0x893c,
+	0x8a03,
+	0x8b16,
+	0x8c8a,
+	0x8d68,
+	0x8e8b,
+	0x8f7c,
+	0x908c,
+	0x917f,
+	0x928d,
+	0x937f,
+	0x948e,
+	0x957f,
+	0x968f,
+	0x977f,
+	0x9890,
+	0x997f,
+	0x9a91,
+	0x9b7f,
+	0x9c92,
+	0x9d7f,
+	0x0e00,
+	0x03e3,
+	0x0e01,
+	0x1003,
+	0x1111,
+	0x1210,
+	0x131f,
+	0x1411,
+	0x152a,
+	0x1612,
+	0x171c,
+	0x1813,
+	0x191c,
+	0x1a14,
+	0x1b3a,
+	0x1c30,
+	0x1d20,
+	0x1e31,
+	0x1f20,
+	0x2032,
+	0x2140,
+	0x2233,
+	0x2328,
+	0x2434,
+	0x251a,
+	0x2635,
+	0x2714,
+	0x2836,
+	0x290c,
+	0x2a37,
+	0x2b0a,
+	0x2c38,
+	0x2d00,
+	0x2e39,
+	0x2f8a,
+	0x303a,
+	0x318a,
+	0x323b,
+	0x338a,
+	0x343c,
+	0x358a,
+	0x363d,
+	0x378a,
+	0x383e,
+	0x398a,
+	0x3a3f,
+	0x3b8a,
+	0x3c40,
+	0x3d8a,
+	0x3e41,
+	0x3f40,
+	0x4042,
+	0x4110,
+	0x4243,
+	0x4310,
+	0x4444,
+	0x4510,
+	0x4645,
+	0x4710,
+	0x4846,
+	0x4910,
+	0x4a47,
+	0x4b10,
+	0x4c48,
+	0x4d10,
+	0x4e49,
+	0x4f40,
+	0x504a,
+	0x5140,
+	0x524b,
+	0x5340,
+	0x544c,
+	0x5540,
+	0x564d,
+	0x5740,
+	0x584e,
+	0x5940,
+	0x5a4f,
+	0x5b40,
+	0x5c50,
+	0x5d40,
+	0x5e51,
+	0x5ff0,
+	0x6052,
+	0x61f0,
+	0x6253,
+	0x63f0,
+	0x6454,
+	0x65f0,
+	0x6655,
+	0x67f0,
+	0x6856,
+	0x69f0,
+	0x6a57,
+	0x6bf0,
+	0x6c58,
+	0x6df0,
+	0x6e59,
+	0x6ff8,
+	0x705a,
+	0x71f8,
+	0x725b,
+	0x73f8,
+	0x745c,
+	0x75f8,
+	0x765d,
+	0x77f8,
+	0x785e,
+	0x79f8,
+	0x7a5f,
+	0x7bf8,
+	0x7c60,
+	0x7df8,
+	0x7e61,
+	0x7fc0,
+	0x8062,
+	0x81f0,
+	0x8263,
+	0x8380,
+	0x8464,
+	0x8540,
+	0x8665,
+	0x8702,
+	0x8866,
+	0x8902,
+	0x8a67,
+	0x8b02,
+	0x8c68,
+	0x8d80,
+	0x8e69,
+	0x8f40,
+	0x906a,
+	0x9101,
+	0x926b,
+	0x9301,
+	0x946c,
+	0x9501,
+	0x966d,
+	0x9780,
+	0x986e,
+	0x9940,
+	0x9a6f,
+	0x9b01,
+	0x9c70,
+	0x9d01,
+	0x9e71,
+	0x9f01,
+	0xa072,
+	0xa16e,
+	0xa273,
+	0xa33a,
+	0xa474,
+	0xa501,
+	0xa675,
+	0xa701,
+	0xa876,
+	0xa901,
+	0xaa77,
+	0xab6e,
+	0xac78,
+	0xad3a,
+	0xae79,
+	0xaf01,
+	0xb07a,
+	0xb101,
+	0xb27b,
+	0xb301,
+	0xb47c,
+	0xb55c,
+	0xb67d,
+	0xb730,
+	0xb87e,
+	0xb901,
+	0xba7f,
+	0xbb01,
+	0xbc80,
+	0xbd01,
+	0xbe81,
+	0xbf62,
+	0xc082,
+	0xc126,
+	0xc283,
+	0xc301,
+	0xc484,
+	0xc501,
+	0xc685,
+	0xc701,
+	0xc886,
+	0xc962,
+	0xca87,
+	0xcb26,
+	0xcc88,
+	0xcd01,
+	0xce89,
+	0xcf01,
+	0xd08a,
+	0xd101,
+	0xd290,
+	0xd300,
+	0xd491,
+	0xd54e,
+	0xd692,
+	0xd700,
+	0xd893,
+	0xd916,
+	0xda94,
+	0xdb01,
+	0xdc95,
+	0xdd80,
+	0xde96,
+	0xdf55,
+	0xe097,
+	0xe18d,
+	0xe2b0,
+	0xe330,
+	0xe4b1,
+	0xe590,
+	0xe6b2,
+	0xe708,
+	0xe8b3,
+	0xe900,
+	0xeab4,
+	0xeb04,
+	0xec03,
+	0xed12,
+	0xee10,
+	0xef03,
+	0xf011,
+	0xf129,
+	0xf212,
+	0xf303,
+	0xf440,
+	0xf502,
+	0xf641,
+	0xf70a,
+	0xf842,
+	0xf96a,
+	0xfa43,
+	0xfb80,
+	0xfc44,
+	0xfd02,
+	0x0e00,
+	0x03e4,
+	0x0e01,
+	0x1045,
+	0x110a,
+	0x1246,
+	0x1380,
+	0x1460,
+	0x1502,
+	0x1661,
+	0x1704,
+	0x1862,
+	0x194b,
+	0x1a63,
+	0x1b41,
+	0x1c64,
+	0x1d14,
+	0x1e65,
+	0x1f00,
+	0x2068,
+	0x210a,
+	0x2269,
+	0x2304,
+	0x246a,
+	0x250a,
+	0x266b,
+	0x270a,
+	0x286c,
+	0x2924,
+	0x2a6d,
+	0x2b01,
+	0x2c70,
+	0x2d18,
+	0x2e71,
+	0x2fbf,
+	0x3080,
+	0x3164,
+	0x3281,
+	0x33b1,
+	0x3482,
+	0x352c,
+	0x3683,
+	0x3702,
+	0x3884,
+	0x3930,
+	0x3a85,
+	0x3b90,
+	0x3c86,
+	0x3d10,
+	0x3e87,
+	0x3f01,
+	0x4088,
+	0x413a,
+	0x4289,
+	0x4390,
+	0x448a,
+	0x450e,
+	0x468b,
+	0x470c,
+	0x488c,
+	0x4905,
+	0x4a8d,
+	0x4b03,
+	0x4ce6,
+	0x4dff,
+	0x4ee7,
+	0x4f18,
+	0x50e8,
+	0x510a,
+	0x52e9,
+	0x5306,
+	0x5403,
+	0x5513,
+	0x5610,
+	0x573f,
+	0x5820,
+	0x5920,
+	0x5a21,
+	0x5b30,
+	0x5c22,
+	0x5d36,
+	0x5e23,
+	0x5f6a,
+	0x6024,
+	0x61a0,
+	0x6225,
+	0x63c0,
+	0x6426,
+	0x65e0,
+	0x6627,
+	0x6700,
+	0x6828,
+	0x6900,
+	0x6a29,
+	0x6b00,
+	0x6c2a,
+	0x6d00,
+	0x6e2b,
+	0x6f00,
+	0x702c,
+	0x7100,
+	0x722d,
+	0x7300,
+	0x742e,
+	0x7500,
+	0x762f,
+	0x7704,
+	0x7830,
+	0x7904,
+	0x7a31,
+	0x7b04,
+	0x7c32,
+	0x7d04,
+	0x7e33,
+	0x7f10,
+	0x8034,
+	0x8110,
+	0x8235,
+	0x8300,
+	0x8436,
+	0x8580,
+	0x86a0,
+	0x8707,
+	0x88a8,
+	0x8930,
+	0x8aa9,
+	0x8b30,
+	0x8caa,
+	0x8d30,
+	0x8eab,
+	0x8f02,
+	0x90c0,
+	0x9127,
+	0x92c2,
+	0x9308,
+	0x94c3,
+	0x9508,
+	0x96c4,
+	0x9746,
+	0x98c5,
+	0x9978,
+	0x9ac6,
+	0x9bf0,
+	0x9cc7,
+	0x9d10,
+	0x9ec8,
+	0x9f44,
+	0xa0c9,
+	0xa187,
+	0xa2ca,
+	0xa3ff,
+	0xa4cb,
+	0xa520,
+	0xa6cc,
+	0xa761,
+	0xa8cd,
+	0xa987,
+	0xaace,
+	0xab8a,
+	0xaccf,
+	0xada5,
+	0xae03,
+	0xaf14,
+	0xb011,
+	0xb103,
+	0xb211,
+	0xb303,
+	0xb412,
+	0xb540,
+	0xb613,
+	0xb788,
+	0xb814,
+	0xb934,
+	0xba15,
+	0xbb00,
+	0xbc16,
+	0xbd00,
+	0xbe17,
+	0xbf00,
+	0xc018,
+	0xc110,
+	0xc219,
+	0xc310,
+	0xc41a,
+	0xc510,
+	0xc620,
+	0xc783,
+	0xc821,
+	0xc903,
+	0xca22,
+	0xcb05,
+	0xcc23,
+	0xcd07,
+	0xce24,
+	0xcf0a,
+	0xd025,
+	0xd146,
+	0xd226,
+	0xd332,
+	0xd427,
+	0xd51e,
+	0xd628,
+	0xd719,
+	0xd829,
+	0xd900,
+	0xda2a,
+	0xdb10,
+	0xdc2b,
+	0xdd10,
+	0xde2c,
+	0xdf10,
+	0xe02d,
+	0xe180,
+	0xe22e,
+	0xe380,
+	0xe42f,
+	0xe580,
+	0xe630,
+	0xe783,
+	0xe831,
+	0xe902,
+	0xea32,
+	0xeb04,
+	0xec33,
+	0xed04,
+	0xee34,
+	0xef0a,
+	0xf035,
+	0xf146,
+	0xf236,
+	0xf332,
+	0xf437,
+	0xf528,
+	0xf638,
+	0xf712,
+	0xf839,
+	0xf900,
+	0xfa3a,
+	0xfb18,
+	0xfc3b,
+	0xfd20,
+	0x0e00,
+	0x03e5,
+	0x0e01,
+	0x103c,
+	0x1118,
+	0x123d,
+	0x1320,
+	0x143e,
+	0x1522,
+	0x163f,
+	0x1710,
+	0x1840,
+	0x1903,
+	0x1a41,
+	0x1b12,
+	0x1c42,
+	0x1db0,
+	0x1e43,
+	0x1f20,
+	0x2044,
+	0x210a,
+	0x2245,
+	0x230a,
+	0x2446,
+	0x250a,
+	0x2647,
+	0x2708,
+	0x2848,
+	0x2908,
+	0x2a49,
+	0x2b08,
+	0x2c50,
+	0x2d03,
+	0x2e51,
+	0x2f32,
+	0x3052,
+	0x3140,
+	0x3253,
+	0x3319,
+	0x3454,
+	0x3560,
+	0x3655,
+	0x3760,
+	0x3856,
+	0x3960,
+	0x3a57,
+	0x3b20,
+	0x3c58,
+	0x3d20,
+	0x3e59,
+	0x3f20,
+	0x4060,
+	0x4103,
+	0x4261,
+	0x43a0,
+	0x4462,
+	0x4598,
+	0x4663,
+	0x47e4,
+	0x4864,
+	0x49a4,
+	0x4a65,
+	0x4b7d,
+	0x4c66,
+	0x4d4b,
+	0x4e70,
+	0x4f10,
+	0x5071,
+	0x5110,
+	0x5272,
+	0x5310,
+	0x5473,
+	0x5510,
+	0x5674,
+	0x5710,
+	0x5875,
+	0x5910,
+	0x5a76,
+	0x5b28,
+	0x5c77,
+	0x5d28,
+	0x5e78,
+	0x5f28,
+	0x6079,
+	0x6128,
+	0x627a,
+	0x6328,
+	0x647b,
+	0x6528,
+	0x6603,
+	0x6710,
+	0x6860,
+	0x6903,
+	0x6a70,
+	0x6b0c,
+	0x6c71,
+	0x6d08,
+	0x6e72,
+	0x6fed,
+	0x7073,
+	0x7100,
+	0x7274,
+	0x7336,
+	0x7475,
+	0x7508,
+	0x7676,
+	0x7713,
+	0x7877,
+	0x7920,
+	0x7a78,
+	0x7b00,
+	0x7c79,
+	0x7d40,
+	0x7e7a,
+	0x7f00,
+	0x807b,
+	0x8139,
+	0x827c,
+	0x8399,
+	0x847d,
+	0x850e,
+	0x867e,
+	0x871e,
+	0x887f,
+	0x893c,
+	0x8a03,
+	0x8b16,
+	0x8c8a,
+	0x8d60,
+	0x8e8b,
+	0x8f68,
+	0x908c,
+	0x916a,
+	0x928d,
+	0x9374,
+	0x948e,
+	0x957a,
+	0x968f,
+	0x977f,
+	0x9890,
+	0x997f,
+	0x9a91,
+	0x9b7f,
+	0x9c92,
+	0x9d7f,
+	0x0e00,
+	0x0300,
+	0x01f1,
+	0x03c0,
+	0x1680,
+	0x03C0,
+	0x3301,
+	0x3201,
+	0x0330,
+	0x1104,
+	0x031f,
+	0x1100,
+	0x1260,
+	0x1314,
+	0x1410,
+	0x1500,
+	0x2018,
+	0x2114,
+	0x228C,
+	0x239C,
+	0x2818,
+	0x2902,
+	0x3B18,
+	0x3C8C,
+	0x1019,
+	0x03c4,
+	0x10e7,
+	0x03c3,
+	0x1084,
+	0x0330,
+	0x7c2c,
+	0x7dce,
+	0x7e2d,
+	0x7fbb,
+	0x8024,
+	0x8170,
+	0x8227,
+	0x8339,
+	0x8421,
+	0x85a6,
+	0x8624,
+	0x876f,
+	0x8827,
+	0x893a,
+	0x8a2a,
+	0x8b03,
+	0x8c2a,
+	0x8d04,
+	0x8e2c,
+	0x8fcd,
+	0x03CD,
+	0x1038,
+	0x03c9,
+	0x2a00,
+	0x2bb2,
+	0x2c00,
+	0x2d79,
+	0x2e00,
+	0x2fb2,
+	0x3000,
+	0x3179,
+	0x03c5,
+	0x1081,
+	0x03cf,
+	0x10af,
+	0x0330,
+	0x3629,
+	0x0300,
+	0xff01,
+	0x0300,
+	0x1041,
+	0x2000,
+	0x2101,
+	0x4200,
+	0x4301,
+	0x0315,
+	0x1081,
+	0x2007,
+	0x21f8,
+	0x2202,
+	0x23fc,
+	0x0319,
+	0x1000,
+	0x1100,
+	0x1206,
+	0x1301,
+	0x2002,
+	0x2180,
+	0x2201,
+	0x23e0,
+	0x2400,
+	0x2503,
+	0x2600,
+	0x2701,
+	0x2802,
+	0x2983,
+	0x2a01,
+	0x2be1,
+	0x2c0c,
+	0x2dcc,
+	0x2e0c,
+	0x2fcc,
+	0x3042,
+	0x1007,
+	0x0348,
+	0x09a6,
+	0x101C,
+	0x1100,
+	0x1450,
+	0x1604,
+	0x1a11,
+	0x1b0d,
+	0x1c01,
+	0x1d0f,
+	0x1e09,
+	0x1f05,
+	0x2000,
+	0x241e,
+	0x3000,
+	0x3105,
+	0x3404,
+	0x3903,
+	0x0300,
+	0x0cf0,
+	0x0330,
+	0x3628,
+	0x0300,
+	0xff01,
+	0x0300,
+	0x01f0,
+	0x03c4,
+	0x10e6,
+	0x03C0,
+	0x3300,
+	0x3201,
+};
+
+static const u16 sr300pc20_camcorder_set[] = {
+	0xff00,
+};
+
+static const u16 sr300pc20_update_preview_setting[] = {
+	0x0300,
+	0x01f1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x1066,
+	0x03c5,
+	0x1000,
+	0x0300,
+	0xff01,
+	0x0330,
+	0x3629,
+	0x0300,
+	0xff01,
+	0x0319,
+	0x1007,
+	0x0300,
+	0x1041,
+	0x1180,
+	0x1380,
+	0x1430,
+	0x1704,
+	0x0302,
+	0x2102,
+	0x0300,
+	0xff01,
+	0x2000,
+	0x2100,
+	0x2200,
+	0x2300,
+	0x5200,
+	0x5321,
+	0x0315,
+	0x1081,
+	0x2007,
+	0x21f8,
+	0x2202,
+	0x23fc,
+	0x0348,
+	0x101C,
+	0x1604,
+	0x3000,
+	0x3105,
+	0x0320,
+	0x2403,
+	0x2537,
+	0x26F9,
+	0x2780,
+	0x03d5,
+	0x4189,
+	0x0330,
+	0x3628,
+	0x0300,
+	0xff01,
+	0x03c4,
+	0x10e7,
+	0x0300,
+	0xff01,
+	0x03c5,
+	0x10b0,
+	0x0314,
+	0x1000,
+	0x0300,
+	0x01f0,
+	0x03cf,
+	0x10af,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_176_144_Preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_320_240_Preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_352_288_Preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_528_432_Preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_640_480_Preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_720_480_Preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_800_600_Preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_1024_768_Preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_1280_1024_Preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_1280_720_Preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_snapshot[] = {
+	0x0300,
+	0x01f1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x1066,
+	0x03c5,
+	0x1000,
+	0x03D5,
+	0x1199,
+	0x03d6,
+	0x1700,
+	0x0319,
+	0x1000,
+	0x0300,
+	0x1000,
+	0x1430,
+	0x1705,
+	0x0302,
+	0x2101,
+	0x0300,
+	0xff01,
+	0x2000,
+	0x2104,
+	0x2200,
+	0x230a,
+	0x0315,
+	0x1083,
+	0x2007,
+	0x21f8,
+	0x2205,
+	0x23f8,
+	0x0348,
+	0x101C,
+	0x1604,
+	0x3000,
+	0x3110,
+	0x0320,
+	0x2800,
+	0x2909,
+	0x2ac4,
+	0x0330,
+	0x3629,
+	0x0300,
+	0xff02,
+	0x0314,
+	0x1027,
+	0x0300,
+	0x01f0,
+};
+static const u16 sr300pc20_snapshot_pvga[] = {
+	0xff00,
+};
+static const u16 sr300pc20_lowlight_snapshot[] = {
+	0xff00,
+};
+static const u16 sr300pc20_lowlight_snapshot_off[] = {
+	0xff00,
+};
+static const u16 sr300pc20_night_snapshot[] = {
+	0x0300,
+	0x01f1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x1066,
+	0x03c5,
+	0x1000,
+	0x03D5,
+	0x1198,
+	0x03d6,
+	0x1701,
+	0x0319,
+	0x1000,
+	0x0300,
+	0x1000,
+	0x1430,
+	0x1705,
+	0x0302,
+	0x2101,
+	0x0300,
+	0xff01,
+	0x2000,
+	0x2104,
+	0x2200,
+	0x230a,
+	0x0315,
+	0x1083,
+	0x2007,
+	0x21f8,
+	0x2205,
+	0x23f8,
+	0x0348,
+	0x101C,
+	0x1604,
+	0x3000,
+	0x3110,
+	0x0320,
+	0x2800,
+	0x2909,
+	0x2ac4,
+	0x0330,
+	0x3629,
+	0x0300,
+	0xff02,
+	0x0314,
+	0x1027,
+	0x0300,
+	0x01f0,
+};
+static const u16 sr300pc20_fireworks_snapshot[] = {
+	0x0300,
+	0x01f1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x1066,
+	0x03c5,
+	0x1000,
+	0x03D5,
+	0x1198,
+	0x03d6,
+	0x1700,
+	0x0319,
+	0x1000,
+	0x0300,
+	0x1000,
+	0x1430,
+	0x1705,
+	0x0302,
+	0x2101,
+	0x0300,
+	0xff01,
+	0x2000,
+	0x2104,
+	0x2200,
+	0x230a,
+	0x0315,
+	0x1083,
+	0x2007,
+	0x21f8,
+	0x2205,
+	0x23f8,
+	0x0348,
+	0x101C,
+	0x1604,
+	0x3000,
+	0x3110,
+	0x0320,
+	0x2800,
+	0x2909,
+	0x2ac4,
+	0x2401,
+	0x259b,
+	0x26fc,
+	0x27c0,
+	0x2001,
+	0x219b,
+	0x22fc,
+	0x23c0,
+	0x0300,
+	0xff02,
+	0x0314,
+	0x1027,
+	0x0300,
+	0x01f0,
+};
+static const u16 sr300pc20_night_snapshot_off[] = {
+	0xff00,
+};
+static const u16 sr300pc20_flash_normal_snapshot[] = {
+	0xff00,
+};
+static const u16 sr300pc20_flash_lowlight_snapshot[] = {
+	0xff00,
+};
+static const u16 sr300pc20_get_light_status[] = {
+	0x0320,
+	0xb100,
+};
+static const u16 sr300pc20_get_iso_reg[] = {
+	0x0320,
+	0x5000,
+};
+static const u16 sr300pc20_get_shutterspeed_reg[] = {
+	0x0320,
+	0xa000,
+	0xa100,
+	0xa200,
+	0xa300,
+};
+static const u16 sr300pc20_fps_auto[] = {
+	0xff00,
+};
+static const u16 sr300pc20_fps_15fix[] = {
+	0x0300,
+	0x0cf1,
+	0xff0a,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x1066,
+	0x03c5,
+	0x1000,
+	0x1213,
+	0x0300,
+	0xff0D,
+	0x0300,
+	0x1190,
+	0x5200,
+	0x5321,
+	0x03c3,
+	0x1080,
+	0x0320,
+	0x2400,
+	0x251b,
+	0x2677,
+	0x2740,
+	0x3c00,
+	0x3d36,
+	0x3eee,
+	0x3f80,
+	0x8030,
+	0x03c4,
+	0x192c,
+	0x1e00,
+	0x1f06,
+	0x20dd,
+	0x21d0,
+	0x1a34,
+	0x2200,
+	0x230d,
+	0x24bb,
+	0x25a0,
+	0x1b3c,
+	0x2600,
+	0x2714,
+	0x2899,
+	0x2970,
+	0x0300,
+	0x13a8,
+	0x1194,
+	0x0311,
+	0xf2ae,
+	0xf3a4,
+	0x03cf,
+	0x10a7,
+	0x03c4,
+	0x10a7,
+	0x0300,
+	0xff02,
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_fps_24fix[] = {
+	0x0300,
+	0x0cf1,
+	0xff0a,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x1066,
+	0x03c5,
+	0x1000,
+	0x1213,
+	0x0300,
+	0xff0D,
+	0x0300,
+	0x1190,
+	0x5200,
+	0x5321,
+	0x03c3,
+	0x1080,
+	0x0320,
+	0x2400,
+	0x251b,
+	0x2677,
+	0x2740,
+	0x3c00,
+	0x3d20,
+	0x3ef5,
+	0x3f80,
+	0x8030,
+	0x03c4,
+	0x192c,
+	0x1e00,
+	0x1f06,
+	0x20dd,
+	0x21d0,
+	0x1a34,
+	0x2200,
+	0x230d,
+	0x24bb,
+	0x25a0,
+	0x1b3c,
+	0x2600,
+	0x2714,
+	0x2899,
+	0x2970,
+	0x0300,
+	0x13a8,
+	0x1194,
+	0x0311,
+	0xf2ae,
+	0xf3a4,
+	0x03cf,
+	0x10a7,
+	0x03c4,
+	0x10a7,
+	0x0300,
+	0xff02,
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_fps_30fix[] = {
+	0x0300,
+	0x0cf1,
+	0xff0a,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x1066,
+	0x03c5,
+	0x1000,
+	0x1213,
+	0x0300,
+	0xff0d,
+	0x0300,
+	0x1190,
+	0x5200,
+	0x5321,
+	0x03c3,
+	0x1080,
+	0x0320,
+	0x2400,
+	0x251b,
+	0x2677,
+	0x2740,
+	0x3c00,
+	0x3d1f,
+	0x3eed,
+	0x3fd4,
+	0x8030,
+	0x03c4,
+	0x192c,
+	0x1e00,
+	0x1f06,
+	0x20dd,
+	0x21d0,
+	0x1a34,
+	0x2200,
+	0x230d,
+	0x24bb,
+	0x25a0,
+	0x1b3c,
+	0x2600,
+	0x2714,
+	0x2899,
+	0x2970,
+	0x0300,
+	0x13a8,
+	0x1194,
+	0x0311,
+	0xf2ae,
+	0xf3a4,
+	0x03cf,
+	0x10a7,
+	0x03c4,
+	0x10a7,
+	0x0300,
+	0xff02,
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_effect_off[] = {
+	0x0310,
+	0x1103,
+	0x12f0,
+	0x4200,
+	0x4300,
+	0x4480,
+	0x4580,
+	0x0314,
+	0x8020,
+};
+static const u16 sr300pc20_effect_mono[] = {
+	0x0310,
+	0x1103,
+	0x12f3,
+	0x4200,
+	0x4300,
+	0x4480,
+	0x4580,
+	0x0314,
+	0x8020,
+};
+static const u16 sr300pc20_effect_sepia[] = {
+	0x0310,
+	0x1103,
+	0x12f3,
+	0x4200,
+	0x4300,
+	0x4460,
+	0x45a3,
+	0x0314,
+	0x8020,
+};
+static const u16 sr300pc20_effect_negative[] = {
+	0x0310,
+	0x1103,
+	0x12f8,
+	0x4200,
+	0x4300,
+	0x4480,
+	0x4580,
+	0x0314,
+	0x8020,
+};
+static const u16 sr300pc20_wb_auto[] = {
+	0x03c5,
+	0x11a4,
+	0x1293,
+	0x03c6,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba6,
+	0x03c5,
+	0x10b1,
+};
+static const u16 sr300pc20_wb_daylight[] = {
+	0x03c5,
+	0x11a0,
+	0x1203,
+	0x03c6,
+	0x1875,
+	0x1976,
+	0x1a6a,
+	0x1b6b,
+	0x03c5,
+	0x10b1,
+};
+static const u16 sr300pc20_wb_cloudy[] = {
+	0x03c5,
+	0x11a0,
+	0x1203,
+	0x03c6,
+	0x1890,
+	0x1992,
+	0x1a5f,
+	0x1b61,
+	0x03c5,
+	0x10b1,
+};
+static const u16 sr300pc20_wb_fluorescent[] = {
+	0x03c5,
+	0x11a0,
+	0x1203,
+	0x03c6,
+	0x185d,
+	0x195e,
+	0x1a94,
+	0x1b95,
+	0x03c5,
+	0x10b1,
+};
+static const u16 sr300pc20_wb_incandescent[] = {
+	0x03c5,
+	0x11a0,
+	0x1203,
+	0x03c6,
+	0x1847,
+	0x1948,
+	0x1aa4,
+	0x1ba5,
+	0x03c5,
+	0x10b1,
+};
+static const u16 sr300pc20_brightness_m_4[] = {
+	0x03d9,
+	0x17d0,
+};
+static const u16 sr300pc20_brightness_m_3[] = {
+	0x03d9,
+	0x17c0,
+};
+static const u16 sr300pc20_brightness_m_2[] = {
+	0x03d9,
+	0x17b0,
+};
+static const u16 sr300pc20_brightness_m_1[] = {
+	0x03d9,
+	0x17a0,
+};
+static const u16 sr300pc20_brightness_0[] = {
+	0x03d9,
+	0x1700,
+};
+static const u16 sr300pc20_brightness_p_1[] = {
+	0x03d9,
+	0x1714,
+};
+static const u16 sr300pc20_brightness_p_2[] = {
+	0x03d9,
+	0x1728,
+};
+static const u16 sr300pc20_brightness_p_3[] = {
+	0x03d9,
+	0x173c,
+};
+static const u16 sr300pc20_brightness_p_4[] = {
+	0x03d9,
+	0x1750,
+};
+static const u16 sr300pc20_scene_off[] = {
+	0x0300,
+	0x0cf1,
+	0xff19,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x1066,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf040,
+	0x0310,
+	0x410a,
+	0x0320,
+	0x126d,
+	0x2400,
+	0x2566,
+	0x26ff,
+	0x2730,
+	0x51f0,
+	0x5224,
+	0x03c4,
+	0x193c,
+	0x1a46,
+	0x1b5c,
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2744,
+	0x28aa,
+	0x2920,
+	0x0300,
+	0x92a0,
+	0x9390,
+	0xa387,
+	0xa787,
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+	0x03c5,
+	0x11a4,
+	0x1293,
+	0x03c6,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba6,
+	0x03d1,
+	0x2b88,
+	0x2c88,
+	0x2d88,
+	0x2e88,
+	0x2f88,
+	0x308c,
+	0x3198,
+	0x3298,
+	0x3398,
+	0x3498,
+	0x3598,
+	0x3698,
+	0x3780,
+	0x3880,
+	0x3980,
+	0x3a78,
+	0x3b88,
+	0x3c84,
+	0x3d8c,
+	0x3e8c,
+	0x3f8c,
+	0x408c,
+	0x418c,
+	0x428c,
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+	0x03cf,
+	0x10af,
+	0x03c3,
+	0xE125,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10f7,
+	0x0300,
+	0xff02,
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_portrait[] = {
+	0xff00,
+};
+static const u16 sr300pc20_scene_landscape[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x1066,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf040,
+	0x0320,
+	0x8030,
+	0x126D,
+	0x2400,
+	0x2566,
+	0x26ff,
+	0x2730,
+	0x51f0,
+	0x5224,
+	0x03c4,
+	0x193c,
+	0x1a46,
+	0x1b5c,
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2744,
+	0x28aa,
+	0x2920,
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8311,
+	0x8411,
+	0x8511,
+	0x8611,
+	0x8711,
+	0x8811,
+	0x8911,
+	0x8A11,
+	0x8B11,
+	0x8C11,
+	0x8D11,
+	0x8E11,
+	0x8F11,
+	0x9011,
+	0x9111,
+	0x9211,
+	0x9311,
+	0x9411,
+	0x9511,
+	0x9611,
+	0x9711,
+	0x9811,
+	0x9911,
+	0x9A11,
+	0x9B11,
+	0x9C11,
+	0x9D11,
+	0x9E11,
+	0x9F11,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+	0x03c5,
+	0x11a4,
+	0x1213,
+	0x03c6,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba6,
+	0x03d1,
+	0x2ba8,
+	0x2ca8,
+	0x2da8,
+	0x2ea8,
+	0x2fa8,
+	0x30ac,
+	0x31b8,
+	0x32b8,
+	0x33b8,
+	0x34b8,
+	0x35b8,
+	0x36b8,
+	0x37a0,
+	0x38a0,
+	0x39a0,
+	0x3a98,
+	0x3ba8,
+	0x3ca4,
+	0x3dac,
+	0x3eac,
+	0x3fac,
+	0x40ac,
+	0x41ac,
+	0x42ac,
+	0x03db,
+	0xbb50,
+	0xbd50,
+	0xbf50,
+	0xc184,
+	0xc384,
+	0xc570,
+	0x03de,
+	0xbb50,
+	0xbd50,
+	0xbf50,
+	0xc188,
+	0xc390,
+	0xc590,
+	0x03e1,
+	0xbb50,
+	0xbd50,
+	0xbf50,
+	0xc168,
+	0xc370,
+	0xc570,
+	0x03e4,
+	0xbb20,
+	0xbd20,
+	0xbf20,
+	0xc140,
+	0xc340,
+	0xc540,
+	0x03cf,
+	0x10a7,
+	0x03c3,
+	0xE125,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10f7,
+	0x0300,
+	0xff02,
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff19,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_sports[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x1066,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf04b,
+	0x0310,
+	0x4100,
+	0x0320,
+	0x8030,
+	0x126d,
+	0x2400,
+	0x2566,
+	0x26ff,
+	0x2730,
+	0x51f0,
+	0x5248,
+	0x03c4,
+	0x1948,
+	0x1a50,
+	0x1b5c,
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2744,
+	0x28aa,
+	0x2920,
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+	0x03c5,
+	0x11a4,
+	0x1213,
+	0x03c6,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba6,
+	0x03d1,
+	0x2b88,
+	0x2c88,
+	0x2d88,
+	0x2e88,
+	0x2f88,
+	0x308c,
+	0x3198,
+	0x3298,
+	0x3398,
+	0x3498,
+	0x3598,
+	0x3698,
+	0x3780,
+	0x3880,
+	0x3980,
+	0x3a78,
+	0x3b88,
+	0x3c84,
+	0x3d8c,
+	0x3e8c,
+	0x3f8c,
+	0x408c,
+	0x418c,
+	0x428c,
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+	0x03cf,
+	0x10a7,
+	0x03c3,
+	0xE149,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10f7,
+	0x0300,
+	0xff02,
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff1a,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_party[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x1066,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf040,
+	0x0310,
+	0x4100,
+	0x0320,
+	0x8030,
+	0x126d,
+	0x2400,
+	0x2566,
+	0x26ff,
+	0x2730,
+	0x518b,
+	0x525c,
+	0x03c4,
+	0x195c,
+	0x1a5c,
+	0x1b5c,
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2744,
+	0x28aa,
+	0x2920,
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+	0x03c5,
+	0x11a4,
+	0x1213,
+	0x03c6,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba6,
+	0x03d1,
+	0x2ba8,
+	0x2ca8,
+	0x2da8,
+	0x2ea8,
+	0x2fa8,
+	0x30ac,
+	0x31b8,
+	0x32b8,
+	0x33b8,
+	0x34b8,
+	0x35b8,
+	0x36b8,
+	0x37a0,
+	0x38a0,
+	0x39a0,
+	0x3a98,
+	0x3ba8,
+	0x3ca4,
+	0x3dac,
+	0x3eac,
+	0x3fac,
+	0x40ac,
+	0x41ac,
+	0x42ac,
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+	0x03cf,
+	0x10a7,
+	0x03c3,
+	0xE15d,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10f7,
+	0x0300,
+	0xff02,
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff1a,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_beach[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x1066,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1710,
+	0x0311,
+	0xf04b,
+	0x0310,
+	0x4100,
+	0x0320,
+	0x8030,
+	0x1269,
+	0x8030,
+	0x2400,
+	0x2566,
+	0x26ff,
+	0x2730,
+	0x5170,
+	0x5224,
+	0x03c4,
+	0x193c,
+	0x1a46,
+	0x1b5c,
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2744,
+	0x28aa,
+	0x2920,
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+	0x03c5,
+	0x11a4,
+	0x1213,
+	0x03c6,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba6,
+	0x03d1,
+	0x2ba8,
+	0x2ca8,
+	0x2da8,
+	0x2ea8,
+	0x2fa8,
+	0x30ac,
+	0x31b8,
+	0x32b8,
+	0x33b8,
+	0x34b8,
+	0x35b8,
+	0x36b8,
+	0x37a0,
+	0x38a0,
+	0x39a0,
+	0x3a98,
+	0x3ba8,
+	0x3ca4,
+	0x3dac,
+	0x3eac,
+	0x3fac,
+	0x40ac,
+	0x41ac,
+	0x42ac,
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+	0x03cf,
+	0x10a7,
+	0x03c3,
+	0xE125,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10f7,
+	0x0300,
+	0xff02,
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff1a,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_sunset[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x1066,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf040,
+	0x0320,
+	0x8030,
+	0x126d,
+	0x2400,
+	0x2566,
+	0x26ff,
+	0x2730,
+	0x51f0,
+	0x5224,
+	0x03c4,
+	0x193c,
+	0x1a46,
+	0x1b5c,
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2744,
+	0x28aa,
+	0x2920,
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+	0x03c5,
+	0x11a0,
+	0x1203,
+	0x03c6,
+	0x1875,
+	0x1976,
+	0x1a6a,
+	0x1b6b,
+	0x03d1,
+	0x2b88,
+	0x2c88,
+	0x2d88,
+	0x2e88,
+	0x2f88,
+	0x308c,
+	0x3198,
+	0x3298,
+	0x3398,
+	0x3498,
+	0x3598,
+	0x3698,
+	0x3780,
+	0x3880,
+	0x3980,
+	0x3a78,
+	0x3b88,
+	0x3c84,
+	0x3d8c,
+	0x3e8c,
+	0x3f8c,
+	0x408c,
+	0x418c,
+	0x428c,
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+	0x03cf,
+	0x10a7,
+	0x03c3,
+	0xE125,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10f7,
+	0x0300,
+	0xff02,
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff19,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_dawn[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x1066,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf040,
+	0x0320,
+	0x8030,
+	0x126d,
+	0x2400,
+	0x2566,
+	0x26ff,
+	0x2730,
+	0x51f0,
+	0x5224,
+	0x03c4,
+	0x193c,
+	0x1a46,
+	0x1b5c,
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2744,
+	0x28aa,
+	0x2920,
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+	0x03c5,
+	0x11a0,
+	0x1203,
+	0x03c6,
+	0x185d,
+	0x195e,
+	0x1a94,
+	0x1b95,
+	0x03d1,
+	0x2b88,
+	0x2c88,
+	0x2d88,
+	0x2e88,
+	0x2f88,
+	0x308c,
+	0x3198,
+	0x3298,
+	0x3398,
+	0x3498,
+	0x3598,
+	0x3698,
+	0x3780,
+	0x3880,
+	0x3980,
+	0x3a78,
+	0x3b88,
+	0x3c84,
+	0x3d8c,
+	0x3e8c,
+	0x3f8c,
+	0x408c,
+	0x418c,
+	0x428c,
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+	0x03cf,
+	0x10a7,
+	0x03c3,
+	0xE125,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10f7,
+	0x0300,
+	0xff02,
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff19,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_fall[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x1066,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf040,
+	0x0320,
+	0x8030,
+	0x126d,
+	0x2400,
+	0x2566,
+	0x26ff,
+	0x2730,
+	0x51f0,
+	0x5224,
+	0x03c4,
+	0x193c,
+	0x1a46,
+	0x1b5c,
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2744,
+	0x28aa,
+	0x2920,
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+	0x03c5,
+	0x11a4,
+	0x1213,
+	0x03c6,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba6,
+	0x03d1,
+	0x2bc8,
+	0x2cc8,
+	0x2dc8,
+	0x2ec8,
+	0x2fc8,
+	0x30cc,
+	0x31d8,
+	0x32d8,
+	0x33d8,
+	0x34d8,
+	0x35d8,
+	0x36d8,
+	0x37c0,
+	0x38c0,
+	0x39c0,
+	0x3ab8,
+	0x3bc8,
+	0x3cc4,
+	0x3dcc,
+	0x3ecc,
+	0x3fcc,
+	0x40cc,
+	0x41cc,
+	0x42cc,
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+	0x03cf,
+	0x10a7,
+	0x03c3,
+	0xE125,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10f7,
+	0x0300,
+	0xff02,
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff19,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_nightshot[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x1066,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf040,
+	0x0320,
+	0x8030,
+	0x126d,
+	0x2400,
+	0x25cd,
+	0x26fe,
+	0x2760,
+	0x51ff,
+	0x5224,
+	0x03c4,
+	0x193c,
+	0x1a46,
+	0x1b5c,
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2744,
+	0x28aa,
+	0x2920,
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+	0x03c5,
+	0x11a4,
+	0x1213,
+	0x03c6,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba6,
+	0x03d1,
+	0x2b88,
+	0x2c88,
+	0x2d88,
+	0x2e88,
+	0x2f88,
+	0x308c,
+	0x3198,
+	0x3298,
+	0x3398,
+	0x3498,
+	0x3598,
+	0x3698,
+	0x3780,
+	0x3880,
+	0x3980,
+	0x3a78,
+	0x3b88,
+	0x3c84,
+	0x3d8c,
+	0x3e8c,
+	0x3f8c,
+	0x408c,
+	0x418c,
+	0x428c,
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+	0x03cf,
+	0x10a7,
+	0x03c3,
+	0xE125,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10f7,
+	0x0300,
+	0xff02,
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff19,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_backlight[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x1066,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf040,
+	0x0320,
+	0x8030,
+	0x126d,
+	0x2400,
+	0x2566,
+	0x26ff,
+	0x2730,
+	0x51f0,
+	0x5224,
+	0x03c4,
+	0x193c,
+	0x1a46,
+	0x1b5c,
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2744,
+	0x28aa,
+	0x2920,
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C00,
+	0x7D10,
+	0x7E11,
+	0x7F11,
+	0x8001,
+	0x8100,
+	0x8200,
+	0x8310,
+	0x84ff,
+	0x85ff,
+	0x8601,
+	0x8700,
+	0x8800,
+	0x8910,
+	0x8Aff,
+	0x8Bff,
+	0x8C01,
+	0x8D00,
+	0x8E00,
+	0x8F10,
+	0x90ff,
+	0x91ff,
+	0x9201,
+	0x9300,
+	0x9400,
+	0x9510,
+	0x9611,
+	0x9711,
+	0x9801,
+	0x9900,
+	0x9A00,
+	0x9B00,
+	0x9C00,
+	0x9D00,
+	0x9E00,
+	0x9F00,
+	0xA000,
+	0xA100,
+	0xA200,
+	0xA300,
+	0xA400,
+	0xA500,
+	0x03c5,
+	0x11a4,
+	0x1213,
+	0x03c6,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba6,
+	0x03d1,
+	0x2b88,
+	0x2c88,
+	0x2d88,
+	0x2e88,
+	0x2f88,
+	0x308c,
+	0x3198,
+	0x3298,
+	0x3398,
+	0x3498,
+	0x3598,
+	0x3698,
+	0x3780,
+	0x3880,
+	0x3980,
+	0x3a78,
+	0x3b88,
+	0x3c84,
+	0x3d8c,
+	0x3e8c,
+	0x3f8c,
+	0x408c,
+	0x418c,
+	0x428c,
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+	0x03cf,
+	0x10a7,
+	0x03c3,
+	0xE125,
+	0x03c4,
+	0x10f7,
+	0x0300,
+	0xff02,
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff1a,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_firework[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x1066,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf04b,
+	0x0320,
+	0x8030,
+	0x1269,
+	0x2400,
+	0x25cd,
+	0x26fe,
+	0x2760,
+	0x5148,
+	0x5224,
+	0x03c4,
+	0x193c,
+	0x1a40,
+	0x1b46,
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2744,
+	0x28aa,
+	0x2920,
+	0x0300,
+	0x9247,
+	0x9340,
+	0xa385,
+	0xa785,
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+	0x03c5,
+	0x11a4,
+	0x1213,
+	0x03c6,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba6,
+	0x03d1,
+	0x2b88,
+	0x2c88,
+	0x2d88,
+	0x2e88,
+	0x2f88,
+	0x308c,
+	0x3198,
+	0x3298,
+	0x3398,
+	0x3498,
+	0x3598,
+	0x3698,
+	0x3780,
+	0x3880,
+	0x3980,
+	0x3a78,
+	0x3b88,
+	0x3c84,
+	0x3d8c,
+	0x3e8c,
+	0x3f8c,
+	0x408c,
+	0x418c,
+	0x428c,
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+	0x03cf,
+	0x10a7,
+	0x03c3,
+	0xE125,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10f7,
+	0x0300,
+	0xff02,
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff19,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_text[] = {
+	0xff00,
+};
+static const u16 sr300pc20_scene_candle[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x1066,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf040,
+	0x0320,
+	0x8030,
+	0x126d,
+	0x2400,
+	0x2566,
+	0x26ff,
+	0x2730,
+	0x51f0,
+	0x5224,
+	0x03c4,
+	0x193c,
+	0x1a46,
+	0x1b5c,
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2744,
+	0x28aa,
+	0x2920,
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+	0x03c5,
+	0x11a0,
+	0x1203,
+	0x03c6,
+	0x1875,
+	0x1976,
+	0x1a6a,
+	0x1b6b,
+	0x03d1,
+	0x2b88,
+	0x2c88,
+	0x2d88,
+	0x2e88,
+	0x2f88,
+	0x308c,
+	0x3198,
+	0x3298,
+	0x3398,
+	0x3498,
+	0x3598,
+	0x3698,
+	0x3780,
+	0x3880,
+	0x3980,
+	0x3a78,
+	0x3b88,
+	0x3c84,
+	0x3d8c,
+	0x3e8c,
+	0x3f8c,
+	0x408c,
+	0x418c,
+	0x428c,
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+	0x03cf,
+	0x10a7,
+	0x03c3,
+	0xE125,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10f7,
+	0x0300,
+	0xff02,
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff19,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_metering_normal[] = {
+	0x03c3,
+	0x7011,
+	0x7111,
+	0x7211,
+	0x7311,
+	0x7411,
+	0x7511,
+	0x7611,
+	0x7711,
+	0x7811,
+	0x7911,
+	0x7A11,
+	0x7B11,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8311,
+	0x8411,
+	0x8511,
+	0x8611,
+	0x8711,
+	0x8811,
+	0x8911,
+	0x8A11,
+	0x8B11,
+	0x8C11,
+	0x8D11,
+	0x8E11,
+	0x8F11,
+	0x9011,
+	0x9111,
+	0x9211,
+	0x9311,
+	0x9411,
+	0x9511,
+	0x9611,
+	0x9711,
+	0x9811,
+	0x9911,
+	0x9A11,
+	0x9B11,
+	0x9C11,
+	0x9D11,
+	0x9E11,
+	0x9F11,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+};
+static const u16 sr300pc20_metering_spot[] = {
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C00,
+	0x7D10,
+	0x7E11,
+	0x7F11,
+	0x8001,
+	0x8100,
+	0x8200,
+	0x8310,
+	0x84ff,
+	0x85ff,
+	0x8601,
+	0x8700,
+	0x8800,
+	0x8910,
+	0x8Aff,
+	0x8Bff,
+	0x8C01,
+	0x8D00,
+	0x8E00,
+	0x8F10,
+	0x90ff,
+	0x91ff,
+	0x9201,
+	0x9300,
+	0x9400,
+	0x9510,
+	0x9611,
+	0x9711,
+	0x9801,
+	0x9900,
+	0x9A00,
+	0x9B00,
+	0x9C00,
+	0x9D00,
+	0x9E00,
+	0x9F00,
+	0xA000,
+	0xA100,
+	0xA200,
+	0xA300,
+	0xA400,
+	0xA500,
+};
+static const u16 sr300pc20_metering_center[] = {
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+};
+static const u16 sr300pc20_iso_auto[] = {
+	0xff00,
+};
+static const u16 sr300pc20_iso_50[] = {
+	0xff00,
+};
+static const u16 sr300pc20_iso_100[] = {
+	0xff00,
+};
+static const u16 sr300pc20_iso_200[] = {
+	0xff00,
+};
+static const u16 sr300pc20_iso_400[] = {
+	0xff00,
+};
+static const u16 sr300pc20_ae_lock[] = {
+	0xff00,
+};
+static const u16 sr300pc20_awb_lock[] = {
+	0xff00,
+};
+static const u16 sr300pc20_ae_unlock[] = {
+	0xff00,
+};
+static const u16 sr300pc20_awb_unlock[] = {
+	0xff00,
+};
+static const u16 sr300pc20_af_abort[] = {
+	0xff00,
+};
+static const u16 sr300pc20_af_off[] = {
+	0xff00,
+};
+static const u16 sr300pc20_af_normal_on[] = {
+	0xff00,
+};
+static const u16 sr300pc20_af_macro_on[] = {
+	0xff00,
+};
+static const u16 sr300pc20_af_do[] = {
+	0xff00,
+};
+static const u16 sr300pc20_1st_720P_af_do[] = {
+	0xff00,
+};
+static const u16 sr300pc20_contrast_m_2[] = {
+	0xff00,
+};
+static const u16 sr300pc20_contrast_m_1[] = {
+	0xff00,
+};
+static const u16 sr300pc20_contrast_0[] = {
+	0xff00,
+};
+static const u16 sr300pc20_contrast_p_1[] = {
+	0xff00,
+};
+static const u16 sr300pc20_contrast_p_2[] = {
+	0xff00,
+};
+static const u16 sr300pc20_saturation_m_2[] = {
+	0xff00,
+};
+static const u16 sr300pc20_saturation_m_1[] = {
+	0xff00,
+};
+static const u16 sr300pc20_saturation_0[] = {
+	0xff00,
+};
+static const u16 sr300pc20_saturation_p_1[] = {
+	0xff00,
+};
+static const u16 sr300pc20_saturation_p_2[] = {
+	0xff00,
+};
+static const u16 sr300pc20_sharpness_m_2[] = {
+	0xff00,
+};
+static const u16 sr300pc20_sharpness_m_1[] = {
+	0xff00,
+};
+static const u16 sr300pc20_sharpness_0[] = {
+	0xff00,
+};
+static const u16 sr300pc20_sharpness_p_1[] = {
+	0xff00,
+};
+static const u16 sr300pc20_sharpness_p_2[] = {
+	0xff00,
+};
+static const u16 sr300pc20_dtp_on[] = {
+	0x0300,
+	0x6005,
+};
+static const u16 sr300pc20_dtp_off[] = {
+	0x0300,
+	0x6000,
+};
+static const u16 sr300pc20_pll_on[] = {
+	0xff00,
+};
+static const u16 sr300pc20_pll_off[] = {
+	0xff00,
+};
+static const u16 sr300pc20_preflash_start[] = {
+	0xff00,
+};
+static const u16 sr300pc20_preflash_end[] = {
+	0xff00,
+};
+static const u16 sr300pc20_mainflash_start[] = {
+	0xff00,
+};
+static const u16 sr300pc20_mainflash_end[] = {
+	0xff00,
+};
+static const u16 sr300pc20_flash_ae_set[] = {
+	0xff00,
+};
+static const u16 sr300pc20_flash_ae_clear[] = {
+	0xff00,
+};
+static const u16 sr300pc20_get_ae_stable_reg[] = {
+	0xff00,
+};
+static const u16 sr300pc20_DTP_init0[] = {
+	0x0300,
+	0x6005,
+};
+#endif
diff --git a/drivers/media/video/msm/sr300pc20_jena.h b/drivers/media/video/msm/sr300pc20_jena.h
new file mode 100644
index 0000000..d7c2417
--- /dev/null
+++ b/drivers/media/video/msm/sr300pc20_jena.h
@@ -0,0 +1,9463 @@
+#ifndef _SAMSUNG_sr300pc20_H_
+#define _SAMSUNG_sr300pc20_H_
+
+static const u16 sr300pc20_init_60hz[] = {
+	0xff00,
+};
+
+static const u16 sr300pc20_pre_init0[] = {
+	0xff00,
+};
+
+static const u16 sr300pc20_init0[] = {
+	0x0300,
+	0x01f1,
+	0x01f1,
+	0x01f3,
+	0x01f1,
+	0x027f,
+	0x0300,
+	0x0725,
+	0x086c,
+	0x0982,
+	0x07a5,
+	0x07a5,
+	0x09a2,
+	0x0A01,
+	0x0A00,
+	0x0A01,
+	0x0A00,
+	0x0320,
+	0x3a00,
+	0x3b00,
+	0x3c00,
+	0x0330,
+	0x3086,
+	0x3100,
+	0x320c,
+	0xe000,
+	0x1080,
+	0x108a,
+	0x1108,
+	0x1100,
+	0x0307,
+	0x1201,
+	0x4035,
+	0x470B,
+	0x2E00,
+	0x2F20,
+	0x3000,
+	0x31D6,
+	0x3200,
+	0x33FF,
+	0x1002,
+	0x8C08,
+	0x8F20,
+	0x9200,
+	0x9354,
+	0x9400,
+	0x9511,
+	0x0300,
+	0xff05,
+	0x0307,
+	0x2E03,
+	0x2F20,
+	0x3020,
+	0x31A6,
+	0x3201,
+	0x3300,
+	0x1002,
+	0x0300,
+	0xff05,
+	0x0307,
+	0x1200,
+	0x9800,
+	0x9701,
+	0x0330,
+	0x100a,
+	0x0300,
+	0x0B02,
+	0x1000,
+	0x1180,
+	0x1380,
+	0x1430,
+	0x1503,
+	0x1704,
+	0x2000,
+	0x2104,
+	0x2200,
+	0x230a,
+	0x2406,
+	0x2500,
+	0x2608,
+	0x2700,
+	0x5001,
+	0x5140,
+	0x5200,
+	0x5321,
+	0x8002,
+	0x8187,
+	0x8228,
+	0x8308,
+	0x848c,
+	0x850c,
+	0x8600,
+	0x8700,
+	0x8898,
+	0x8910,
+	0x8a80,
+	0x8b00,
+	0x8e80,
+	0x8f0f,
+	0x900f,
+	0x910f,
+	0x92a0,
+	0x9390,
+	0x96fe,
+	0x97E0,
+	0x9820,
+	0xa182,
+	0xa283,
+	0xa387,
+	0xa582,
+	0xa683,
+	0xa787,
+	0xbb20,
+	0x0302,
+	0x1a00,
+	0x2033,
+	0x2101,
+	0x2222,
+	0x2330,
+	0x2433,
+	0x2777,
+	0x31f0,
+	0x3222,
+	0x3302,
+	0x3430,
+	0x3500,
+	0x3608,
+	0x3720,
+	0x4001,
+	0x418a,
+	0x4200,
+	0x483C,
+	0x4910,
+	0x54c0,
+	0x5540,
+	0x5b00,
+	0x7802,
+	0x7936,
+	0x7a02,
+	0x7b3a,
+	0xa001,
+	0xa1c4,
+	0xa202,
+	0xa3de,
+	0xa403,
+	0xa53b,
+	0xa608,
+	0xa7ee,
+	0xa800,
+	0xa9cd,
+	0xaa01,
+	0xabba,
+	0xac02,
+	0xad8a,
+	0xae05,
+	0xaF96,
+	0xb000,
+	0xb176,
+	0xb200,
+	0xb3e6,
+	0xb400,
+	0xb52d,
+	0xb601,
+	0xb7b8,
+	0xb800,
+	0xb967,
+	0xba00,
+	0xbbe7,
+	0xbc00,
+	0xbd03,
+	0xbe03,
+	0xbF01,
+	0xc000,
+	0xc176,
+	0xc200,
+	0xc3e8,
+	0xc400,
+	0xc52d,
+	0xc601,
+	0xc7ba,
+	0xc800,
+	0xc967,
+	0xca00,
+	0xcbeb,
+	0xcc00,
+	0xcd03,
+	0xce03,
+	0xcf05,
+	0xd40f,
+	0xd50f,
+	0xd6a8,
+	0xd7a0,
+	0xEF65,
+	0xF00c,
+	0xF40a,
+	0x0303,
+	0x1000,
+	0x11dc,
+	0x1200,
+	0x1382,
+	0x1402,
+	0x15d3,
+	0x1602,
+	0x17db,
+	0x1801,
+	0x1919,
+	0x1a02,
+	0x1b3c,
+	0x1c01,
+	0x1d19,
+	0x1e02,
+	0x1F3c,
+	0x2001,
+	0x2119,
+	0x2201,
+	0x234a,
+	0x2401,
+	0x2519,
+	0x2601,
+	0x274a,
+	0x2801,
+	0x2919,
+	0x2a01,
+	0x2b4b,
+	0x2c01,
+	0x2d19,
+	0x2e01,
+	0x2F4b,
+	0x3000,
+	0x3101,
+	0x3205,
+	0x33b1,
+	0x3400,
+	0x3501,
+	0x3605,
+	0x37b1,
+	0x3800,
+	0x3901,
+	0x3a03,
+	0x3b1d,
+	0x3c00,
+	0x3d01,
+	0x3e03,
+	0x3F05,
+	0x4000,
+	0x4104,
+	0x4200,
+	0x4344,
+	0x4400,
+	0x4502,
+	0x4600,
+	0x4773,
+	0x4800,
+	0x4906,
+	0x4a00,
+	0x4b42,
+	0x4c00,
+	0x4d06,
+	0x4e00,
+	0x4F42,
+	0x5000,
+	0x5108,
+	0x5200,
+	0x532d,
+	0x5400,
+	0x5508,
+	0x5600,
+	0x572d,
+	0x5800,
+	0x5908,
+	0x5a00,
+	0x5b2d,
+	0x5c00,
+	0x5d06,
+	0x5e00,
+	0x5F44,
+	0x6800,
+	0x6904,
+	0x6a00,
+	0x6b46,
+	0x7000,
+	0x71e8,
+	0x7202,
+	0x7338,
+	0x7400,
+	0x75ed,
+	0x7601,
+	0x7715,
+	0x7802,
+	0x7936,
+	0x7a02,
+	0x7b3a,
+	0x7c02,
+	0x7d36,
+	0x7e02,
+	0x7F3a,
+	0x8001,
+	0x81cc,
+	0x8202,
+	0x8312,
+	0x8402,
+	0x8536,
+	0x8602,
+	0x873a,
+	0x8802,
+	0x8936,
+	0x8a02,
+	0x8b3a,
+	0x8c00,
+	0x8dea,
+	0x8e01,
+	0x8F18,
+	0x9000,
+	0x91e8,
+	0x9202,
+	0x9332,
+	0x9400,
+	0x95e8,
+	0x9602,
+	0x9732,
+	0x9802,
+	0x9932,
+	0x9a00,
+	0x9be8,
+	0x9c02,
+	0x9d32,
+	0x9e00,
+	0x9Fe8,
+	0xa000,
+	0xa10a,
+	0xa200,
+	0xa306,
+	0xa400,
+	0xa50a,
+	0xa600,
+	0xa706,
+	0xa800,
+	0xa9F5,
+	0xaa00,
+	0xabe6,
+	0xac00,
+	0xadF5,
+	0xae00,
+	0xaFe6,
+	0xc000,
+	0xc148,
+	0xc200,
+	0xc36E,
+	0xc400,
+	0xc548,
+	0xc600,
+	0xc76E,
+	0xc800,
+	0xc94a,
+	0xca00,
+	0xcb6c,
+	0xcc00,
+	0xcd4a,
+	0xce00,
+	0xcF6c,
+	0xd000,
+	0xd14c,
+	0xd200,
+	0xd36a,
+	0xd400,
+	0xd54c,
+	0xd600,
+	0xd76a,
+	0xd800,
+	0xd94e,
+	0xda00,
+	0xdb68,
+	0xdc00,
+	0xdd4e,
+	0xde00,
+	0xdF68,
+	0xe000,
+	0xe1ed,
+	0xe201,
+	0xe354,
+	0xe401,
+	0xe568,
+	0xe602,
+	0xe759,
+	0xe801,
+	0xe917,
+	0xea01,
+	0xebc8,
+	0xec00,
+	0xeddd,
+	0xee00,
+	0xef00,
+	0xf000,
+	0xf134,
+	0x0310,
+	0x1001,
+	0x1230,
+	0x130a,
+	0x2080,
+	0x410a,
+	0x50a0,
+	0x6003,
+	0x700c,
+	0x7100,
+	0x727a,
+	0x7328,
+	0x7414,
+	0x750d,
+	0x7640,
+	0x7749,
+	0x7899,
+	0x794c,
+	0x7acc,
+	0x7b49,
+	0x7c99,
+	0x7d14,
+	0x7e28,
+	0x7f50,
+	0xe0ff,
+	0xe13f,
+	0xe2ff,
+	0xe3ff,
+	0xe4f7,
+	0xe579,
+	0xe6ce,
+	0xe71f,
+	0xe85f,
+	0xf03f,
+	0x0311,
+	0x1013,
+	0xf040,
+	0xf26e,
+	0xf364,
+	0xf4fe,
+	0xf5fd,
+	0xf600,
+	0xf700,
+	0x0312,
+	0x1208,
+	0x2b08,
+	0x2c08,
+	0x2d08,
+	0x2e06,
+	0x3309,
+	0x3503,
+	0x360f,
+	0x370d,
+	0x3802,
+	0x6021,
+	0x610e,
+	0x6270,
+	0x6370,
+	0x6501,
+	0xE158,
+	0xEC32,
+	0xEE03,
+	0x0313,
+	0x1033,
+	0xa00f,
+	0xe107,
+	0x0314,
+	0x1027,
+	0x1102,
+	0x1240,
+	0x2082,
+	0x3082,
+	0x4084,
+	0x5084,
+	0x0300,
+	0xff01,
+	0x0315,
+	0x1082,
+	0x0307,
+	0x1204,
+	0x3400,
+	0x3500,
+	0x1385,
+	0x1305,
+	0x374f,
+	0x3750,
+	0x374c,
+	0x3746,
+	0x373f,
+	0x3739,
+	0x3734,
+	0x3730,
+	0x372e,
+	0x372e,
+	0x372f,
+	0x3732,
+	0x3737,
+	0x373d,
+	0x3743,
+	0x3749,
+	0x374f,
+	0x374f,
+	0x374f,
+	0x374f,
+	0x3749,
+	0x3742,
+	0x373b,
+	0x3734,
+	0x372e,
+	0x372a,
+	0x3728,
+	0x3727,
+	0x3729,
+	0x372c,
+	0x3732,
+	0x3739,
+	0x3740,
+	0x3747,
+	0x374e,
+	0x374e,
+	0x374a,
+	0x3749,
+	0x3741,
+	0x3738,
+	0x3730,
+	0x3728,
+	0x3722,
+	0x371d,
+	0x371b,
+	0x371a,
+	0x371c,
+	0x3720,
+	0x3725,
+	0x372d,
+	0x3736,
+	0x373e,
+	0x3747,
+	0x3748,
+	0x3744,
+	0x3743,
+	0x3739,
+	0x3730,
+	0x3726,
+	0x371e,
+	0x3717,
+	0x3713,
+	0x3711,
+	0x3710,
+	0x3712,
+	0x3715,
+	0x371b,
+	0x3723,
+	0x372d,
+	0x3736,
+	0x3740,
+	0x3742,
+	0x373f,
+	0x373d,
+	0x3733,
+	0x3728,
+	0x371e,
+	0x3715,
+	0x370f,
+	0x370a,
+	0x3708,
+	0x3708,
+	0x3709,
+	0x370d,
+	0x3713,
+	0x371b,
+	0x3725,
+	0x372f,
+	0x373a,
+	0x373d,
+	0x373c,
+	0x3739,
+	0x372e,
+	0x3723,
+	0x3719,
+	0x3710,
+	0x3709,
+	0x3705,
+	0x3702,
+	0x3702,
+	0x3704,
+	0x3708,
+	0x370e,
+	0x3716,
+	0x3720,
+	0x372a,
+	0x3736,
+	0x3739,
+	0x373a,
+	0x3736,
+	0x372b,
+	0x3720,
+	0x3716,
+	0x370d,
+	0x3706,
+	0x3702,
+	0x3700,
+	0x3700,
+	0x3701,
+	0x3705,
+	0x370b,
+	0x3713,
+	0x371c,
+	0x3727,
+	0x3733,
+	0x3737,
+	0x3739,
+	0x3736,
+	0x372a,
+	0x371f,
+	0x3715,
+	0x370c,
+	0x3706,
+	0x3701,
+	0x3700,
+	0x3700,
+	0x3701,
+	0x3704,
+	0x370a,
+	0x3712,
+	0x371c,
+	0x3727,
+	0x3732,
+	0x3736,
+	0x373a,
+	0x3737,
+	0x372b,
+	0x3721,
+	0x3717,
+	0x370e,
+	0x3708,
+	0x3703,
+	0x3701,
+	0x3701,
+	0x3702,
+	0x3706,
+	0x370c,
+	0x3714,
+	0x371e,
+	0x3728,
+	0x3734,
+	0x3738,
+	0x373b,
+	0x3739,
+	0x372e,
+	0x3724,
+	0x371b,
+	0x3712,
+	0x370c,
+	0x3707,
+	0x3705,
+	0x3704,
+	0x3706,
+	0x370a,
+	0x3710,
+	0x3718,
+	0x3721,
+	0x372c,
+	0x3737,
+	0x373a,
+	0x373e,
+	0x373d,
+	0x3733,
+	0x3729,
+	0x3720,
+	0x3718,
+	0x3712,
+	0x370d,
+	0x370b,
+	0x370b,
+	0x370c,
+	0x3710,
+	0x3716,
+	0x371e,
+	0x3727,
+	0x3731,
+	0x373a,
+	0x373d,
+	0x3743,
+	0x3741,
+	0x3739,
+	0x3730,
+	0x3728,
+	0x3721,
+	0x371b,
+	0x3717,
+	0x3714,
+	0x3714,
+	0x3716,
+	0x3719,
+	0x371f,
+	0x3726,
+	0x372f,
+	0x3738,
+	0x3740,
+	0x3741,
+	0x3746,
+	0x3746,
+	0x373f,
+	0x3739,
+	0x3731,
+	0x372b,
+	0x3725,
+	0x3722,
+	0x371f,
+	0x371f,
+	0x3721,
+	0x3724,
+	0x3729,
+	0x3730,
+	0x3737,
+	0x373f,
+	0x3745,
+	0x3746,
+	0x3746,
+	0x3747,
+	0x3741,
+	0x373b,
+	0x3735,
+	0x372f,
+	0x372a,
+	0x3727,
+	0x3725,
+	0x3724,
+	0x3726,
+	0x3729,
+	0x372e,
+	0x3733,
+	0x373a,
+	0x3740,
+	0x3746,
+	0x3746,
+	0x375d,
+	0x375e,
+	0x3757,
+	0x374f,
+	0x3747,
+	0x3740,
+	0x373a,
+	0x3735,
+	0x3733,
+	0x3733,
+	0x3735,
+	0x3739,
+	0x373e,
+	0x3745,
+	0x374d,
+	0x3753,
+	0x3759,
+	0x3759,
+	0x375c,
+	0x375c,
+	0x3754,
+	0x374b,
+	0x3742,
+	0x373a,
+	0x3733,
+	0x372e,
+	0x372c,
+	0x372c,
+	0x372e,
+	0x3732,
+	0x3738,
+	0x3740,
+	0x3748,
+	0x3750,
+	0x3758,
+	0x3758,
+	0x3755,
+	0x3754,
+	0x374a,
+	0x3740,
+	0x3736,
+	0x372c,
+	0x3725,
+	0x3720,
+	0x371d,
+	0x371d,
+	0x371f,
+	0x3724,
+	0x372a,
+	0x3733,
+	0x373d,
+	0x3747,
+	0x3750,
+	0x3752,
+	0x374f,
+	0x374c,
+	0x3741,
+	0x3736,
+	0x372b,
+	0x3721,
+	0x3719,
+	0x3714,
+	0x3712,
+	0x3711,
+	0x3713,
+	0x3718,
+	0x371f,
+	0x3728,
+	0x3733,
+	0x373e,
+	0x3748,
+	0x374b,
+	0x3749,
+	0x3746,
+	0x373a,
+	0x372d,
+	0x3722,
+	0x3718,
+	0x3710,
+	0x370b,
+	0x3709,
+	0x3708,
+	0x370a,
+	0x370f,
+	0x3716,
+	0x371f,
+	0x372a,
+	0x3736,
+	0x3742,
+	0x3745,
+	0x3744,
+	0x3741,
+	0x3734,
+	0x3728,
+	0x371c,
+	0x3712,
+	0x370a,
+	0x3705,
+	0x3703,
+	0x3703,
+	0x3705,
+	0x3709,
+	0x3710,
+	0x3719,
+	0x3724,
+	0x3730,
+	0x373d,
+	0x3741,
+	0x3742,
+	0x373e,
+	0x3731,
+	0x3725,
+	0x3719,
+	0x370e,
+	0x3707,
+	0x3702,
+	0x3700,
+	0x3700,
+	0x3701,
+	0x3706,
+	0x370c,
+	0x3715,
+	0x3721,
+	0x372d,
+	0x373a,
+	0x373f,
+	0x3741,
+	0x373d,
+	0x3730,
+	0x3724,
+	0x3718,
+	0x370e,
+	0x3706,
+	0x3701,
+	0x3700,
+	0x3700,
+	0x3701,
+	0x3705,
+	0x370c,
+	0x3715,
+	0x3720,
+	0x372c,
+	0x3739,
+	0x373e,
+	0x3742,
+	0x373e,
+	0x3732,
+	0x3726,
+	0x371a,
+	0x3710,
+	0x3709,
+	0x3704,
+	0x3701,
+	0x3701,
+	0x3703,
+	0x3707,
+	0x370e,
+	0x3717,
+	0x3722,
+	0x372e,
+	0x373b,
+	0x373f,
+	0x3744,
+	0x3741,
+	0x3735,
+	0x372a,
+	0x371f,
+	0x3715,
+	0x370d,
+	0x3708,
+	0x3706,
+	0x3706,
+	0x3708,
+	0x370c,
+	0x3712,
+	0x371b,
+	0x3726,
+	0x3732,
+	0x373e,
+	0x3742,
+	0x3748,
+	0x3745,
+	0x373b,
+	0x3730,
+	0x3725,
+	0x371c,
+	0x3715,
+	0x3710,
+	0x370d,
+	0x370d,
+	0x370f,
+	0x3713,
+	0x371a,
+	0x3723,
+	0x372d,
+	0x3738,
+	0x3743,
+	0x3746,
+	0x374c,
+	0x374b,
+	0x3742,
+	0x3738,
+	0x372e,
+	0x3726,
+	0x371f,
+	0x371a,
+	0x3717,
+	0x3717,
+	0x3719,
+	0x371d,
+	0x3724,
+	0x372c,
+	0x3736,
+	0x373f,
+	0x3749,
+	0x374b,
+	0x3751,
+	0x3750,
+	0x3749,
+	0x3741,
+	0x3739,
+	0x3731,
+	0x372b,
+	0x3727,
+	0x3724,
+	0x3724,
+	0x3726,
+	0x372a,
+	0x3730,
+	0x3737,
+	0x3740,
+	0x3748,
+	0x374f,
+	0x3750,
+	0x3750,
+	0x3751,
+	0x374b,
+	0x3744,
+	0x373d,
+	0x3736,
+	0x3730,
+	0x372d,
+	0x372a,
+	0x372a,
+	0x372c,
+	0x3730,
+	0x3735,
+	0x373c,
+	0x3743,
+	0x374a,
+	0x3751,
+	0x3751,
+	0x3746,
+	0x3748,
+	0x3744,
+	0x373f,
+	0x3739,
+	0x3734,
+	0x372f,
+	0x372b,
+	0x3729,
+	0x3728,
+	0x372a,
+	0x372c,
+	0x3730,
+	0x3735,
+	0x373b,
+	0x3740,
+	0x3744,
+	0x3744,
+	0x3746,
+	0x3747,
+	0x3742,
+	0x373c,
+	0x3735,
+	0x372f,
+	0x372a,
+	0x3726,
+	0x3724,
+	0x3723,
+	0x3724,
+	0x3727,
+	0x372c,
+	0x3731,
+	0x3737,
+	0x373d,
+	0x3743,
+	0x3743,
+	0x3741,
+	0x3740,
+	0x3739,
+	0x3733,
+	0x372b,
+	0x3725,
+	0x371f,
+	0x371b,
+	0x3718,
+	0x3718,
+	0x3719,
+	0x371c,
+	0x3721,
+	0x3727,
+	0x372e,
+	0x3735,
+	0x373c,
+	0x373d,
+	0x373b,
+	0x373a,
+	0x3732,
+	0x372b,
+	0x3723,
+	0x371b,
+	0x3716,
+	0x3711,
+	0x370f,
+	0x370e,
+	0x3710,
+	0x3713,
+	0x3718,
+	0x371f,
+	0x3727,
+	0x372e,
+	0x3735,
+	0x3737,
+	0x3736,
+	0x3734,
+	0x372c,
+	0x3724,
+	0x371b,
+	0x3714,
+	0x370e,
+	0x370a,
+	0x3707,
+	0x3707,
+	0x3709,
+	0x370c,
+	0x3711,
+	0x3718,
+	0x3720,
+	0x3728,
+	0x3730,
+	0x3733,
+	0x3733,
+	0x3731,
+	0x3728,
+	0x371f,
+	0x3716,
+	0x370f,
+	0x3709,
+	0x3705,
+	0x3703,
+	0x3703,
+	0x3704,
+	0x3707,
+	0x370c,
+	0x3713,
+	0x371b,
+	0x3724,
+	0x372d,
+	0x3730,
+	0x3731,
+	0x372f,
+	0x3726,
+	0x371d,
+	0x3714,
+	0x370c,
+	0x3706,
+	0x3702,
+	0x3700,
+	0x3700,
+	0x3702,
+	0x3705,
+	0x370a,
+	0x3711,
+	0x3719,
+	0x3722,
+	0x372b,
+	0x372e,
+	0x3730,
+	0x372e,
+	0x3725,
+	0x371c,
+	0x3713,
+	0x370b,
+	0x3706,
+	0x3702,
+	0x3700,
+	0x3700,
+	0x3701,
+	0x3704,
+	0x3709,
+	0x3710,
+	0x3718,
+	0x3721,
+	0x372a,
+	0x372e,
+	0x3732,
+	0x372f,
+	0x3726,
+	0x371d,
+	0x3715,
+	0x370d,
+	0x3707,
+	0x3704,
+	0x3701,
+	0x3701,
+	0x3703,
+	0x3706,
+	0x370b,
+	0x3712,
+	0x371a,
+	0x3723,
+	0x372c,
+	0x372f,
+	0x3734,
+	0x3732,
+	0x3729,
+	0x3721,
+	0x3719,
+	0x3711,
+	0x370b,
+	0x3707,
+	0x3705,
+	0x3705,
+	0x3706,
+	0x370a,
+	0x370f,
+	0x3716,
+	0x371e,
+	0x3726,
+	0x372f,
+	0x3732,
+	0x3737,
+	0x3736,
+	0x372e,
+	0x3726,
+	0x371e,
+	0x3717,
+	0x3711,
+	0x370d,
+	0x370a,
+	0x370a,
+	0x370c,
+	0x370f,
+	0x3715,
+	0x371c,
+	0x3723,
+	0x372b,
+	0x3733,
+	0x3735,
+	0x373c,
+	0x373b,
+	0x3734,
+	0x372d,
+	0x3725,
+	0x371f,
+	0x3719,
+	0x3715,
+	0x3712,
+	0x3712,
+	0x3714,
+	0x3717,
+	0x371c,
+	0x3723,
+	0x372a,
+	0x3731,
+	0x3738,
+	0x3739,
+	0x3740,
+	0x3740,
+	0x373a,
+	0x3734,
+	0x372d,
+	0x3727,
+	0x3722,
+	0x371e,
+	0x371c,
+	0x371b,
+	0x371d,
+	0x3720,
+	0x3725,
+	0x372b,
+	0x3731,
+	0x3737,
+	0x373d,
+	0x373d,
+	0x3740,
+	0x3740,
+	0x373c,
+	0x3736,
+	0x3730,
+	0x372a,
+	0x3725,
+	0x3722,
+	0x3720,
+	0x371f,
+	0x3721,
+	0x3724,
+	0x3729,
+	0x372e,
+	0x3734,
+	0x3739,
+	0x373e,
+	0x373e,
+	0x374f,
+	0x3750,
+	0x374c,
+	0x3746,
+	0x373f,
+	0x3739,
+	0x3734,
+	0x3730,
+	0x372e,
+	0x372e,
+	0x372f,
+	0x3732,
+	0x3737,
+	0x373d,
+	0x3743,
+	0x3749,
+	0x374f,
+	0x374f,
+	0x374f,
+	0x374f,
+	0x3749,
+	0x3742,
+	0x373b,
+	0x3734,
+	0x372e,
+	0x372a,
+	0x3728,
+	0x3727,
+	0x3729,
+	0x372c,
+	0x3732,
+	0x3739,
+	0x3740,
+	0x3747,
+	0x374e,
+	0x374e,
+	0x374a,
+	0x3749,
+	0x3741,
+	0x3738,
+	0x3730,
+	0x3728,
+	0x3722,
+	0x371d,
+	0x371b,
+	0x371a,
+	0x371c,
+	0x3720,
+	0x3725,
+	0x372d,
+	0x3736,
+	0x373e,
+	0x3747,
+	0x3748,
+	0x3744,
+	0x3743,
+	0x3739,
+	0x3730,
+	0x3726,
+	0x371e,
+	0x3717,
+	0x3713,
+	0x3711,
+	0x3710,
+	0x3712,
+	0x3715,
+	0x371b,
+	0x3723,
+	0x372d,
+	0x3736,
+	0x3740,
+	0x3742,
+	0x373f,
+	0x373d,
+	0x3733,
+	0x3728,
+	0x371e,
+	0x3715,
+	0x370f,
+	0x370a,
+	0x3708,
+	0x3708,
+	0x3709,
+	0x370d,
+	0x3713,
+	0x371b,
+	0x3725,
+	0x372f,
+	0x373a,
+	0x373d,
+	0x373c,
+	0x3739,
+	0x372e,
+	0x3723,
+	0x3719,
+	0x3710,
+	0x3709,
+	0x3705,
+	0x3702,
+	0x3702,
+	0x3704,
+	0x3708,
+	0x370e,
+	0x3716,
+	0x3720,
+	0x372a,
+	0x3736,
+	0x3739,
+	0x373a,
+	0x3736,
+	0x372b,
+	0x3720,
+	0x3716,
+	0x370d,
+	0x3706,
+	0x3702,
+	0x3700,
+	0x3700,
+	0x3701,
+	0x3705,
+	0x370b,
+	0x3713,
+	0x371c,
+	0x3727,
+	0x3733,
+	0x3737,
+	0x3739,
+	0x3736,
+	0x372a,
+	0x371f,
+	0x3715,
+	0x370c,
+	0x3706,
+	0x3701,
+	0x3700,
+	0x3700,
+	0x3701,
+	0x3704,
+	0x370a,
+	0x3712,
+	0x371c,
+	0x3727,
+	0x3732,
+	0x3736,
+	0x373a,
+	0x3737,
+	0x372b,
+	0x3721,
+	0x3717,
+	0x370e,
+	0x3708,
+	0x3703,
+	0x3701,
+	0x3701,
+	0x3702,
+	0x3706,
+	0x370c,
+	0x3714,
+	0x371e,
+	0x3728,
+	0x3734,
+	0x3738,
+	0x373b,
+	0x3739,
+	0x372e,
+	0x3724,
+	0x371b,
+	0x3712,
+	0x370c,
+	0x3707,
+	0x3705,
+	0x3704,
+	0x3706,
+	0x370a,
+	0x3710,
+	0x3718,
+	0x3721,
+	0x372c,
+	0x3737,
+	0x373a,
+	0x373e,
+	0x373d,
+	0x3733,
+	0x3729,
+	0x3720,
+	0x3718,
+	0x3712,
+	0x370d,
+	0x370b,
+	0x370b,
+	0x370c,
+	0x3710,
+	0x3716,
+	0x371e,
+	0x3727,
+	0x3731,
+	0x373a,
+	0x373d,
+	0x3743,
+	0x3741,
+	0x3739,
+	0x3730,
+	0x3728,
+	0x3721,
+	0x371b,
+	0x3717,
+	0x3714,
+	0x3714,
+	0x3716,
+	0x3719,
+	0x371f,
+	0x3726,
+	0x372f,
+	0x3738,
+	0x3740,
+	0x3741,
+	0x3746,
+	0x3746,
+	0x373f,
+	0x3739,
+	0x3731,
+	0x372b,
+	0x3725,
+	0x3722,
+	0x371f,
+	0x371f,
+	0x3721,
+	0x3724,
+	0x3729,
+	0x3730,
+	0x3737,
+	0x373f,
+	0x3745,
+	0x3746,
+	0x3746,
+	0x3747,
+	0x3741,
+	0x373b,
+	0x3735,
+	0x372f,
+	0x372a,
+	0x3727,
+	0x3725,
+	0x3724,
+	0x3726,
+	0x3729,
+	0x372e,
+	0x3733,
+	0x373a,
+	0x3740,
+	0x3746,
+	0x3746,
+	0x1200,
+	0x1300,
+	0x0315,
+	0x1083,
+	0x0316,
+	0x100f,
+	0x60ff,
+
+	0x8a68,
+	0x8b7c,
+	0x8c7f,
+	0x8d7f,
+	0x8e7f,
+	0x8f7f,
+	0x907f,
+	0x917f,
+	0x927f,
+	0x937f,
+	0x947a,
+	0x9578,
+	0x9674,
+	0x9770,
+	0x986c,
+	0x9968,
+	0x9a64,
+
+	0xa081,
+	0xa100,
+	0xa258,
+	0xa382,
+	0xa6f0,
+	0xa8f0,
+
+	0xF009,
+	0xF180,
+	0xF280,
+	0xF380,
+	0xF480,
+
+	0x0317,
+	0x1001,
+
+	0x0318,
+	0x1000,
+
+	0x0320,
+	0x109f,
+	0x122d,
+	0x17a0,
+	0x1f1f,
+	0x2000,
+	0x2118,
+	0x22b8,
+	0x2320,
+	0x2400,
+	0x2562,
+	0x26e0,
+	0x2780,
+	0x2800,
+	0x2913,
+	0x2a88,
+	0x3008,
+	0x313d,
+	0x3260,
+	0x3306,
+	0x34dd,
+	0x35d0,
+	0x3600,
+	0x3709,
+	0x38c4,
+	0x4000,
+	0x4108,
+	0x423d,
+	0x51f0,
+	0x5224,
+	0x7184,
+	0x7280,
+	0x8032,
+
+	0x0330,
+	0x1200,
+	0x2008,
+	0x5000,
+	0xe002,
+	0xf000,
+	0x1105,
+	0x03c0,
+	0xe4A0,
+
+	0x0330,
+	0x7c2c,
+	0x7dce,
+	0x7e2c,
+	0x7fd1,
+	0x8024,
+	0x8170,
+	0x8224,
+	0x8373,
+	0x8421,
+	0x85a6,
+	0x8621,
+	0x87a9,
+	0x8827,
+	0x893a,
+	0x8a27,
+	0x8b3d,
+	0x8c2a,
+	0x8d04,
+	0x8e2a,
+	0x8f07,
+	0x03C0,
+	0x2Ff0,
+	0x3120,
+	0x3320,
+	0x3201,
+	0x03C0,
+	0x2Ff0,
+	0x3120,
+	0x3320,
+	0x3201,
+	0x0300,
+	0x1013,
+	0x01F0,
+
+	0x0330,
+	0xDE20,
+	0xDFA5,
+	0x03E7,
+	0x1F18,
+	0x209c,
+	0x210F,
+	0x2250,
+
+	0x03CD,
+	0x4700,
+	0x1280,
+	0x1380,
+	0x148C,
+	0x1580,
+	0x168C,
+	0x10B9,
+
+	0x031f,
+	0x1100,
+	0x1260,
+	0x1314,
+	0x1410,
+	0x1500,
+	0x2018,
+	0x2114,
+	0x228C,
+	0x2360,
+	0x2818,
+	0x2902,
+	0x3B18,
+	0x3C8C,
+	0x1019,
+
+	0x03c4,
+	0x1290,
+	0x1510,
+	0x160a,
+	0x1708,
+	0x1804,
+
+	0x193c,
+	0x1e00,
+	0x1f18,
+	0x20b8,
+	0x2120,
+	0x1a46,
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x1b5c,
+	0x2600,
+	0x2741,
+	0x28eb,
+	0x2900,
+	0x3611,
+
+	0x03c3,
+	0x1000,
+	0x38FF,
+	0x39FF,
+
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+	0xE125,
+	0xE203,
+
+	0x03d5,
+	0x1199,
+	0x1e04,
+	0x8608,
+	0x1f01,
+	0x2040,
+	0x2109,
+	0x22c4,
+	0x8c01,
+	0x8d40,
+	0x9209,
+	0x93c4,
+	0x3300,
+
+	0x03c0,
+	0x1680,
+	0x1681,
+
+	0x03c5,
+	0x0e01,
+	0x1030,
+	0x11a5,
+	0x1293,
+	0x131d,
+	0x1402,
+	0x150A,
+	0x1606,
+	0x1708,
+	0x180a,
+	0x1903,
+	0x1aa0,
+	0x1b08,
+	0x1c10,
+	0x1d40,
+	0x1e00,
+	0x1fc8,
+	0x2000,
+	0x219b,
+	0x2200,
+	0x23c8,
+	0x2400,
+	0x25a5,
+	0x2601,
+	0x2709,
+	0x2800,
+	0x2955,
+	0x2a00,
+	0x2bd2,
+	0x2c00,
+	0x2d55,
+	0x2e00,
+	0x2f02,
+	0x300f,
+	0x3158,
+	0x3200,
+	0x3302,
+	0x3451,
+	0x3543,
+	0x3600,
+	0x3709,
+	0x3845,
+	0x390c,
+	0x3a00,
+	0x3b12,
+	0x3c8a,
+	0x3d18,
+	0x3e01,
+	0x3fee,
+	0x4062,
+	0x4180,
+	0x4202,
+	0x4351,
+	0x4443,
+	0x4500,
+	0x4600,
+	0x4709,
+	0x4845,
+	0x490c,
+	0x4a00,
+	0x4b12,
+	0x4c8a,
+	0x4d18,
+	0x4e00,
+	0x4f00,
+	0x5055,
+	0x5155,
+	0x5255,
+	0x5355,
+	0x5455,
+	0x5555,
+	0x5655,
+	0x5755,
+	0x5855,
+	0x5955,
+	0x5aaa,
+	0x5b55,
+	0x5c55,
+	0x5daa,
+	0x5e55,
+	0x5f55,
+	0x60aa,
+	0x6155,
+	0x6255,
+	0x6355,
+	0x6455,
+	0x6555,
+	0x6655,
+	0x6755,
+	0x6855,
+	0x6955,
+	0x6a55,
+	0x6b16,
+	0x6c25,
+	0x6d29,
+	0x6e30,
+	0x6f33,
+	0x7039,
+	0x7142,
+	0x724e,
+	0x7359,
+	0x7464,
+	0x75ad,
+	0x76C0,
+	0x7783,
+	0x7871,
+	0x795C,
+	0x7a4E,
+	0x7b45,
+	0x7c3e,
+	0x7d3a,
+	0x7e37,
+	0x7f35,
+	0x802a,
+	0x81D0,
+	0x82A7,
+	0x839F,
+	0x8486,
+	0x857c,
+	0x8671,
+	0x8762,
+	0x884f,
+	0x8945,
+	0x8a3f,
+	0x8b31,
+	0x8c16,
+	0x8d24,
+	0x8e27,
+	0x8f2b,
+	0x902e,
+	0x9132,
+	0x9237,
+	0x933e,
+	0x9447,
+	0x9562,
+	0x96ad,
+	0x97C8,
+	0x989F,
+	0x9990,
+	0x9a83,
+	0x9b73,
+	0x9c68,
+	0x9d5A,
+	0x9e50,
+	0x9f45,
+	0xa03b,
+	0xa12d,
+	0xa232,
+	0xa337,
+	0xa441,
+	0xa546,
+	0xa64b,
+	0xa750,
+	0xa85a,
+	0xa96e,
+	0xaa03,
+	0xab03,
+	0xac03,
+	0xad03,
+	0xae00,
+	0xaf00,
+	0xb000,
+	0xb100,
+	0xb294,
+	0xb394,
+	0xb494,
+	0xb594,
+	0xb600,
+	0xb781,
+	0xb881,
+	0xb981,
+	0xba00,
+	0xbb00,
+	0xbc00,
+	0xbd00,
+	0xbe00,
+	0xbf00,
+	0xc000,
+	0xc100,
+	0xc200,
+	0xc300,
+	0xc400,
+	0xc500,
+	0xc600,
+	0xc700,
+	0xc800,
+	0xc900,
+	0xca00,
+	0xcb00,
+	0xcc00,
+	0xcd00,
+	0xce20,
+	0xcf80,
+	0xd020,
+	0xd100,
+	0xd20a, /*aInYlvlWgt*/
+	0xd319,
+	0xd42d,
+	0xd53c,
+	0xd64b,
+	0xd755,
+	0xd864,
+	0xd964,
+	0xda5a,
+	0xdb4b,
+	0xdc3c,
+	0xdd28,
+	0xde1e,
+	0xdf14,
+	0xe00a,
+	0xe10a,
+	0xe2ff,
+	0xe3ff,
+	0xe4ff,
+	0xe5ff,
+	0xe6ff,
+	0xe7ff,
+	0xe880,
+	0xe930,
+	0xea1e,
+	0xeb1e,
+	0xec1e,
+	0xed80,
+	0xee80,
+	0xef80,
+	0xf080,
+	0xf180,
+	0xf240,
+	0xf320,
+	0xf40a,
+	0xf50a,
+	0xf60a,
+	0xf70a,
+	0xf832,
+	0xf902,
+	0xfa32,
+	0xfb28,
+	0xfc64,
+	0xfd1E,
+	0x0e00,
+	0x03c6,
+	0x0e01,
+	0x1028,
+	0x1150,
+	0x121e,
+	0x1332,
+	0x144B,
+	0x151e,
+	0x1608,
+	0x17e0,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba4,
+	0x1c0a,
+	0x1d04,
+	0x1e14,
+	0x1f29,
+	0x202E,
+	0x2134,
+	0x223B,
+	0x2343,
+	0x244A,
+	0x2551,
+	0x2659,
+	0x2761,
+	0x28A0,
+	0x299F,
+	0x2a58,
+	0x2b54,
+	0x2c4F,
+	0x2d49,
+	0x2e46,
+	0x2f44,
+	0x3042,
+	0x3141,
+	0x3240,
+	0x333C,
+	0x34AA,
+	0x3568,
+	0x3666,
+	0x3764,
+	0x3862,
+	0x395F,
+	0x3a5C,
+	0x3b59,
+	0x3c53,
+	0x3d50,
+	0x3e4A,
+	0x3f14,
+	0x402A,
+	0x4130,
+	0x4237,
+	0x433E,
+	0x4446,
+	0x454D,
+	0x4654,
+	0x475B,
+	0x4861,
+	0x49A0,
+	0x4aA5,
+	0x4b5F,
+	0x4c5C,
+	0x4d57,
+	0x4e54,
+	0x4f50,
+	0x504E,
+	0x514B,
+	0x5248,
+	0x5347,
+	0x5443,
+	0x5550,
+	0x5655,
+	0x575a,
+	0x585f,
+	0x5964,
+	0x5a69,
+	0x5b6e,
+	0x5c73,
+	0x5d00,
+	0x5e00,
+	0x5f00,
+	0x6000,
+	0x6100,
+	0x6200,
+	0x6300,
+	0x6400,
+	0x6500,
+	0x6600,
+	0x6700,
+	0x6800,
+	0x6900,
+	0x6a00,
+	0x6b00,
+	0x6c00,
+	0x6d00,
+	0x6e00,
+	0x6f00,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7a00,
+	0x7b00,
+	0x7c00,
+	0x7d00,
+	0x7e00,
+	0x7f00,
+	0x8011,
+	0x8122,
+	0x8222,
+	0x8333,
+	0x8433,
+	0x8512,
+	0x861e,
+	0x8728,
+	0x882d,
+	0x892d,
+	0x8a12,
+	0x8b0a,
+	0x8c15,
+	0x8d1f,
+	0x8e16,
+	0x8f15,
+	0x900a,
+	0x910a,
+	0x920a,
+	0x930a,
+	0x940a,
+	0x95ff,
+	0x96ff,
+	0x97ff,
+	0x98ff,
+	0x99ff,
+	0x9aff,
+	0x9bff,
+	0x9cff,
+	0x9dff,
+	0x9eff,
+	0x9fff,
+	0xa008,
+	0xa108,
+	0xa208,
+	0xa30d,
+	0xa410,
+	0xa512,
+	0xa612,
+	0xa712,
+	0xa813,
+	0xa913,
+	0xaa14,
+	0xab0a,
+	0xac01,
+	0xad14,
+	0xae19,
+	0xaf55,
+	0xb01E,
+	0xb128,
+	0xb21E,
+	0xb350,
+	0xb41e,
+	0xb53c,
+	0xb61e,
+	0xb708,
+	0xb8d2,
+	0xb960,
+	0xba66,
+	0xbb66,
+	0xbc80,
+	0xbd0a,
+	0xbe04,
+	0x0e00,
+	0x03d4,
+	0x315e,
+	0x326a,
+	0x356c,
+	0x367e,
+	0x375e,
+	0x3872,
+	0x3b6c,
+	0x3c7b,
+	0x3d46,
+	0x3e90,
+	0x4140,
+	0x42a7,
+	0x03c9,
+	0x4268,
+	0x4340,
+	0x4470,
+
+	0x03CD,
+	0x4706,
+	0x10B8,
+
+	0x03cf,
+	0x0e01,
+	0x1000,
+	0x1105,
+	0x1201,
+	0x1302,
+	0x1482,
+	0x15b3,
+	0x1640,
+	0x1700,
+	0x18cf,
+	0x1906,
+	0x1a0c,
+	0x1b00,
+	0x1c09,
+	0x1d45,
+	0x1e0c,
+	0x1f00,
+	0x2000,
+	0x2120,
+	0x22F6,
+	0x2378,
+	0x2458,
+	0x2538,
+	0x2660,
+	0x2740,
+	0x2801,
+	0x2900,
+	0x2a00,
+	0x2b00,
+	0x2c00,
+	0x2d00,
+	0x2ebc,
+	0x2f7b,
+	0x30f4,
+	0x3100,
+	0x3200,
+	0x3300,
+	0x3400,
+	0x3500,
+	0x3600,
+	0x3700,
+	0x3800,
+	0x3900,
+	0x3a14,
+	0x3b00,
+	0x3c00,
+	0x3d00,
+	0x3e00,
+
+	0x3f28,
+	0x4028,
+	0x4128,
+	0x422e,
+	0x432e,
+	0x442e,
+	0x4533,
+	0x4633,
+	0x4733,
+	0x4833,
+	0x4933,
+	0x4a33,
+
+	0x4b80,
+	0x4c80,
+	0x4d80,
+	0x4e80,
+	0x4f80,
+	0x5080,
+	0x5180,
+	0x5280,
+	0x5380,
+	0x5480,
+	0x5580,
+	0x5680,
+
+	0x5700,
+	0x5800,
+	0x5900,
+	0x5a00,
+	0x5b00,
+	0x5c00,
+	0x5d00,
+	0x5e00,
+	0x5f00,
+	0x6000,
+	0x6100,
+	0x6200,
+
+	0x6300,
+	0x6402,
+	0x6504,
+	0x660a,
+	0x6711,
+	0x6823,
+	0x6936,
+	0x6a46,
+	0x6b57,
+	0x6c64,
+	0x6d6f,
+	0x6e78,
+	0x6f80,
+	0x7087,
+	0x718c,
+	0x7291,
+	0x7396,
+	0x749a,
+	0x759f,
+	0x76a3,
+	0x77a8,
+	0x78af,
+	0x79b6,
+	0x7abc,
+	0x7bc6,
+	0x7cd1,
+	0x7ddb,
+	0x7ee2,
+	0x7fe9,
+	0x80f0,
+	0x81f6,
+	0x82fa,
+	0x83fe,
+	0x84ff,
+	0x8500,
+	0x8602,
+	0x8704,
+	0x880a,
+	0x8911,
+	0x8a23,
+	0x8b36,
+	0x8c46,
+	0x8d57,
+	0x8e64,
+	0x8f6f,
+	0x9078,
+	0x9180,
+	0x9287,
+	0x938c,
+	0x9491,
+	0x9596,
+	0x969a,
+	0x979f,
+	0x98a3,
+	0x99a8,
+	0x9aaf,
+	0x9bb6,
+	0x9cbc,
+	0x9dc6,
+	0x9ed1,
+	0x9fdb,
+	0xa0e2,
+	0xa1e9,
+	0xa2f0,
+	0xa3f6,
+	0xa4fa,
+	0xa5fe,
+	0xa6ff,
+	0xa700,
+	0xa802,
+	0xa904,
+	0xaa0a,
+	0xab11,
+	0xac23,
+	0xad36,
+	0xae46,
+	0xaf57,
+	0xb064,
+	0xb16f,
+	0xb278,
+	0xb380,
+	0xb487,
+	0xb58c,
+	0xb691,
+	0xb796,
+	0xb89a,
+	0xb99f,
+	0xbaa3,
+	0xbba8,
+	0xbcaf,
+	0xbdb6,
+	0xbebc,
+	0xbfc6,
+	0xc0d1,
+	0xc1db,
+	0xc2e2,
+	0xc3e9,
+	0xc4f0,
+	0xc5f6,
+	0xc6fa,
+	0xc7fe,
+	0xc8ff,
+	0xc900,
+	0xca02,
+	0xcb04,
+	0xcc0a,
+	0xcd15,
+	0xce24,
+	0xcf34,
+	0xd044,
+	0xd151,
+	0xd25f,
+	0xd36b,
+	0xd475,
+	0xd57d,
+	0xd685,
+	0xd78a,
+	0xd88f,
+	0xd993,
+	0xda98,
+	0xdb9c,
+	0xdca0,
+	0xdda5,
+	0xdeab,
+	0xdfb2,
+	0xe0ba,
+	0xe1c6,
+	0xe2d3,
+	0xe3de,
+	0xe4e7,
+	0xe5ed,
+	0xe6f3,
+	0xe7f7,
+	0xe8fa,
+	0xe9fe,
+	0xeaff,
+	0xeb00,
+	0xec02,
+	0xed04,
+	0xee0a,
+	0xef15,
+	0xf024,
+	0xf134,
+	0xf244,
+	0xf351,
+	0xf45f,
+	0xf56b,
+	0xf675,
+	0xf77d,
+	0xf885,
+	0xf98a,
+	0xfa8f,
+	0xfb93,
+	0xfc98,
+	0xfd9c,
+	0x0e00,
+	0x03d0,
+	0x0e01,
+	0x10a0,
+	0x11a5,
+	0x12ab,
+	0x13b2,
+	0x14ba,
+	0x15c6,
+	0x16d3,
+	0x17de,
+	0x18e7,
+	0x19ed,
+	0x1af3,
+	0x1bf7,
+	0x1cfa,
+	0x1dfe,
+	0x1eff,
+	0x1f00,
+	0x2002,
+	0x2104,
+	0x220a,
+	0x2315,
+	0x2424,
+	0x2534,
+	0x2644,
+	0x2751,
+	0x285f,
+	0x296b,
+	0x2a75,
+	0x2b7d,
+	0x2c85,
+	0x2d8a,
+	0x2e8f,
+	0x2f93,
+	0x3098,
+	0x319c,
+	0x32a0,
+	0x33a5,
+	0x34ab,
+	0x35b2,
+	0x36ba,
+	0x37c6,
+	0x38d3,
+	0x39de,
+	0x3ae7,
+	0x3bed,
+	0x3cf3,
+	0x3df7,
+	0x3efa,
+	0x3ffe,
+	0x40ff,
+	0x4100,
+	0x4201,
+	0x4304,
+	0x440a,
+	0x4514,
+	0x4623,
+	0x4730,
+	0x4840,
+	0x494d,
+	0x4a57,
+	0x4b62,
+	0x4c6b,
+	0x4d73,
+	0x4e7a,
+	0x4f82,
+	0x5089,
+	0x518e,
+	0x5294,
+	0x5399,
+	0x549e,
+	0x55a2,
+	0x56aa,
+	0x57b1,
+	0x58b9,
+	0x59c4,
+	0x5ace,
+	0x5bd6,
+	0x5cdc,
+	0x5de1,
+	0x5ee6,
+	0x5fec,
+	0x60f1,
+	0x61f5,
+	0x62f9,
+	0x6300,
+	0x6401,
+	0x6504,
+	0x660a,
+	0x6714,
+	0x6823,
+	0x6930,
+	0x6a40,
+	0x6b4d,
+	0x6c57,
+	0x6d62,
+	0x6e6b,
+	0x6f73,
+	0x707a,
+	0x7182,
+	0x7289,
+	0x738e,
+	0x7494,
+	0x7599,
+	0x769e,
+	0x77a2,
+	0x78aa,
+	0x79b1,
+	0x7ab9,
+	0x7bc4,
+	0x7cce,
+	0x7dd6,
+	0x7edc,
+	0x7fe1,
+	0x80e6,
+	0x81ec,
+	0x82f1,
+	0x83f5,
+	0x84f9,
+	0x8500,
+	0x8601,
+	0x8704,
+	0x880a,
+	0x8914,
+	0x8a23,
+	0x8b30,
+	0x8c40,
+	0x8d4d,
+	0x8e57,
+	0x8f62,
+	0x906b,
+	0x9173,
+	0x927a,
+	0x9382,
+	0x9489,
+	0x958e,
+	0x9694,
+	0x9799,
+	0x989e,
+	0x99a2,
+	0x9aaa,
+	0x9bb1,
+	0x9cb9,
+	0x9dc4,
+	0x9ece,
+	0x9fd6,
+	0xa0dc,
+	0xa1e1,
+	0xa2e6,
+	0xa3ec,
+	0xa4f1,
+	0xa5f5,
+	0xa6f9,
+	0xa700,
+	0xa801,
+	0xa904,
+	0xaa0a,
+	0xab14,
+	0xac23,
+	0xad30,
+	0xae40,
+	0xaf4d,
+	0xb057,
+	0xb162,
+	0xb26b,
+	0xb373,
+	0xb47a,
+	0xb582,
+	0xb689,
+	0xb78e,
+	0xb894,
+	0xb999,
+	0xba9e,
+	0xbba2,
+	0xbcaa,
+	0xbdb1,
+	0xbeb9,
+	0xbfc4,
+	0xc0ce,
+	0xc1d6,
+	0xc2dc,
+	0xc3e1,
+	0xc4e6,
+	0xc5ec,
+	0xc6f1,
+	0xc7f5,
+	0xc8f9,
+	0xc900,
+	0xca01,
+	0xcb04,
+	0xcc0a,
+	0xcd14,
+	0xce23,
+	0xcf30,
+	0xd040,
+	0xd14d,
+	0xd257,
+	0xd362,
+	0xd46b,
+	0xd573,
+	0xd67a,
+	0xd782,
+	0xd889,
+	0xd98e,
+	0xda94,
+	0xdb99,
+	0xdc9e,
+	0xdda2,
+	0xdeaa,
+	0xdfb1,
+	0xe0b9,
+	0xe1c4,
+	0xe2ce,
+	0xe3d6,
+	0xe4dc,
+	0xe5e1,
+	0xe6e6,
+	0xe7ec,
+	0xe8f1,
+	0xe9f5,
+	0xeaf9,
+	0xeb00,
+	0xec01,
+	0xed04,
+	0xee0a,
+	0xef14,
+	0xf023,
+	0xf130,
+	0xf240,
+	0xf34d,
+	0xf457,
+	0xf562,
+	0xf66b,
+	0xf773,
+	0xf87a,
+	0xf982,
+	0xfa89,
+	0xfb8e,
+	0xfc94,
+	0xfd99,
+	0x0e00,
+	0x03d1,
+	0x0e01,
+	0x109e,
+	0x11a2,
+	0x12aa,
+	0x13b1,
+	0x14b9,
+	0x15c4,
+	0x16ce,
+	0x17d6,
+	0x18dc,
+	0x19e1,
+	0x1ae6,
+	0x1bec,
+	0x1cf1,
+	0x1df5,
+	0x1ef9,
+
+	0x1f80,
+	0x2080,
+	0x2180,
+	0x2280,
+	0x2380,
+	0x2480,
+	0x2580,
+	0x2680,
+	0x2780,
+	0x2880,
+	0x2980,
+	0x2a80,
+
+	0x2b88,
+	0x2c88,
+	0x2d88,
+	0x2e88,
+	0x2f88,
+	0x308c,
+	0x3198,
+	0x3298,
+	0x3398,
+	0x3498,
+	0x3598,
+	0x3698,
+
+	0x3780,
+	0x3880,
+	0x3980,
+	0x3a78,
+	0x3b88,
+	0x3c84,
+	0x3d8c,
+	0x3e8c,
+	0x3f8c,
+	0x408c,
+	0x418c,
+	0x428c,
+
+	0x432f,
+	0x4468,
+	0x4529,
+	0x4601,
+	0x4719,
+	0x486c,
+	0x4913,
+	0x4a13,
+	0x4b1e,
+	0x4c71,
+	0x4d2f,
+	0x4e68,
+	0x4f29,
+	0x5001,
+	0x5119,
+	0x526c,
+	0x5313,
+	0x5413,
+	0x551e,
+	0x5671,
+	0x572f,
+	0x5868,
+	0x5929,
+	0x5a01,
+	0x5b19,
+	0x5c6c,
+	0x5d13,
+	0x5e13,
+	0x5f1e,
+	0x6071,
+	0x612f,
+	0x626a,
+	0x6332,
+	0x6408,
+	0x651a,
+	0x666c,
+	0x6712,
+	0x6803,
+	0x6930,
+	0x6a73,
+	0x6b2f,
+	0x6c68,
+	0x6d29,
+	0x6e01,
+	0x6f17,
+	0x706c,
+	0x7115,
+	0x7201,
+	0x7330,
+	0x7471,
+	0x752f,
+	0x7668,
+	0x7729,
+	0x7801,
+	0x7917,
+	0x7a6c,
+	0x7b15,
+	0x7c01,
+	0x7d30,
+	0x7e71,
+	0x7f2f,
+	0x806a,
+	0x813c,
+	0x8212,
+	0x8321,
+	0x8470,
+	0x850f,
+	0x8606,
+	0x872d,
+	0x8873,
+	0x892f,
+	0x8a6a,
+	0x8b3c,
+	0x8c12,
+	0x8d21,
+	0x8e70,
+	0x8f0f,
+	0x9006,
+	0x912d,
+	0x9273,
+	0x932f,
+	0x946a,
+	0x953c,
+	0x9612,
+	0x9721,
+	0x9870,
+	0x990f,
+	0x9a06,
+	0x9b2d,
+	0x9c73,
+	0x9d2f,
+	0x9e6a,
+	0x9f3c,
+	0xa012,
+	0xa121,
+	0xa270,
+	0xa30f,
+	0xa406,
+	0xa52d,
+	0xa673,
+	0xa72f,
+	0xa86a,
+	0xa93c,
+	0xaa12,
+	0xab21,
+	0xac70,
+	0xad0f,
+	0xae06,
+	0xaf2d,
+	0xb073,
+	0xb12f,
+	0xb26a,
+	0xb33c,
+	0xb412,
+	0xb521,
+	0xb670,
+	0xb70f,
+	0xb806,
+	0xb92d,
+	0xba73,
+
+	0xbb80,
+	0xbc00,
+	0xbd80,
+	0xbe00,
+	0xbf35,
+	0xc013,
+	0xc180,
+	0xc200,
+	0xc376,
+	0xc41c,
+	0xc580,
+	0xc600,
+	0xc7ac,
+	0xc81c,
+	0xc980,
+	0xca00,
+	0xcb4c,
+	0xcc20,
+	0xcd80,
+	0xce00,
+	0xcf76,
+	0xd01c,
+	0xd180,
+	0xd200,
+	0xd352,
+	0xd41d,
+
+	0xd580,
+	0xd600,
+	0xd780,
+	0xd800,
+	0xd935,
+	0xda13,
+	0xdb80,
+	0xdc00,
+	0xdd76,
+	0xde1c,
+	0xdf80,
+	0xe000,
+	0xe1ac,
+	0xe21c,
+	0xe380,
+	0xe400,
+	0xe54c,
+	0xe620,
+	0xe780,
+	0xe800,
+	0xe976,
+	0xea1c,
+	0xeb80,
+	0xec00,
+	0xed52,
+	0xee1d,
+
+	0xef80,
+	0xf000,
+	0xf180,
+	0xf200,
+	0xf335,
+	0xf413,
+	0xf580,
+	0xf600,
+	0xf776,
+	0xf81c,
+	0xf980,
+	0xfa00,
+	0xfbac,
+	0xfc1c,
+	0xfd80,
+	0x0e00,
+	0x03d2,
+	0x0e01,
+	0x1000,
+	0x114c,
+	0x1220,
+	0x1380,
+	0x1400,
+	0x1576,
+	0x161c,
+	0x1780,
+	0x1800,
+	0x1952,
+	0x1a1d,
+
+	0x1b80,
+	0x1c00,
+	0x1d70,
+	0x1e04,
+	0x1f36,
+	0x200d,
+	0x21b0,
+	0x2210,
+	0x236b,
+	0x241c,
+	0x2570,
+	0x2600,
+	0x27af,
+	0x281c,
+	0x2980,
+	0x2a87,
+	0x2b51,
+	0x2c1c,
+	0x2db0,
+	0x2e10,
+	0x2f76,
+	0x301c,
+	0x3180,
+	0x3200,
+	0x339a,
+	0x3414,
+
+	0x3580,
+	0x3600,
+	0x3780,
+	0x380a,
+	0x3932,
+	0x3a0f,
+	0x3b90,
+	0x3c14,
+	0x3d6a,
+	0x3e14,
+	0x3f70,
+	0x408e,
+	0x41af,
+	0x421c,
+	0x439a,
+	0x4400,
+	0x4551,
+	0x4618,
+	0x47a9,
+	0x4810,
+	0x497c,
+	0x4a18,
+	0x4ba0,
+	0x4c00,
+	0x4d99,
+	0x4e1e,
+
+	0x4f80,
+	0x5000,
+	0x5178,
+	0x5208,
+	0x5332,
+	0x540f,
+	0x5590,
+	0x560a,
+	0x576a,
+	0x5814,
+	0x5970,
+	0x5a88,
+	0x5baf,
+	0x5c1c,
+	0x5d9a,
+	0x5e00,
+	0x5f4b,
+	0x6018,
+	0x6190,
+	0x6210,
+	0x637c,
+	0x6418,
+	0x65a0,
+	0x6600,
+	0x6799,
+	0x681e,
+
+	0x6980,
+	0x6a00,
+	0x6b60,
+	0x6c08,
+	0x6d34,
+	0x6e0c,
+	0x6f93,
+	0x7010,
+	0x715e,
+	0x7214,
+	0x73a0,
+	0x7488,
+	0x75af,
+	0x7628,
+	0x7780,
+	0x788a,
+	0x7948,
+	0x7a14,
+	0x7b80,
+	0x7c0c,
+	0x7d72,
+	0x7e14,
+	0x7f80,
+	0x8000,
+	0x819a,
+	0x8214,
+
+	0x8380,
+	0x8400,
+	0x8560,
+	0x8608,
+	0x8734,
+	0x880c,
+	0x8993,
+	0x8a10,
+	0x8b5e,
+	0x8c14,
+	0x8da0,
+	0x8e88,
+	0x8faf,
+	0x9028,
+	0x9180,
+	0x928a,
+	0x9348,
+	0x9414,
+	0x9580,
+	0x960c,
+	0x9772,
+	0x9814,
+	0x9980,
+	0x9a00,
+	0x9b9a,
+	0x9c14,
+
+	0x9d80,
+	0x9e00,
+	0x9f60,
+	0xa008,
+	0xa134,
+	0xa20c,
+	0xa393,
+	0xa410,
+	0xa55e,
+	0xa614,
+	0xa7a0,
+	0xa888,
+	0xa9af,
+	0xaa28,
+	0xab80,
+	0xac8a,
+	0xad48,
+	0xae14,
+	0xaf80,
+	0xb00c,
+	0xb172,
+	0xb214,
+	0xb380,
+	0xb400,
+	0xb59a,
+	0xb614,
+
+	0xb780,
+	0xb800,
+	0xb960,
+	0xba08,
+	0xbb34,
+	0xbc0c,
+	0xbd93,
+	0xbe10,
+	0xbf5e,
+	0xc014,
+	0xc1a0,
+	0xc288,
+	0xc3af,
+	0xc428,
+	0xc580,
+	0xc68a,
+	0xc748,
+	0xc814,
+	0xc980,
+	0xca0c,
+	0xcb72,
+	0xcc14,
+	0xcd80,
+	0xce00,
+	0xcf9a,
+	0xd014,
+
+	0xd180,
+	0xd200,
+	0xd360,
+	0xd408,
+	0xd534,
+	0xd60c,
+	0xd793,
+	0xd810,
+	0xd95e,
+	0xda14,
+	0xdba0,
+	0xdc88,
+	0xddaf,
+	0xde28,
+	0xdf80,
+	0xe08a,
+	0xe148,
+	0xe214,
+	0xe380,
+	0xe40c,
+	0xe572,
+	0xe614,
+	0xe780,
+	0xe800,
+	0xe99a,
+	0xea14,
+
+	0xeb80,
+	0xec00,
+	0xed60,
+	0xee08,
+	0xef34,
+	0xf00c,
+	0xf193,
+	0xf210,
+	0xf35e,
+	0xf414,
+	0xf5a0,
+	0xf688,
+	0xf7af,
+	0xf828,
+	0xf980,
+	0xfa8a,
+	0xfb48,
+	0xfc14,
+	0xfd80,
+	0x0e00,
+	0x03d3,
+	0x0e01,
+	0x100c,
+	0x1172,
+	0x1214,
+	0x1380,
+	0x1400,
+	0x159a,
+	0x1614,
+
+	0x1700,
+	0x1800,
+	0x1900,
+	0x1a00,
+	0x1b5c,
+	0x1c60,
+	0x1d60,
+	0x1e5c,
+	0x1f00,
+	0x2000,
+	0x2100,
+	0x2200,
+	0x235c,
+	0x2460,
+	0x2560,
+	0x265c,
+	0x2700,
+	0x2800,
+	0x2900,
+	0x2a00,
+	0x2b5c,
+	0x2c60,
+	0x2d60,
+	0x2e5c,
+	0x2f00,
+	0x3000,
+	0x3100,
+	0x3200,
+	0x3380,
+	0x3480,
+	0x3576,
+	0x3680,
+	0x3700,
+	0x3800,
+	0x3900,
+	0x3a00,
+	0x3b80,
+	0x3c80,
+	0x3d76,
+	0x3e80,
+	0x3f00,
+	0x4000,
+	0x4100,
+	0x4200,
+	0x4380,
+	0x4480,
+	0x4576,
+	0x4680,
+	0x4700,
+	0x4800,
+	0x4900,
+	0x4a00,
+	0x4b80,
+	0x4c80,
+	0x4d80,
+	0x4e80,
+	0x4f00,
+	0x5000,
+	0x5100,
+	0x5200,
+	0x5380,
+	0x5480,
+	0x5580,
+	0x5680,
+	0x5700,
+	0x5800,
+	0x5900,
+	0x5a00,
+	0x5b80,
+	0x5c80,
+	0x5d80,
+	0x5e80,
+	0x5f00,
+	0x6000,
+	0x6100,
+	0x6200,
+	0x6380,
+	0x6480,
+	0x6580,
+	0x6680,
+	0x6700,
+	0x6800,
+	0x6900,
+	0x6a00,
+	0x6b80,
+	0x6c80,
+	0x6d80,
+	0x6e80,
+	0x6f00,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7380,
+	0x7480,
+	0x7580,
+	0x7680,
+
+	0x7760,
+	0x7820,
+	0x7960,
+	0x7a40,
+	0x7b20,
+
+	0x7c00,
+	0x7d02,
+	0x7e0f,
+	0x7f58,
+	0x8000,
+	0x8100,
+	0x82c3,
+	0x8350,
+	0x8478,
+	0x8562,
+	0x8608,
+	0x8702,
+	0x8800,
+	0x8900,
+	0x8a00,
+	0x8b00,
+	0x8c80,
+	0x8d80,
+	0x8e80,
+	0x8f80,
+	0x9050,
+	0x9150,
+	0x0e00,
+
+	0x03d9,
+	0x0e01,
+	0x1003,
+	0x1110,
+	0x1261,
+	0x1380,
+	0x1462,
+	0x1580,
+	0x1640,
+	0x1700,
+	0x1848,
+	0x1980,
+	0x1a03,
+	0x1b16,
+	0x1c30,
+	0x1d7f,
+	0x1e31,
+	0x1f42,
+	0x2032,
+	0x2103,
+	0x2233,
+	0x2322,
+	0x2434,
+	0x257b,
+	0x2635,
+	0x2719,
+	0x2836,
+	0x2901,
+	0x2a37,
+	0x2b43,
+	0x2c38,
+	0x2d84,
+	0x2e70,
+	0x2f80,
+	0x3071,
+	0x3100,
+	0x3272,
+	0x339b,
+	0x3473,
+	0x3505,
+	0x3674,
+	0x3734,
+	0x3875,
+	0x391e,
+	0x3a76,
+	0x3ba6,
+	0x3c77,
+	0x3d10,
+	0x3e78,
+	0x3f69,
+	0x4079,
+	0x411e,
+	0x427a,
+	0x4380,
+	0x447b,
+	0x4580,
+	0x467c,
+	0x47ad,
+	0x487d,
+	0x491e,
+	0x4a7e,
+	0x4b98,
+	0x4c7f,
+	0x4d80,
+	0x4e80,
+	0x4f51,
+	0x5081,
+	0x511e,
+	0x5282,
+	0x5380,
+	0x5483,
+	0x550c,
+	0x5684,
+	0x5723,
+	0x5885,
+	0x591e,
+	0x5a86,
+	0x5bb3,
+	0x5c87,
+	0x5d8a,
+	0x5e88,
+	0x5f52,
+	0x6089,
+	0x611e,
+	0x6203,
+	0x6317,
+	0x6420,
+	0x6500,
+	0x6621,
+	0x6702,
+	0x6822,
+	0x6904,
+	0x6a23,
+	0x6b09,
+	0x6c24,
+	0x6d12,
+	0x6e25,
+	0x6f23,
+	0x7026,
+	0x7137,
+	0x7227,
+	0x7347,
+	0x7428,
+	0x7557,
+	0x7629,
+	0x7761,
+	0x782a,
+	0x796b,
+	0x7a2b,
+	0x7b71,
+	0x7c2c,
+	0x7d76,
+	0x7e2d,
+	0x7f7a,
+	0x802e,
+	0x817f,
+	0x822f,
+	0x8384,
+	0x8430,
+	0x8588,
+	0x8631,
+	0x878c,
+	0x8832,
+	0x8991,
+	0x8a33,
+	0x8b94,
+	0x8c34,
+	0x8d98,
+	0x8e35,
+	0x8f9f,
+	0x9036,
+	0x91a6,
+	0x9237,
+	0x93ae,
+	0x9438,
+	0x95bb,
+	0x9639,
+	0x97c9,
+	0x983a,
+	0x99d3,
+	0x9a3b,
+	0x9bdc,
+	0x9c3c,
+	0x9de2,
+	0x9e3d,
+	0x9fe8,
+	0xa03e,
+	0xa1ed,
+	0xa23f,
+	0xa3f4,
+	0xa440,
+	0xa5fa,
+	0xa641,
+	0xa7ff,
+	0xa803,
+	0xa920,
+	0xaa39,
+	0xab40,
+	0xac03,
+	0xad15,
+	0xae24,
+	0xaf00,
+	0xb025,
+	0xb100,
+	0xb226,
+	0xb300,
+	0xb427,
+	0xb500,
+	0xb628,
+	0xb780,
+	0xb829,
+	0xb980,
+	0xba2a,
+	0xbb80,
+	0xbc2b,
+	0xbd80,
+	0xbe11,
+	0xbf40,
+	0x0e00,
+
+	0x03da,
+	0x0e01,
+	0x1003,
+	0x1111,
+	0x1210,
+	0x1313,
+	0x1411,
+	0x1525,
+	0x1612,
+	0x1722,
+	0x1813,
+	0x1911,
+	0x1a14,
+	0x1b21,
+	0x1c30,
+	0x1d20,
+	0x1e31,
+	0x1f20,
+	0x2032,
+	0x2170,
+	0x2233,
+	0x234a,
+	0x2434,
+	0x252a,
+	0x2635,
+	0x272b,
+	0x2836,
+	0x2916,
+	0x2a37,
+	0x2b1b,
+	0x2c38,
+	0x2d14,
+	0x2e39,
+	0x2f10,
+	0x303a,
+	0x3110,
+	0x323b,
+	0x332c,
+	0x343c,
+	0x3560,
+	0x363d,
+	0x3738,
+	0x383e,
+	0x3968,
+	0x3a3f,
+	0x3b68,
+	0x3c40,
+	0x3d68,
+	0x3e41,
+	0x3f1a,
+	0x4042,
+	0x411a,
+	0x4243,
+	0x431a,
+	0x4444,
+	0x4530,
+	0x4645,
+	0x4730,
+	0x4846,
+	0x4940,
+	0x4a47,
+	0x4b40,
+	0x4c48,
+	0x4d40,
+	0x4e49,
+	0x4ff0,
+	0x504a,
+	0x51f0,
+	0x524b,
+	0x53f0,
+	0x544c,
+	0x55f0,
+	0x564d,
+	0x57f0,
+	0x584e,
+	0x59f0,
+	0x5a4f,
+	0x5bf0,
+	0x5c50,
+	0x5df0,
+	0x5e51,
+	0x5f60,
+	0x6052,
+	0x6160,
+	0x6253,
+	0x6360,
+	0x6454,
+	0x6560,
+	0x6655,
+	0x6760,
+	0x6856,
+	0x6960,
+	0x6a57,
+	0x6b60,
+	0x6c58,
+	0x6d60,
+	0x6e59,
+	0x6f80,
+	0x705a,
+	0x7180,
+	0x725b,
+	0x7380,
+	0x745c,
+	0x7580,
+	0x765d,
+	0x7780,
+	0x785e,
+	0x7980,
+	0x7a5f,
+	0x7b80,
+	0x7c60,
+	0x7d80,
+	0x7e61,
+	0x7ff0,
+	0x8062,
+	0x81fc,
+	0x8263,
+	0x8360,
+	0x8464,
+	0x8520,
+	0x8665,
+	0x8724,
+	0x8866,
+	0x8924,
+	0x8a67,
+	0x8b1a,
+	0x8c68,
+	0x8d5a,
+	0x8e69,
+	0x8f24,
+	0x906a,
+	0x9124,
+	0x926b,
+	0x9324,
+	0x946c,
+	0x951a,
+	0x966d,
+	0x975c,
+	0x986e,
+	0x9920,
+	0x9a6f,
+	0x9b26,
+	0x9c70,
+	0x9d26,
+	0x9e71,
+	0x9f30,
+	0xa072,
+	0xa15c,
+	0xa273,
+	0xa320,
+	0xa474,
+	0xa590,
+	0xa675,
+	0xa790,
+	0xa876,
+	0xa980,
+	0xaa77,
+	0xab40,
+	0xac78,
+	0xad26,
+	0xae79,
+	0xaf90,
+	0xb07a,
+	0xb190,
+	0xb27b,
+	0xb380,
+	0xb47c,
+	0xb538,
+	0xb67d,
+	0xb71c,
+	0xb87e,
+	0xb968,
+	0xba7f,
+	0xbb58,
+	0xbc80,
+	0xbd48,
+	0xbe81,
+	0xbf32,
+	0xc082,
+	0xc110,
+	0xc283,
+	0xc368,
+	0xc484,
+	0xc558,
+	0xc685,
+	0xc748,
+	0xc886,
+	0xc91c,
+	0xca87,
+	0xcb08,
+	0xcc88,
+	0xcd64,
+	0xce89,
+	0xcf64,
+	0xd08a,
+	0xd148,
+	0xd290,
+	0xd302,
+	0xd491,
+	0xd548,
+	0xd692,
+	0xd700,
+	0xd893,
+	0xd904,
+	0xda94,
+	0xdb02,
+	0xdc95,
+	0xdd64,
+	0xde96,
+	0xdf14,
+	0xe097,
+	0xe190,
+	0xe2b0,
+	0xe360,
+	0xe4b1,
+	0xe590,
+	0xe6b2,
+	0xe710,
+	0xe8b3,
+	0xe908,
+	0xeab4,
+	0xeb04,
+	0xec03,
+	0xed12,
+	0xee10,
+	0xef03,
+	0xf011,
+	0xf129,
+	0xf212,
+	0xf330,
+	0xf440,
+	0xf537,
+	0xf641,
+	0xf724,
+	0xf842,
+	0xf900,
+	0xfa43,
+	0xfb62,
+	0xfc44,
+	0xfd02,
+	0x0e00,
+	0x03db,
+	0x0e01,
+	0x1045,
+	0x110a,
+	0x1246,
+	0x1340,
+	0x1460,
+	0x1502,
+	0x1661,
+	0x1704,
+	0x1862,
+	0x194b,
+	0x1a63,
+	0x1b41,
+	0x1c64,
+	0x1d14,
+	0x1e65,
+	0x1f00,
+	0x2068,
+	0x210a,
+	0x2269,
+	0x2304,
+	0x246a,
+	0x250a,
+	0x266b,
+	0x270a,
+	0x286c,
+	0x2924,
+	0x2a6d,
+	0x2b01,
+	0x2c70,
+	0x2d01,
+	0x2e71,
+	0x2f3d,
+	0x3080,
+	0x3180,
+	0x3281,
+	0x338a,
+	0x3482,
+	0x350a,
+	0x3683,
+	0x3712,
+	0x3884,
+	0x39c8,
+	0x3a85,
+	0x3b92,
+	0x3c86,
+	0x3d20,
+	0x3e87,
+	0x3f00,
+	0x4088,
+	0x4170,
+	0x4289,
+	0x43aa,
+	0x448a,
+	0x4550,
+	0x468b,
+	0x4710,
+	0x488c,
+	0x4904,
+	0x4a8d,
+	0x4b02,
+	0x4ce6,
+	0x4dff,
+	0x4ee7,
+	0x4f18,
+	0x50e8,
+	0x5120,
+	0x52e9,
+	0x5304,
+	0x5403,
+	0x5513,
+	0x5610,
+	0x573f,
+	0x5820,
+	0x5920,
+	0x5a21,
+	0x5b30,
+	0x5c22,
+	0x5d36,
+	0x5e23,
+	0x5f6a,
+	0x6024,
+	0x61a0,
+	0x6225,
+	0x63c0,
+	0x6426,
+	0x65e0,
+	0x6627,
+	0x670a,
+	0x6828,
+	0x690a,
+	0x6a29,
+	0x6b0a,
+	0x6c2a,
+	0x6d08,
+	0x6e2b,
+	0x6f06,
+	0x702c,
+	0x7105,
+	0x722d,
+	0x7304,
+	0x742e,
+	0x7503,
+	0x762f,
+	0x7701,
+	0x7830,
+	0x7902,
+	0x7a31,
+	0x7b78,
+	0x7c32,
+	0x7d01,
+	0x7e33,
+	0x7f80,
+	0x8034,
+	0x81f0,
+	0x8235,
+	0x8310,
+	0x8436,
+	0x85f0,
+	0x86a0,
+	0x8707,
+	0x88a8,
+	0x8924,
+	0x8aa9,
+	0x8b24,
+	0x8caa,
+	0x8d20,
+	0x8eab,
+	0x8f02,
+	0x90c0,
+	0x9127,
+	0x92c2,
+	0x9308,
+	0x94c3,
+	0x9508,
+	0x96c4,
+	0x9740,
+	0x98c5,
+	0x9978,
+	0x9ac6,
+	0x9bf0,
+	0x9cc7,
+	0x9d10,
+	0x9ec8,
+	0x9f44,
+	0xa0c9,
+	0xa187,
+	0xa2ca,
+	0xa3ff,
+	0xa4cb,
+	0xa520,
+	0xa6cc,
+	0xa761,
+	0xa8cd,
+	0xa987,
+	0xaace,
+	0xab8a,
+	0xaccf,
+	0xada5,
+	0xae03,
+	0xaf14,
+	0xb011,
+	0xb102,
+	0xb211,
+	0xb302,
+	0xb412,
+	0xb560,
+	0xb613,
+	0xb762,
+	0xb814,
+	0xb920,
+	0xba15,
+	0xbb30,
+	0xbc16,
+	0xbd30,
+	0xbe17,
+	0xbf30,
+	0xc018,
+	0xc154,
+	0xc219,
+	0xc354,
+	0xc41a,
+	0xc540,
+	0xc620,
+	0xc7d2,
+	0xc821,
+	0xc903,
+	0xca22,
+	0xcb04,
+	0xcc23,
+	0xcd04,
+	0xce24,
+	0xcf05,
+	0xd025,
+	0xd132,
+	0xd226,
+	0xd330,
+	0xd427,
+	0xd520,
+	0xd628,
+	0xd73c,
+	0xd829,
+	0xd900,
+	0xda2a,
+	0xdb16,
+	0xdc2b,
+	0xdd16,
+	0xde2c,
+	0xdf16,
+	0xe02d,
+	0xe154,
+	0xe22e,
+	0xe354,
+	0xe42f,
+	0xe554,
+	0xe630,
+	0xe782,
+	0xe831,
+	0xe902,
+	0xea32,
+	0xeb04,
+	0xec33,
+	0xed04,
+	0xee34,
+	0xef0a,
+	0xf035,
+	0xf146,
+	0xf236,
+	0xf332,
+	0xf437,
+	0xf528,
+	0xf638,
+	0xf712,
+	0xf839,
+	0xf900,
+	0xfa3a,
+	0xfb24,
+	0xfc3b,
+	0xfd24,
+	0x0e00,
+	0x03dc,
+	0x0e01,
+	0x103c,
+	0x1124,
+	0x123d,
+	0x1324,
+	0x143e,
+	0x1524,
+	0x163f,
+	0x1714,
+	0x1840,
+	0x1982,
+	0x1a41,
+	0x1b1a,
+	0x1c42,
+	0x1d70,
+	0x1e43,
+	0x1f20,
+	0x2044,
+	0x2126,
+	0x2245,
+	0x231e,
+	0x2446,
+	0x2524,
+	0x2647,
+	0x2718,
+	0x2848,
+	0x290a,
+	0x2a49,
+	0x2b10,
+	0x2c50,
+	0x2d82,
+	0x2e51,
+	0x2f38,
+	0x3052,
+	0x31f0,
+	0x3253,
+	0x3378,
+	0x3454,
+	0x3524,
+	0x3655,
+	0x3724,
+	0x3856,
+	0x3924,
+	0x3a57,
+	0x3b10,
+	0x3c58,
+	0x3d14,
+	0x3e59,
+	0x3f10,
+	0x4060,
+	0x4101,
+	0x4261,
+	0x43a0,
+	0x4462,
+	0x4598,
+	0x4663,
+	0x47e4,
+	0x4864,
+	0x49a4,
+	0x4a65,
+	0x4b7d,
+	0x4c66,
+	0x4d4b,
+	0x4e70,
+	0x4f10,
+	0x5071,
+	0x5110,
+	0x5272,
+	0x5310,
+	0x5473,
+	0x5510,
+	0x5674,
+	0x5710,
+	0x5875,
+	0x5910,
+	0x5a76,
+	0x5b38,
+	0x5c77,
+	0x5d38,
+	0x5e78,
+	0x5f38,
+	0x6079,
+	0x6158,
+	0x627a,
+	0x6358,
+	0x647b,
+	0x6558,
+	0x6603,
+	0x6710,
+	0x6860,
+	0x6903,
+	0x6a70,
+	0x6b0c,
+	0x6c71,
+	0x6d00,
+	0x6e72,
+	0x6f7a,
+	0x7073,
+	0x7128,
+	0x7274,
+	0x7314,
+	0x7475,
+	0x750d,
+	0x7676,
+	0x7740,
+	0x7877,
+	0x7949,
+	0x7a78,
+	0x7b99,
+	0x7c79,
+	0x7d4c,
+	0x7e7a,
+	0x7fcc,
+	0x807b,
+	0x8149,
+	0x827c,
+	0x8399,
+	0x847d,
+	0x8514,
+	0x867e,
+	0x8728,
+	0x887f,
+	0x8950,
+	0x8a03,
+	0x8b16,
+	0x8c8a,
+	0x8d68,
+	0x8e8b,
+	0x8f7c,
+	0x908c,
+	0x917f,
+	0x928d,
+	0x937f,
+	0x948e,
+	0x957f,
+	0x968f,
+	0x977f,
+	0x9890,
+	0x997f,
+	0x9a91,
+	0x9b7f,
+	0x9c92,
+	0x9d7f,
+	0x0e00,
+
+	0x03dd,
+	0x0e01,
+	0x1003,
+	0x1111,
+	0x1210,
+	0x1313,
+	0x1411,
+	0x1508,
+	0x1612,
+	0x171e,
+	0x1813,
+	0x190e,
+	0x1a14,
+	0x1b31,
+	0x1c30,
+	0x1d20,
+	0x1e31,
+	0x1f20,
+	0x2032,
+	0x2152,
+	0x2233,
+	0x233b,
+	0x2434,
+	0x251d,
+	0x2635,
+	0x2721,
+	0x2836,
+	0x291b,
+	0x2a37,
+	0x2b21,
+	0x2c38,
+	0x2d18,
+	0x2e39,
+	0x2f18,
+	0x303a,
+	0x3118,
+	0x323b,
+	0x3318,
+	0x343c,
+	0x351a,
+	0x363d,
+	0x371a,
+	0x383e,
+	0x3920,
+	0x3a3f,
+	0x3b22,
+	0x3c40,
+	0x3d20,
+	0x3e41,
+	0x3f10,
+	0x4042,
+	0x4110,
+	0x4243,
+	0x4310,
+	0x4444,
+	0x4510,
+	0x4645,
+	0x4718,
+	0x4846,
+	0x4918,
+	0x4a47,
+	0x4b40,
+	0x4c48,
+	0x4d40,
+	0x4e49,
+	0x4fe0,
+	0x504a,
+	0x51f0,
+	0x524b,
+	0x53fc,
+	0x544c,
+	0x55fc,
+	0x564d,
+	0x57fc,
+	0x584e,
+	0x59f0,
+	0x5a4f,
+	0x5bf0,
+	0x5c50,
+	0x5df0,
+	0x5e51,
+	0x5f68,
+	0x6052,
+	0x6168,
+	0x6253,
+	0x6368,
+	0x6454,
+	0x6568,
+	0x6655,
+	0x6768,
+	0x6856,
+	0x6968,
+	0x6a57,
+	0x6b68,
+	0x6c58,
+	0x6d68,
+	0x6e59,
+	0x6f70,
+	0x705a,
+	0x7170,
+	0x725b,
+	0x7370,
+	0x745c,
+	0x7570,
+	0x765d,
+	0x7770,
+	0x785e,
+	0x7970,
+	0x7a5f,
+	0x7b70,
+	0x7c60,
+	0x7d70,
+	0x7e61,
+	0x7fc0,
+	0x8062,
+	0x81f0,
+	0x8263,
+	0x8380,
+	0x8464,
+	0x8540,
+	0x8665,
+	0x8780,
+	0x8866,
+	0x8980,
+	0x8a67,
+	0x8b80,
+	0x8c68,
+	0x8d80,
+	0x8e69,
+	0x8f40,
+	0x906a,
+	0x9180,
+	0x926b,
+	0x9380,
+	0x946c,
+	0x9580,
+	0x966d,
+	0x9780,
+	0x986e,
+	0x9940,
+	0x9a6f,
+	0x9b80,
+	0x9c70,
+	0x9d60,
+	0x9e71,
+	0x9f40,
+	0xa072,
+	0xa16e,
+	0xa273,
+	0xa33a,
+	0xa474,
+	0xa580,
+	0xa675,
+	0xa780,
+	0xa876,
+	0xa940,
+	0xaa77,
+	0xab6e,
+	0xac78,
+	0xad66,
+	0xae79,
+	0xaf60,
+	0xb07a,
+	0xb130,
+	0xb27b,
+	0xb320,
+	0xb47c,
+	0xb55c,
+	0xb67d,
+	0xb730,
+	0xb87e,
+	0xb960,
+	0xba7f,
+	0xbb60,
+	0xbc80,
+	0xbd20,
+	0xbe81,
+	0xbf62,
+	0xc082,
+	0xc126,
+	0xc283,
+	0xc360,
+	0xc484,
+	0xc560,
+	0xc685,
+	0xc760,
+	0xc886,
+	0xc962,
+	0xca87,
+	0xcb26,
+	0xcc88,
+	0xcd60,
+	0xce89,
+	0xcf60,
+	0xd08a,
+	0xd160,
+	0xd290,
+	0xd300,
+	0xd491,
+	0xd54e,
+	0xd692,
+	0xd700,
+	0xd893,
+	0xd916,
+	0xda94,
+	0xdb01,
+	0xdc95,
+	0xdd80,
+	0xde96,
+	0xdf55,
+	0xe097,
+	0xe18d,
+	0xe2b0,
+	0xe360,
+	0xe4b1,
+	0xe5b0,
+	0xe6b2,
+	0xe788,
+	0xe8b3,
+	0xe910,
+	0xeab4,
+	0xeb04,
+	0xec03,
+	0xed12,
+	0xee10,
+	0xef03,
+	0xf011,
+	0xf129,
+	0xf212,
+	0xf308,
+	0xf440,
+	0xf533,
+	0xf641,
+	0xf70a,
+	0xf842,
+	0xf96a,
+	0xfa43,
+	0xfb80,
+	0xfc44,
+	0xfd02,
+	0x0e00,
+	0x03de,
+	0x0e01,
+	0x1045,
+	0x110a,
+	0x1246,
+	0x1380,
+	0x1460,
+	0x1521,
+	0x1661,
+	0x170e,
+	0x1862,
+	0x1970,
+	0x1a63,
+	0x1b70,
+	0x1c64,
+	0x1d14,
+	0x1e65,
+	0x1f01,
+	0x2068,
+	0x210a,
+	0x2269,
+	0x2304,
+	0x246a,
+	0x250a,
+	0x266b,
+	0x270a,
+	0x286c,
+	0x2924,
+	0x2a6d,
+	0x2b01,
+	0x2c70,
+	0x2d01,
+	0x2e71,
+	0x2f3d,
+	0x3080,
+	0x3180,
+	0x3281,
+	0x3388,
+	0x3482,
+	0x3508,
+	0x3683,
+	0x370c,
+	0x3884,
+	0x3990,
+	0x3a85,
+	0x3b92,
+	0x3c86,
+	0x3d20,
+	0x3e87,
+	0x3f00,
+	0x4088,
+	0x4170,
+	0x4289,
+	0x43aa,
+	0x448a,
+	0x4550,
+	0x468b,
+	0x4710,
+	0x488c,
+	0x4904,
+	0x4a8d,
+	0x4b02,
+	0x4ce6,
+	0x4dff,
+	0x4ee7,
+	0x4f18,
+	0x50e8,
+	0x5120,
+	0x52e9,
+	0x5306,
+	0x5403,
+	0x5513,
+	0x5610,
+	0x5733,
+	0x5820,
+	0x5920,
+	0x5a21,
+	0x5b30,
+	0x5c22,
+	0x5d36,
+	0x5e23,
+	0x5f6a,
+	0x6024,
+	0x61a0,
+	0x6225,
+	0x63c0,
+	0x6426,
+	0x65e0,
+	0x6627,
+	0x6702,
+	0x6828,
+	0x6903,
+	0x6a29,
+	0x6b03,
+	0x6c2a,
+	0x6d10,
+	0x6e2b,
+	0x6f10,
+	0x702c,
+	0x7104,
+	0x722d,
+	0x7303,
+	0x742e,
+	0x7503,
+	0x762f,
+	0x7718,
+	0x7830,
+	0x7903,
+	0x7a31,
+	0x7b03,
+	0x7c32,
+	0x7d03,
+	0x7e33,
+	0x7f40,
+	0x8034,
+	0x8180,
+	0x8235,
+	0x8300,
+	0x8436,
+	0x85f0,
+	0x86a0,
+	0x8707,
+	0x88a8,
+	0x8924,
+	0x8aa9,
+	0x8b24,
+	0x8caa,
+	0x8d20,
+	0x8eab,
+	0x8f02,
+	0x90c0,
+	0x9127,
+	0x92c2,
+	0x9308,
+	0x94c3,
+	0x9508,
+	0x96c4,
+	0x9740,
+	0x98c5,
+	0x9938,
+	0x9ac6,
+	0x9bf0,
+	0x9cc7,
+	0x9d10,
+	0x9ec8,
+	0x9f44,
+	0xa0c9,
+	0xa187,
+	0xa2ca,
+	0xa3ff,
+	0xa4cb,
+	0xa520,
+	0xa6cc,
+	0xa761,
+	0xa8cd,
+	0xa987,
+	0xaace,
+	0xab8a,
+	0xaccf,
+	0xada5,
+	0xae03,
+	0xaf14,
+	0xb011,
+	0xb102,
+	0xb211,
+	0xb302,
+	0xb412,
+	0xb540,
+	0xb613,
+	0xb798,
+	0xb814,
+	0xb93a,
+	0xba15,
+	0xbb30,
+	0xbc16,
+	0xbd30,
+	0xbe17,
+	0xbf30,
+	0xc018,
+	0xc158,
+	0xc219,
+	0xc360,
+	0xc41a,
+	0xc560,
+	0xc620,
+	0xc782,
+	0xc821,
+	0xc903,
+	0xca22,
+	0xcb05,
+	0xcc23,
+	0xcd07,
+	0xce24,
+	0xcf0a,
+	0xd025,
+	0xd146,
+	0xd226,
+	0xd332,
+	0xd427,
+	0xd51e,
+	0xd628,
+	0xd710,
+	0xd829,
+	0xd900,
+	0xda2a,
+	0xdb18,
+	0xdc2b,
+	0xdd18,
+	0xde2c,
+	0xdf18,
+	0xe02d,
+	0xe130,
+	0xe22e,
+	0xe330,
+	0xe42f,
+	0xe530,
+	0xe630,
+	0xe782,
+	0xe831,
+	0xe902,
+	0xea32,
+	0xeb04,
+	0xec33,
+	0xed04,
+	0xee34,
+	0xef0a,
+	0xf035,
+	0xf146,
+	0xf236,
+	0xf332,
+	0xf437,
+	0xf528,
+	0xf638,
+	0xf712,
+	0xf839,
+	0xf900,
+	0xfa3a,
+	0xfb20,
+	0xfc3b,
+	0xfd30,
+	0x0e00,
+	0x03df,
+	0x0e01,
+	0x103c,
+	0x1120,
+	0x123d,
+	0x1318,
+	0x143e,
+	0x1528,
+	0x163f,
+	0x1714,
+	0x1840,
+	0x1984,
+	0x1a41,
+	0x1b10,
+	0x1c42,
+	0x1d70,
+	0x1e43,
+	0x1f20,
+	0x2044,
+	0x2118,
+	0x2245,
+	0x2318,
+	0x2446,
+	0x2510,
+	0x2647,
+	0x2718,
+	0x2848,
+	0x290a,
+	0x2a49,
+	0x2b10,
+	0x2c50,
+	0x2d84,
+	0x2e51,
+	0x2f30,
+	0x3052,
+	0x31b0,
+	0x3253,
+	0x3337,
+	0x3454,
+	0x3533,
+	0x3655,
+	0x3733,
+	0x3856,
+	0x3933,
+	0x3a57,
+	0x3b10,
+	0x3c58,
+	0x3d20,
+	0x3e59,
+	0x3f20,
+	0x4060,
+	0x4101,
+	0x4261,
+	0x43a0,
+	0x4462,
+	0x4598,
+	0x4663,
+	0x47e4,
+	0x4864,
+	0x49a4,
+	0x4a65,
+	0x4b7d,
+	0x4c66,
+	0x4d4b,
+	0x4e70,
+	0x4f10,
+	0x5071,
+	0x5110,
+	0x5272,
+	0x5310,
+	0x5473,
+	0x5510,
+	0x5674,
+	0x5710,
+	0x5875,
+	0x5910,
+	0x5a76,
+	0x5b38,
+	0x5c77,
+	0x5d38,
+	0x5e78,
+	0x5f38,
+	0x6079,
+	0x6170,
+	0x627a,
+	0x6370,
+	0x647b,
+	0x6570,
+	0x6603,
+	0x6710,
+	0x6860,
+	0x6903,
+	0x6a70,
+	0x6b0c,
+	0x6c71,
+	0x6d00,
+	0x6e72,
+	0x6f83,
+	0x7073,
+	0x7199,
+	0x7274,
+	0x731b,
+	0x7475,
+	0x750b,
+	0x7676,
+	0x773c,
+	0x7877,
+	0x7943,
+	0x7a78,
+	0x7b33,
+	0x7c79,
+	0x7d4c,
+	0x7e7a,
+	0x7fcc,
+	0x807b,
+	0x8149,
+	0x827c,
+	0x8399,
+	0x847d,
+	0x850e,
+	0x867e,
+	0x871e,
+	0x887f,
+	0x893c,
+	0x8a03,
+	0x8b16,
+	0x8c8a,
+	0x8d68,
+	0x8e8b,
+	0x8f7c,
+	0x908c,
+	0x917f,
+	0x928d,
+	0x937f,
+	0x948e,
+	0x957f,
+	0x968f,
+	0x977f,
+	0x9890,
+	0x997f,
+	0x9a91,
+	0x9b7f,
+	0x9c92,
+	0x9d7f,
+	0x0e00,
+
+	0x03e0,
+	0x0e01,
+	0x1003,
+	0x1111,
+	0x1210,
+	0x1313,
+	0x1411,
+	0x1508,
+	0x1612,
+	0x171e,
+	0x1813,
+	0x190e,
+	0x1a14,
+	0x1b31,
+	0x1c30,
+	0x1d20,
+	0x1e31,
+	0x1f20,
+	0x2032,
+	0x2152,
+	0x2233,
+	0x233b,
+	0x2434,
+	0x251d,
+	0x2635,
+	0x2721,
+	0x2836,
+	0x291b,
+	0x2a37,
+	0x2b21,
+	0x2c38,
+	0x2d18,
+	0x2e39,
+	0x2f18,
+	0x303a,
+	0x3120,
+	0x323b,
+	0x3328,
+	0x343c,
+	0x3520,
+	0x363d,
+	0x3720,
+	0x383e,
+	0x391e,
+	0x3a3f,
+	0x3b1e,
+	0x3c40,
+	0x3d1e,
+	0x3e41,
+	0x3f10,
+	0x4042,
+	0x4110,
+	0x4243,
+	0x4320,
+	0x4444,
+	0x452a,
+	0x4645,
+	0x4730,
+	0x4846,
+	0x4950,
+	0x4a47,
+	0x4b40,
+	0x4c48,
+	0x4d40,
+	0x4e49,
+	0x4f60,
+	0x504a,
+	0x5180,
+	0x524b,
+	0x53a0,
+	0x544c,
+	0x55a0,
+	0x564d,
+	0x57a0,
+	0x584e,
+	0x5990,
+	0x5a4f,
+	0x5b90,
+	0x5c50,
+	0x5d90,
+	0x5e51,
+	0x5f68,
+	0x6052,
+	0x6168,
+	0x6253,
+	0x6368,
+	0x6454,
+	0x6568,
+	0x6655,
+	0x6768,
+	0x6856,
+	0x6968,
+	0x6a57,
+	0x6b68,
+	0x6c58,
+	0x6d68,
+	0x6e59,
+	0x6f70,
+	0x705a,
+	0x7170,
+	0x725b,
+	0x7370,
+	0x745c,
+	0x7570,
+	0x765d,
+	0x7770,
+	0x785e,
+	0x7970,
+	0x7a5f,
+	0x7b70,
+	0x7c60,
+	0x7d70,
+	0x7e61,
+	0x7fc0,
+	0x8062,
+	0x81f0,
+	0x8263,
+	0x8380,
+	0x8464,
+	0x8540,
+	0x8665,
+	0x8740,
+	0x8866,
+	0x8940,
+	0x8a67,
+	0x8b40,
+	0x8c68,
+	0x8d80,
+	0x8e69,
+	0x8f40,
+	0x906a,
+	0x9140,
+	0x926b,
+	0x9340,
+	0x946c,
+	0x9540,
+	0x966d,
+	0x9780,
+	0x986e,
+	0x9940,
+	0x9a6f,
+	0x9b50,
+	0x9c70,
+	0x9d50,
+	0x9e71,
+	0x9f50,
+	0xa072,
+	0xa16e,
+	0xa273,
+	0xa33a,
+	0xa474,
+	0xa550,
+	0xa675,
+	0xa750,
+	0xa876,
+	0xa950,
+	0xaa77,
+	0xab6e,
+	0xac78,
+	0xad66,
+	0xae79,
+	0xaf40,
+	0xb07a,
+	0xb140,
+	0xb27b,
+	0xb340,
+	0xb47c,
+	0xb55c,
+	0xb67d,
+	0xb730,
+	0xb87e,
+	0xb940,
+	0xba7f,
+	0xbb40,
+	0xbc80,
+	0xbd40,
+	0xbe81,
+	0xbf62,
+	0xc082,
+	0xc126,
+	0xc283,
+	0xc340,
+	0xc484,
+	0xc540,
+	0xc685,
+	0xc740,
+	0xc886,
+	0xc962,
+	0xca87,
+	0xcb26,
+	0xcc88,
+	0xcd30,
+	0xce89,
+	0xcf30,
+	0xd08a,
+	0xd130,
+	0xd290,
+	0xd300,
+	0xd491,
+	0xd54e,
+	0xd692,
+	0xd700,
+	0xd893,
+	0xd916,
+	0xda94,
+	0xdb01,
+	0xdc95,
+	0xdd80,
+	0xde96,
+	0xdf55,
+	0xe097,
+	0xe18d,
+	0xe2b0,
+	0xe360,
+	0xe4b1,
+	0xe5b0,
+	0xe6b2,
+	0xe788,
+	0xe8b3,
+	0xe910,
+	0xeab4,
+	0xeb04,
+	0xec03,
+	0xed12,
+	0xee10,
+	0xef03,
+	0xf011,
+	0xf129,
+	0xf212,
+	0xf304,
+	0xf440,
+	0xf533,
+	0xf641,
+	0xf70a,
+	0xf842,
+	0xf96a,
+	0xfa43,
+	0xfb80,
+	0xfc44,
+	0xfd02,
+	0x0e00,
+	0x03e1,
+	0x0e01,
+	0x1045,
+	0x110a,
+	0x1246,
+	0x1380,
+	0x1460,
+	0x1521,
+	0x1661,
+	0x170e,
+	0x1862,
+	0x1970,
+	0x1a63,
+	0x1b70,
+	0x1c64,
+	0x1d14,
+	0x1e65,
+	0x1f01,
+	0x2068,
+	0x210a,
+	0x2269,
+	0x2304,
+	0x246a,
+	0x250a,
+	0x266b,
+	0x270a,
+	0x286c,
+	0x2924,
+	0x2a6d,
+	0x2b01,
+	0x2c70,
+	0x2d01,
+	0x2e71,
+	0x2f3d,
+	0x3080,
+	0x3180,
+	0x3281,
+	0x3388,
+	0x3482,
+	0x3508,
+	0x3683,
+	0x370c,
+	0x3884,
+	0x3990,
+	0x3a85,
+	0x3b92,
+	0x3c86,
+	0x3d20,
+	0x3e87,
+	0x3f00,
+	0x4088,
+	0x4170,
+	0x4289,
+	0x43aa,
+	0x448a,
+	0x4550,
+	0x468b,
+	0x4710,
+	0x488c,
+	0x4904,
+	0x4a8d,
+	0x4b02,
+	0x4ce6,
+	0x4dff,
+	0x4ee7,
+	0x4f18,
+	0x50e8,
+	0x5120,
+	0x52e9,
+	0x5306,
+	0x5403,
+	0x5513,
+	0x5610,
+	0x5731,
+	0x5820,
+	0x5920,
+	0x5a21,
+	0x5b30,
+	0x5c22,
+	0x5d36,
+	0x5e23,
+	0x5f6a,
+	0x6024,
+	0x61a0,
+	0x6225,
+	0x63c0,
+	0x6426,
+	0x65e0,
+	0x6627,
+	0x6702,
+	0x6828,
+	0x6903,
+	0x6a29,
+	0x6b03,
+	0x6c2a,
+	0x6d02,
+	0x6e2b,
+	0x6f04,
+	0x702c,
+	0x7104,
+	0x722d,
+	0x7303,
+	0x742e,
+	0x7503,
+	0x762f,
+	0x7714,
+	0x7830,
+	0x7903,
+	0x7a31,
+	0x7b03,
+	0x7c32,
+	0x7d03,
+	0x7e33,
+	0x7f40,
+	0x8034,
+	0x8180,
+	0x8235,
+	0x8300,
+	0x8436,
+	0x85f0,
+	0x86a0,
+	0x8707,
+	0x88a8,
+	0x8924,
+	0x8aa9,
+	0x8b24,
+	0x8caa,
+	0x8d20,
+	0x8eab,
+	0x8f02,
+	0x90c0,
+	0x9127,
+	0x92c2,
+	0x9308,
+	0x94c3,
+	0x9508,
+	0x96c4,
+	0x9740,
+	0x98c5,
+	0x9938,
+	0x9ac6,
+	0x9bf0,
+	0x9cc7,
+	0x9d10,
+	0x9ec8,
+	0x9f44,
+	0xa0c9,
+	0xa187,
+	0xa2ca,
+	0xa3ff,
+	0xa4cb,
+	0xa520,
+	0xa6cc,
+	0xa761,
+	0xa8cd,
+	0xa987,
+	0xaace,
+	0xab8a,
+	0xaccf,
+	0xada5,
+	0xae03,
+	0xaf14,
+	0xb011,
+	0xb104,
+	0xb211,
+	0xb304,
+	0xb412,
+	0xb540,
+	0xb613,
+	0xb798,
+	0xb814,
+	0xb93a,
+	0xba15,
+	0xbb30,
+	0xbc16,
+	0xbd30,
+	0xbe17,
+	0xbf30,
+	0xc018,
+	0xc138,
+	0xc219,
+	0xc340,
+	0xc41a,
+	0xc540,
+	0xc620,
+	0xc784,
+	0xc821,
+	0xc903,
+	0xca22,
+	0xcb05,
+	0xcc23,
+	0xcd07,
+	0xce24,
+	0xcf0a,
+	0xd025,
+	0xd146,
+	0xd226,
+	0xd332,
+	0xd427,
+	0xd51e,
+	0xd628,
+	0xd710,
+	0xd829,
+	0xd900,
+	0xda2a,
+	0xdb18,
+	0xdc2b,
+	0xdd18,
+	0xde2c,
+	0xdf18,
+	0xe02d,
+	0xe130,
+	0xe22e,
+	0xe330,
+	0xe42f,
+	0xe530,
+	0xe630,
+	0xe784,
+	0xe831,
+	0xe902,
+	0xea32,
+	0xeb04,
+	0xec33,
+	0xed04,
+	0xee34,
+	0xef0a,
+	0xf035,
+	0xf146,
+	0xf236,
+	0xf332,
+	0xf437,
+	0xf528,
+	0xf638,
+	0xf712,
+	0xf839,
+	0xf900,
+	0xfa3a,
+	0xfb20,
+	0xfc3b,
+	0xfd20,
+	0x0e00,
+	0x03e2,
+	0x0e01,
+	0x103c,
+	0x1120,
+	0x123d,
+	0x1310,
+	0x143e,
+	0x1518,
+	0x163f,
+	0x1714,
+	0x1840,
+	0x1904,
+	0x1a41,
+	0x1b10,
+	0x1c42,
+	0x1d70,
+	0x1e43,
+	0x1f20,
+	0x2044,
+	0x2110,
+	0x2245,
+	0x230c,
+	0x2446,
+	0x2510,
+	0x2647,
+	0x2718,
+	0x2848,
+	0x290a,
+	0x2a49,
+	0x2b10,
+	0x2c50,
+	0x2d85,
+	0x2e51,
+	0x2f30,
+	0x3052,
+	0x31b0,
+	0x3253,
+	0x3337,
+	0x3454,
+	0x3533,
+	0x3655,
+	0x3733,
+	0x3856,
+	0x3933,
+	0x3a57,
+	0x3b10,
+	0x3c58,
+	0x3d14,
+	0x3e59,
+	0x3f10,
+	0x4060,
+	0x4101,
+	0x4261,
+	0x43a0,
+	0x4462,
+	0x4598,
+	0x4663,
+	0x47e4,
+	0x4864,
+	0x49a4,
+	0x4a65,
+	0x4b7d,
+	0x4c66,
+	0x4d4b,
+	0x4e70,
+	0x4f10,
+	0x5071,
+	0x5110,
+	0x5272,
+	0x5310,
+	0x5473,
+	0x5510,
+	0x5674,
+	0x5710,
+	0x5875,
+	0x5910,
+	0x5a76,
+	0x5b38,
+	0x5c77,
+	0x5d38,
+	0x5e78,
+	0x5f38,
+	0x6079,
+	0x6170,
+	0x627a,
+	0x6370,
+	0x647b,
+	0x6570,
+	0x6603,
+	0x6710,
+	0x6860,
+	0x6903,
+	0x6a70,
+	0x6b0c,
+	0x6c71,
+	0x6d05,
+	0x6e72,
+	0x6f5f,
+	0x7073,
+	0x7133,
+	0x7274,
+	0x731b,
+	0x7475,
+	0x7503,
+	0x7676,
+	0x7720,
+	0x7877,
+	0x7933,
+	0x7a78,
+	0x7b33,
+	0x7c79,
+	0x7d46,
+	0x7e7a,
+	0x7f66,
+	0x807b,
+	0x8143,
+	0x827c,
+	0x8333,
+	0x847d,
+	0x850e,
+	0x867e,
+	0x871e,
+	0x887f,
+	0x893c,
+	0x8a03,
+	0x8b16,
+	0x8c8a,
+	0x8d68,
+	0x8e8b,
+	0x8f7c,
+	0x908c,
+	0x917f,
+	0x928d,
+	0x937f,
+	0x948e,
+	0x957f,
+	0x968f,
+	0x977f,
+	0x9890,
+	0x997f,
+	0x9a91,
+	0x9b7f,
+	0x9c92,
+	0x9d7f,
+	0x0e00,
+
+	0x03e3,
+	0x0e01,
+	0x1003,
+	0x1111,
+	0x1210,
+	0x131f,
+	0x1411,
+	0x152a,
+	0x1612,
+	0x171c,
+	0x1813,
+	0x191c,
+	0x1a14,
+	0x1b3a,
+	0x1c30,
+	0x1d20,
+	0x1e31,
+	0x1f20,
+	0x2032,
+	0x2140,
+	0x2233,
+	0x2328,
+	0x2434,
+	0x251a,
+	0x2635,
+	0x2714,
+	0x2836,
+	0x290c,
+	0x2a37,
+	0x2b0a,
+	0x2c38,
+	0x2d00,
+	0x2e39,
+	0x2f8a,
+	0x303a,
+	0x318a,
+	0x323b,
+	0x338a,
+	0x343c,
+	0x358a,
+	0x363d,
+	0x378a,
+	0x383e,
+	0x398a,
+	0x3a3f,
+	0x3b8a,
+	0x3c40,
+	0x3d8a,
+	0x3e41,
+	0x3f40,
+	0x4042,
+	0x4110,
+	0x4243,
+	0x4310,
+	0x4444,
+	0x4510,
+	0x4645,
+	0x4710,
+	0x4846,
+	0x4910,
+	0x4a47,
+	0x4b10,
+	0x4c48,
+	0x4d10,
+	0x4e49,
+	0x4f40,
+	0x504a,
+	0x5140,
+	0x524b,
+	0x5340,
+	0x544c,
+	0x5540,
+	0x564d,
+	0x5740,
+	0x584e,
+	0x5940,
+	0x5a4f,
+	0x5b40,
+	0x5c50,
+	0x5d40,
+	0x5e51,
+	0x5ff0,
+	0x6052,
+	0x61f0,
+	0x6253,
+	0x63f0,
+	0x6454,
+	0x65f0,
+	0x6655,
+	0x67f0,
+	0x6856,
+	0x69f0,
+	0x6a57,
+	0x6bf0,
+	0x6c58,
+	0x6df0,
+	0x6e59,
+	0x6ff8,
+	0x705a,
+	0x71f8,
+	0x725b,
+	0x73f8,
+	0x745c,
+	0x75f8,
+	0x765d,
+	0x77f8,
+	0x785e,
+	0x79f8,
+	0x7a5f,
+	0x7bf8,
+	0x7c60,
+	0x7df8,
+	0x7e61,
+	0x7fc0,
+	0x8062,
+	0x81f0,
+	0x8263,
+	0x8380,
+	0x8464,
+	0x8540,
+	0x8665,
+	0x8702,
+	0x8866,
+	0x8902,
+	0x8a67,
+	0x8b02,
+	0x8c68,
+	0x8d80,
+	0x8e69,
+	0x8f40,
+	0x906a,
+	0x9101,
+	0x926b,
+	0x9301,
+	0x946c,
+	0x9501,
+	0x966d,
+	0x9780,
+	0x986e,
+	0x9940,
+	0x9a6f,
+	0x9b01,
+	0x9c70,
+	0x9d01,
+	0x9e71,
+	0x9f01,
+	0xa072,
+	0xa16e,
+	0xa273,
+	0xa33a,
+	0xa474,
+	0xa501,
+	0xa675,
+	0xa701,
+	0xa876,
+	0xa901,
+	0xaa77,
+	0xab6e,
+	0xac78,
+	0xad3a,
+	0xae79,
+	0xaf01,
+	0xb07a,
+	0xb101,
+	0xb27b,
+	0xb301,
+	0xb47c,
+	0xb55c,
+	0xb67d,
+	0xb730,
+	0xb87e,
+	0xb901,
+	0xba7f,
+	0xbb01,
+	0xbc80,
+	0xbd01,
+	0xbe81,
+	0xbf62,
+	0xc082,
+	0xc126,
+	0xc283,
+	0xc301,
+	0xc484,
+	0xc501,
+	0xc685,
+	0xc701,
+	0xc886,
+	0xc962,
+	0xca87,
+	0xcb26,
+	0xcc88,
+	0xcd01,
+	0xce89,
+	0xcf01,
+	0xd08a,
+	0xd101,
+	0xd290,
+	0xd300,
+	0xd491,
+	0xd54e,
+	0xd692,
+	0xd700,
+	0xd893,
+	0xd916,
+	0xda94,
+	0xdb01,
+	0xdc95,
+	0xdd80,
+	0xde96,
+	0xdf55,
+	0xe097,
+	0xe18d,
+	0xe2b0,
+	0xe330,
+	0xe4b1,
+	0xe590,
+	0xe6b2,
+	0xe708,
+	0xe8b3,
+	0xe900,
+	0xeab4,
+	0xeb04,
+	0xec03,
+	0xed12,
+	0xee10,
+	0xef03,
+	0xf011,
+	0xf129,
+	0xf212,
+	0xf303,
+	0xf440,
+	0xf502,
+	0xf641,
+	0xf70a,
+	0xf842,
+	0xf96a,
+	0xfa43,
+	0xfb80,
+	0xfc44,
+	0xfd02,
+	0x0e00,
+	0x03e4,
+	0x0e01,
+	0x1045,
+	0x110a,
+	0x1246,
+	0x1380,
+	0x1460,
+	0x1502,
+	0x1661,
+	0x1704,
+	0x1862,
+	0x194b,
+	0x1a63,
+	0x1b41,
+	0x1c64,
+	0x1d14,
+	0x1e65,
+	0x1f00,
+	0x2068,
+	0x210a,
+	0x2269,
+	0x2304,
+	0x246a,
+	0x250a,
+	0x266b,
+	0x270a,
+	0x286c,
+	0x2924,
+	0x2a6d,
+	0x2b01,
+	0x2c70,
+	0x2d18,
+	0x2e71,
+	0x2fbf,
+	0x3080,
+	0x3164,
+	0x3281,
+	0x33b1,
+	0x3482,
+	0x352c,
+	0x3683,
+	0x3702,
+	0x3884,
+	0x3930,
+	0x3a85,
+	0x3b90,
+	0x3c86,
+	0x3d10,
+	0x3e87,
+	0x3f01,
+	0x4088,
+	0x413a,
+	0x4289,
+	0x4390,
+	0x448a,
+	0x450e,
+	0x468b,
+	0x470c,
+	0x488c,
+	0x4905,
+	0x4a8d,
+	0x4b03,
+	0x4ce6,
+	0x4dff,
+	0x4ee7,
+	0x4f18,
+	0x50e8,
+	0x510a,
+	0x52e9,
+	0x5306,
+	0x5403,
+	0x5513,
+	0x5610,
+	0x573f,
+	0x5820,
+	0x5920,
+	0x5a21,
+	0x5b30,
+	0x5c22,
+	0x5d36,
+	0x5e23,
+	0x5f6a,
+	0x6024,
+	0x61a0,
+	0x6225,
+	0x63c0,
+	0x6426,
+	0x65e0,
+	0x6627,
+	0x6700,
+	0x6828,
+	0x6900,
+	0x6a29,
+	0x6b00,
+	0x6c2a,
+	0x6d00,
+	0x6e2b,
+	0x6f00,
+	0x702c,
+	0x7100,
+	0x722d,
+	0x7300,
+	0x742e,
+	0x7500,
+	0x762f,
+	0x7704,
+	0x7830,
+	0x7904,
+	0x7a31,
+	0x7b04,
+	0x7c32,
+	0x7d04,
+	0x7e33,
+	0x7f10,
+	0x8034,
+	0x8110,
+	0x8235,
+	0x8300,
+	0x8436,
+	0x8580,
+	0x86a0,
+	0x8707,
+	0x88a8,
+	0x8930,
+	0x8aa9,
+	0x8b30,
+	0x8caa,
+	0x8d30,
+	0x8eab,
+	0x8f02,
+	0x90c0,
+	0x9127,
+	0x92c2,
+	0x9308,
+	0x94c3,
+	0x9508,
+	0x96c4,
+	0x9746,
+	0x98c5,
+	0x9978,
+	0x9ac6,
+	0x9bf0,
+	0x9cc7,
+	0x9d10,
+	0x9ec8,
+	0x9f44,
+	0xa0c9,
+	0xa187,
+	0xa2ca,
+	0xa3ff,
+	0xa4cb,
+	0xa520,
+	0xa6cc,
+	0xa761,
+	0xa8cd,
+	0xa987,
+	0xaace,
+	0xab8a,
+	0xaccf,
+	0xada5,
+	0xae03,
+	0xaf14,
+	0xb011,
+	0xb103,
+	0xb211,
+	0xb303,
+	0xb412,
+	0xb540,
+	0xb613,
+	0xb788,
+	0xb814,
+	0xb934,
+	0xba15,
+	0xbb00,
+	0xbc16,
+	0xbd00,
+	0xbe17,
+	0xbf00,
+	0xc018,
+	0xc110,
+	0xc219,
+	0xc310,
+	0xc41a,
+	0xc510,
+	0xc620,
+	0xc783,
+	0xc821,
+	0xc903,
+	0xca22,
+	0xcb05,
+	0xcc23,
+	0xcd07,
+	0xce24,
+	0xcf0a,
+	0xd025,
+	0xd146,
+	0xd226,
+	0xd332,
+	0xd427,
+	0xd51e,
+	0xd628,
+	0xd719,
+	0xd829,
+	0xd900,
+	0xda2a,
+	0xdb10,
+	0xdc2b,
+	0xdd10,
+	0xde2c,
+	0xdf10,
+	0xe02d,
+	0xe180,
+	0xe22e,
+	0xe380,
+	0xe42f,
+	0xe580,
+	0xe630,
+	0xe783,
+	0xe831,
+	0xe902,
+	0xea32,
+	0xeb04,
+	0xec33,
+	0xed04,
+	0xee34,
+	0xef0a,
+	0xf035,
+	0xf146,
+	0xf236,
+	0xf332,
+	0xf437,
+	0xf528,
+	0xf638,
+	0xf712,
+	0xf839,
+	0xf900,
+	0xfa3a,
+	0xfb18,
+	0xfc3b,
+	0xfd20,
+	0x0e00,
+	0x03e5,
+	0x0e01,
+	0x103c,
+	0x1118,
+	0x123d,
+	0x1320,
+	0x143e,
+	0x1522,
+	0x163f,
+	0x1710,
+	0x1840,
+	0x1903,
+	0x1a41,
+	0x1b12,
+	0x1c42,
+	0x1db0,
+	0x1e43,
+	0x1f20,
+	0x2044,
+	0x210a,
+	0x2245,
+	0x230a,
+	0x2446,
+	0x250a,
+	0x2647,
+	0x2708,
+	0x2848,
+	0x2908,
+	0x2a49,
+	0x2b08,
+	0x2c50,
+	0x2d03,
+	0x2e51,
+	0x2f32,
+	0x3052,
+	0x3140,
+	0x3253,
+	0x3319,
+	0x3454,
+	0x3560,
+	0x3655,
+	0x3760,
+	0x3856,
+	0x3960,
+	0x3a57,
+	0x3b20,
+	0x3c58,
+	0x3d20,
+	0x3e59,
+	0x3f20,
+	0x4060,
+	0x4103,
+	0x4261,
+	0x43a0,
+	0x4462,
+	0x4598,
+	0x4663,
+	0x47e4,
+	0x4864,
+	0x49a4,
+	0x4a65,
+	0x4b7d,
+	0x4c66,
+	0x4d4b,
+	0x4e70,
+	0x4f10,
+	0x5071,
+	0x5110,
+	0x5272,
+	0x5310,
+	0x5473,
+	0x5510,
+	0x5674,
+	0x5710,
+	0x5875,
+	0x5910,
+	0x5a76,
+	0x5b28,
+	0x5c77,
+	0x5d28,
+	0x5e78,
+	0x5f28,
+	0x6079,
+	0x6128,
+	0x627a,
+	0x6328,
+	0x647b,
+	0x6528,
+	0x6603,
+	0x6710,
+	0x6860,
+	0x6903,
+	0x6a70,
+	0x6b0c,
+	0x6c71,
+	0x6d08,
+	0x6e72,
+	0x6fed,
+	0x7073,
+	0x7100,
+	0x7274,
+	0x7336,
+	0x7475,
+	0x7508,
+	0x7676,
+	0x7713,
+	0x7877,
+	0x7920,
+	0x7a78,
+	0x7b00,
+	0x7c79,
+	0x7d40,
+	0x7e7a,
+	0x7f00,
+	0x807b,
+	0x8139,
+	0x827c,
+	0x8399,
+	0x847d,
+	0x850e,
+	0x867e,
+	0x871e,
+	0x887f,
+	0x893c,
+	0x8a03,
+	0x8b16,
+	0x8c8a,
+	0x8d60,
+	0x8e8b,
+	0x8f68,
+	0x908c,
+	0x916a,
+	0x928d,
+	0x9374,
+	0x948e,
+	0x957a,
+	0x968f,
+	0x977f,
+	0x9890,
+	0x997f,
+	0x9a91,
+	0x9b7f,
+	0x9c92,
+	0x9d7f,
+	0x0e00,
+
+	0x0300,
+	0x01f1,
+	0x03c0,
+	0x1680,
+	0x03C0,
+	0x3301,
+	0x3201,
+	0x0330,
+	0x1104,
+
+	0x031f,
+	0x1100,
+	0x1260,
+	0x1314,
+	0x1410,
+	0x1500,
+	0x2018,
+	0x2114,
+	0x228C,
+	0x239C,
+	0x2818,
+	0x2902,
+	0x3B18,
+	0x3C8C,
+	0x1019,
+	0x03c4,
+	0x10ef,
+	0x03c3,
+	0x1084,
+
+	0x0330,
+	0x7c2c,
+	0x7dce,
+	0x7e2d,
+	0x7fbb,
+	0x8024,
+	0x8170,
+	0x8227,
+	0x8339,
+	0x8421,
+	0x85a6,
+	0x8624,
+	0x876f,
+	0x8827,
+	0x893a,
+	0x8a2a,
+	0x8b03,
+	0x8c2a,
+	0x8d04,
+	0x8e2c,
+	0x8fcd,
+
+	0x03CD,
+	0x1038,
+	0x03c9,
+	0x2a00,
+	0x2bb2,
+	0x2c00,
+	0x2d79,
+	0x2e00,
+	0x2fb2,
+	0x3000,
+	0x3179,
+	0x03c5,
+	0x1081,
+	0x03cf,
+	0x10af,
+
+	0x0330,
+	0x3629,
+	0x0300,
+	0xff01,
+	0x0300,
+	0x1041,
+	0x2000,
+	0x2101,
+	0x4200,
+	0x4301,
+	0x0315,
+	0x1081,
+	0x2007,
+	0x21f8,
+	0x2202,
+	0x23fc,
+	0x0319,
+	0x1000,
+	0x1100,
+	0x1206,
+	0x1301,
+	0x2002,
+	0x2180,
+	0x2201,
+	0x23e0,
+	0x2400,
+	0x2503,
+	0x2600,
+	0x2701,
+	0x2802,
+	0x2983,
+	0x2a01,
+	0x2be1,
+	0x2c0c,
+	0x2dcc,
+	0x2e0c,
+	0x2fcc,
+	0x3042,
+	0x1007,
+
+	0x0348,
+	0x09a6,
+	0x101C,
+	0x1100,
+	0x1450,
+	0x1604,
+	0x1a11,
+	0x1b0d,
+	0x1c01,
+	0x1d0f,
+	0x1e09,
+	0x1f05,
+	0x2000,
+	0x241e,
+	0x3000,
+	0x3105,
+	0x3404,
+	0x3903,
+	0x0300,
+	0x0cf0,
+
+	0x0330,
+	0x3628,
+	0x0300,
+	0xff01,
+	0x0300,
+	0x01f0,
+	0x03c4,
+	0x10ee,
+	0x03C0,
+	0x3300,
+	0x3201,
+};
+
+static const u16 sr300pc20_camcorder_set[] = {
+	0xff00,
+};
+
+static const u16 sr300pc20_update_preview_setting[] = {
+	0x0300,
+	0x01f1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x106e,
+	0x03c5,
+	0x1000,
+	0x0300,
+	0xff01,
+	0x0330,
+	0x3629,
+	0x0300,
+	0xff01,
+	0x0319,
+	0x1007,
+	0x0300,
+	0x1041,
+	0x1180,
+	0x1380,
+	0x1430,
+	0x1704,
+	0x0302,
+	0x2102,
+	0x0300,
+	0xff01,
+	0x2000,
+	0x2100,
+	0x2200,
+	0x2300,
+	0x5200,
+	0x5321,
+	0x0315,
+	0x1081,
+	0x2007, /*Shading Width 2048*/
+	0x21f8,
+	0x2202, /*Shading Height 768*/
+	0x23fc,
+	0x0348,
+	0x101C,
+	0x1604,
+	0x3000,
+	0x3105,
+	0x0320,
+	0x2403,
+	0x2537,
+	0x26F9,
+	0x2780,
+	0x03d5,
+	0x4189,
+	0x0330,
+	0x3628,
+	0x0300,
+	0xff01,
+	0x03c4,
+	0x10ef,
+	0x0300,
+	0xff01,
+	0x03c5,
+	0x10b0,
+	0x0314,
+	0x1000,
+	0x0300,
+	0x01f0,
+	0x03cf,
+	0x10af,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_176_144_Preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_320_240_Preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_352_288_Preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_528_432_Preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_640_480_Preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_720_480_Preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_800_600_Preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_1024_768_Preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_1280_1024_Preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_1280_720_Preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_preview[] = {
+	0xff00,
+};
+static const u16 sr300pc20_snapshot[] = {
+	0x0300,
+	0x01f1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x106e,
+	0x03c5,
+	0x1000,
+	0x03D5,
+	0x1199,
+	0x03d6,
+	0x1700,
+	0x0319,
+	0x1000,
+	0x0300,
+	0x1000,
+	0x1430,
+	0x1705,
+	0x0302,
+	0x2101,
+	0x0300,
+	0xff01,
+	0x2000,
+	0x2104,
+	0x2200,
+	0x230a,
+	0x0315,
+	0x1083,
+	0x2007,
+	0x21f8,
+	0x2205,
+	0x23f8,
+	0x0348,
+	0x101C,
+	0x1604,
+	0x3000,
+	0x3110,
+	0x0320,
+	0x2800,
+	0x2909,
+	0x2ac4,
+	0x0330,
+	0x3629,
+	0x0300,
+	0xff02,
+	0x0314,
+	0x1027,
+	0x0300,
+	0x01f0,
+};
+static const u16 sr300pc20_snapshot_pvga[] = {
+	0xff00,
+};
+static const u16 sr300pc20_lowlight_snapshot[] = {
+	0xff00,
+};
+static const u16 sr300pc20_lowlight_snapshot_off[] = {
+	0xff00,
+};
+static const u16 sr300pc20_night_snapshot[] = {
+	0x0300,
+	0x01f1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x106e,
+	0x03c5,
+	0x1000,
+	0x03D5,
+	0x1198,
+	0x03d6,
+	0x1701,
+	0x0319,
+	0x1000,
+	0x0300,
+	0x1000,
+	0x1430,
+	0x1705,
+	0x0302,
+	0x2101,
+	0x0300,
+	0xff01,
+	0x2000,
+	0x2104,
+	0x2200,
+	0x230a,
+	0x0315,
+	0x1083,
+	0x2007,
+	0x21f8,
+	0x2205,
+	0x23f8,
+	0x0348,
+	0x101C,
+	0x1604,
+	0x3000,
+	0x3110,
+	0x0320,
+	0x2800,
+	0x2909,
+	0x2ac4,
+	0x0330,
+	0x3629,
+	0x0300,
+	0xff02,
+	0x0314,
+	0x1027,
+	0x0300,
+	0x01f0,
+};
+static const u16 sr300pc20_fireworks_snapshot[] = {
+	0x0300,
+	0x01f1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x106e,
+	0x03c5,
+	0x1000,
+	0x03D5,
+	0x1198,
+	0x03d6,
+	0x1700,
+	0x0319,
+	0x1000,
+	0x0300,
+	0x1000,
+	0x1430,
+	0x1705,
+	0x0302,
+	0x2101,
+	0x0300,
+	0xff01,
+	0x2000,
+	0x2104,
+	0x2200,
+	0x230a,
+	0x0315,
+	0x1083,
+	0x2007,
+	0x21f8,
+	0x2205,
+	0x23f8,
+	0x0348,
+	0x101C,
+	0x1604,
+	0x3000,
+	0x3110,
+	0x0320,
+	0x2800,
+	0x2909,
+	0x2ac4,
+	0x2401,
+	0x259b,
+	0x26fc,
+	0x27c0,
+	0x2001,
+	0x219b,
+	0x22fc,
+	0x23c0,
+	0x0300,
+	0xff02,
+	0x0314,
+	0x1027,
+	0x0300,
+	0x01f0,
+};
+static const u16 sr300pc20_night_snapshot_off[] = {
+	0xff00,
+};
+static const u16 sr300pc20_flash_normal_snapshot[] = {
+	0xff00,
+};
+static const u16 sr300pc20_flash_lowlight_snapshot[] = {
+	0xff00,
+};
+static const u16 sr300pc20_get_light_status[] = {
+	0x0320,
+	0xb100,
+};
+static const u16 sr300pc20_get_iso_reg[] = {
+	0x0320,
+	0x5000,
+};
+static const u16 sr300pc20_get_shutterspeed_reg[] = {
+	0x0320,
+	0xa000,
+	0xa100,
+	0xa200,
+	0xa300,
+};
+static const u16 sr300pc20_fps_auto[] = {
+	0xff00,
+};
+static const u16 sr300pc20_fps_15fix[] = {
+	0x0300,
+	0x0cf1,
+	0xff0a,
+	0x0300,
+	0x1430,
+	0x0302,
+	0xa608,
+	0xa726,
+	0xa801,
+	0xa9c4,
+	0xaa02,
+	0xabde,
+	0xac03,
+	0xad3b,
+	0xae05,
+	0xaf0c,
+	0xb800,
+	0xb976,
+	0xba00,
+	0xbbe6,
+	0xbc00,
+	0xbd2d,
+	0xbe01,
+	0xbfb8,
+	0xc800,
+	0xc976,
+	0xca00,
+	0xcbe8,
+	0xcc00,
+	0xcd2d,
+	0xce01,
+	0xcfba,
+	0x0303,
+	0x3204,
+	0x33e9,
+	0x3604,
+	0x37e9,
+	0x3800,
+	0x3901,
+	0x3a01,
+	0x3bc8,
+	0x3c00,
+	0x3d01,
+	0x3e01,
+	0x3fc8,
+	0xf000,
+	0xf173,
+	0x0310,
+	0x4100,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x106e,
+	0x03c5,
+	0x1000,
+	0x1213,
+	0x0300,
+	0xff0D,
+	0x0300,
+	0x1190,
+	0x5000,
+	0x5114,
+	0x5200,
+	0x5321,
+	0x03c3,
+	0x1080,
+	0x0320,
+	0x7180,
+	0x3008,
+	0x3139,
+	0x3278,
+	0x3306,
+	0x34d9,
+	0x3520,
+	0x2400,
+	0x2518,
+	0x26ac,
+	0x2768,
+	0x3c00,
+	0x3d36,
+	0x3eeb,
+	0x3f60,
+	0x8030,
+	0x03c4,
+	0x192c,
+	0x1e00,
+	0x1f08,
+	0x2039,
+	0x2178,
+	0x1a34,
+	0x2200,
+	0x2310,
+	0x2472,
+	0x25f0,
+	0x1b3c,
+	0x2600,
+	0x2718,
+	0x28ac,
+	0x2968,
+	0x0300,
+	0x13a8,
+	0x1194,
+	0x0311,
+	0xf2ae,
+	0xf3a4,
+	0x03cf,
+	0x10a7,
+	0x03c4,
+	0x10af,
+	0x0300,
+	0xff02,
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_fps_24fix[] =	{
+	0x0300,
+	0x0cf1,
+	0xff0a,
+	0x0300,
+	0x1430,
+	0x0302,
+	0xa608,
+	0xa726,
+	0xa801,
+	0xa9c4,
+	0xaa02,
+	0xabde,
+	0xac03,
+	0xad3b,
+	0xae05,
+	0xaf0c,
+	0xb800,
+	0xb976,
+	0xba00,
+	0xbbe6,
+	0xbc00,
+	0xbd2d,
+	0xbe01,
+	0xbfb8,
+	0xc800,
+	0xc976,
+	0xca00,
+	0xcbe8,
+	0xcc00,
+	0xcd2d,
+	0xce01,
+	0xcfba,
+	0x0303,
+	0x3204,
+	0x33e9,
+	0x3604,
+	0x37e9,
+	0x3800,
+	0x3901,
+	0x3a01,
+	0x3bc8,
+	0x3c00,
+	0x3d01,
+	0x3e01,
+	0x3fc8,
+	0xf000,
+	0xf173,
+	0x0310,
+	0x4100,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x106e,
+	0x03c5,
+	0x1000,
+	0x1213,
+	0x0300,
+	0xff0d,
+	0x0300,
+	0x1190,
+	0x5000,
+	0x5114,
+	0x5200,
+	0x530e,
+	0x03c3,
+	0x1080,
+	0x0320,
+	0x7180,
+	0x3008,
+	0x3139,
+	0x3278,
+	0x3306,
+	0x34d9,
+	0x3520,
+	0x2400,
+	0x2518,
+	0x26ac,
+	0x2768,
+	0x3c00,
+	0x3d1b,
+	0x3e75,
+	0x3fb0,
+	0x8030,
+	0x03c4,
+	0x192c,
+	0x1e00,
+	0x1f08,
+	0x2039,
+	0x2178,
+	0x1a34,
+	0x2200,
+	0x2310,
+	0x2472,
+	0x25f0,
+	0x1b3c,
+	0x2600,
+	0x2718,
+	0x28ac,
+	0x2968,
+	0x0300,
+	0x13a8,
+	0x1194,
+	0x0311,
+	0xf2ae,
+	0xf3a4,
+	0x03cf,
+	0x10a7,
+	0x03c4,
+	0x10af,
+	0x0300,
+	0xff02,
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_fps_30fix[] = {
+	0x0300,
+	0x0cf1,
+	0xff0a,
+	0x0300,
+	0x1430,
+	0x0302,
+	0xa608,
+	0xa726,
+	0xa801,
+	0xa9c4,
+	0xaa02,
+	0xabde,
+	0xac03,
+	0xad3b,
+	0xae05,
+	0xaf0c,
+	0xb800,
+	0xb976,
+	0xba00,
+	0xbbe6,
+	0xbc00,
+	0xbd2d,
+	0xbe01,
+	0xbfb8,
+	0xc800,
+	0xc976,
+	0xca00,
+	0xcbe8,
+	0xcc00,
+	0xcd2d,
+	0xce01,
+	0xcfba,
+	0x0303,
+	0x3204,
+	0x33e9,
+	0x3604,
+	0x37e9,
+	0x3800,
+	0x3901,
+	0x3a01,
+	0x3bc8,
+	0x3c00,
+	0x3d01,
+	0x3e01,
+	0x3fc8,
+	0xf000,
+	0xf173,
+	0x0310,
+	0x4100,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x106e,
+	0x03c5,
+	0x1000,
+	0x1213,
+	0x0300,
+	0xff0d,
+	0x0300,
+	0x1190,
+	0x5000,
+	0x5114,
+	0x5200,
+	0x530e,
+	0x03c3,
+	0x1080,
+	0x0320,
+	0x7180,
+	0x3008,
+	0x3139,
+	0x3278,
+	0x3306,
+	0x34d9,
+	0x3520,
+	0x2400,
+	0x2518,
+	0x26ac,
+	0x2768,
+	0x3c00,
+	0x3d1b,
+	0x3e75,
+	0x3fb0,
+	0x8030,
+	0x03c4,
+	0x192c,
+	0x1e00,
+	0x1f08,
+	0x2039,
+	0x2178,
+	0x1a34,
+	0x2200,
+	0x2310,
+	0x2472,
+	0x25f0,
+	0x1b3c,
+	0x2600,
+	0x2718,
+	0x28ac,
+	0x2968,
+	0x0300,
+	0x13a8,
+	0x1194,
+	0x0311,
+	0xf2ae,
+	0xf3a4,
+	0x03cf,
+	0x10a7,
+	0x03c4,
+	0x10af,
+	0x0300,
+	0xff02,
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_effect_off[] = {
+	0x0310,
+	0x1103,
+	0x12f0,
+	0x4200,
+	0x4300,
+	0x4480,
+	0x4580,
+	0x0314,
+	0x8020,
+};
+static const u16 sr300pc20_effect_mono[] = {
+	0x0310,
+	0x1103,
+	0x12f3,
+	0x4200,
+	0x4300,
+	0x4480,
+	0x4580,
+	0x0314,
+	0x8020,
+};
+static const u16 sr300pc20_effect_sepia[] = {
+	0x0310,
+	0x1103,
+	0x12f3,
+	0x4200,
+	0x4300,
+	0x4460,
+	0x45a3,
+	0x0314,
+	0x8020,
+};
+static const u16 sr300pc20_effect_negative[] = {
+	0x0310,
+	0x1103,
+	0x12f8,
+	0x4200,
+	0x4300,
+	0x4480,
+	0x4580,
+	0x0314,
+	0x8020,
+};
+static const u16 sr300pc20_wb_auto[] = {
+	0x03c5,
+	0x11a4,
+	0x1293,
+	0x03c6,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba6,
+	0x03c5,
+	0x10b1,
+};
+static const u16 sr300pc20_wb_daylight[] = {
+	0x03c5,
+	0x11a0,
+	0x1203,
+	0x03c6,
+	0x1875,
+	0x1976,
+	0x1a6a,
+	0x1b6b,
+	0x03c5,
+	0x10b1,
+};
+static const u16 sr300pc20_wb_cloudy[] = {
+	0x03c5,
+	0x11a0,
+	0x1203,
+	0x03c6,
+	0x1890,
+	0x1992,
+	0x1a5f,
+	0x1b61,
+	0x03c5,
+	0x10b1,
+};
+static const u16 sr300pc20_wb_fluorescent[] = {
+	0x03c5,
+	0x11a0,
+	0x1203,
+	0x03c6,
+	0x185d,
+	0x195e,
+	0x1a94,
+	0x1b95,
+	0x03c5,
+	0x10b1,
+};
+static const u16 sr300pc20_wb_incandescent[] = {
+	0x03c5,
+	0x11a0,
+	0x1203,
+	0x03c6,
+	0x1847,
+	0x1948,
+	0x1aa4,
+	0x1ba5,
+	0x03c5,
+	0x10b1,
+};
+static const u16 sr300pc20_brightness_m_4[] = {
+	0x03d9,
+	0x17d0,
+};
+static const u16 sr300pc20_brightness_m_3[] = {
+	0x03d9,
+	0x17c0,
+};
+static const u16 sr300pc20_brightness_m_2[] = {
+	0x03d9,
+	0x17b0,
+};
+static const u16 sr300pc20_brightness_m_1[] = {
+	0x03d9,
+	0x17a0,
+};
+static const u16 sr300pc20_brightness_0[] = {
+	0x03d9,
+	0x1700,
+};
+static const u16 sr300pc20_brightness_p_1[] = {
+	0x03d9,
+	0x1714,
+};
+static const u16 sr300pc20_brightness_p_2[] = {
+	0x03d9,
+	0x1728,
+};
+static const u16 sr300pc20_brightness_p_3[] = {
+	0x03d9,
+	0x173c,
+};
+static const u16 sr300pc20_brightness_p_4[] = {
+	0x03d9,
+	0x1750,
+};
+static const u16 sr300pc20_scene_off[] = {
+	0x0300,
+	0x0cf1,
+	0xff19,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x106e,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf040,
+	0x0310,
+	0x410a,
+
+	0x0320,
+	0x126d,
+	0x2400,
+	0x2562,
+	0x26e0,
+	0x2780,
+
+	0x51f0,
+	0x5224,
+
+	0x03c4,
+	0x193c,
+	0x1a46,
+	0x1b5c,
+
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2741,
+	0x28eb,
+	0x2900,
+	0x0300,
+	0x92a0,
+	0x9390,
+	0xa387,
+	0xa787,
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+
+	0x03c5,
+	0x11a4,
+	0x1293,
+	0x03c6,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba6,
+
+	0x03d1,
+
+	0x2b88,
+	0x2c88,
+	0x2d88,
+	0x2e88,
+	0x2f88,
+	0x308c,
+	0x3198,
+	0x3298,
+	0x3398,
+	0x3498,
+	0x3598,
+	0x3698,
+
+	0x3780,
+	0x3880,
+	0x3980,
+	0x3a78,
+	0x3b88,
+	0x3c84,
+	0x3d8c,
+	0x3e8c,
+	0x3f8c,
+	0x408c,
+	0x418c,
+	0x428c,
+
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+
+	0x03cf,
+	0x10af,
+
+	0x03c3,
+	0xE125,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10ff,
+	0x0300,
+	0xff02,
+
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_portrait[] = {
+	0xff00,
+};
+static const u16 sr300pc20_scene_landscape[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x106e,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf040,
+
+	0x0320,
+	0x8030,
+	0x126D,
+	0x2400,
+	0x2562,
+	0x26e0,
+	0x2780,
+
+	0x51f0,
+	0x5224,
+
+	0x03c4,
+	0x193c,
+	0x1a46,
+	0x1b5c,
+
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2741,
+	0x28eb,
+	0x2900,
+
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8311,
+	0x8411,
+	0x8511,
+	0x8611,
+	0x8711,
+	0x8811,
+	0x8911,
+	0x8A11,
+	0x8B11,
+	0x8C11,
+	0x8D11,
+	0x8E11,
+	0x8F11,
+	0x9011,
+	0x9111,
+	0x9211,
+	0x9311,
+	0x9411,
+	0x9511,
+	0x9611,
+	0x9711,
+	0x9811,
+	0x9911,
+	0x9A11,
+	0x9B11,
+	0x9C11,
+	0x9D11,
+	0x9E11,
+	0x9F11,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+
+	0x03c5,
+	0x11a4,
+	0x1213,
+	0x03c6,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba6,
+
+	0x03d1,
+
+	0x2ba8,
+	0x2ca8,
+	0x2da8,
+	0x2ea8,
+	0x2fa8,
+	0x30ac,
+	0x31b8,
+	0x32b8,
+	0x33b8,
+	0x34b8,
+	0x35b8,
+	0x36b8,
+
+	0x37a0,
+	0x38a0,
+	0x39a0,
+	0x3a98,
+	0x3ba8,
+	0x3ca4,
+	0x3dac,
+	0x3eac,
+	0x3fac,
+	0x40ac,
+	0x41ac,
+	0x42ac,
+
+	0x03db,
+	0xbb50,
+	0xbd50,
+	0xbf50,
+	0xc184,
+	0xc384,
+	0xc570,
+	0x03de,
+	0xbb50,
+	0xbd50,
+	0xbf50,
+	0xc188,
+	0xc390,
+	0xc590,
+	0x03e1,
+	0xbb50,
+	0xbd50,
+	0xbf50,
+	0xc168,
+	0xc370,
+	0xc570,
+	0x03e4,
+	0xbb20,
+	0xbd20,
+	0xbf20,
+	0xc140,
+	0xc340,
+	0xc540,
+
+	0x03cf,
+	0x10a7,
+
+	0x03c3,
+	0xE125,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10ff,
+	0x0300,
+	0xff02,
+
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff19,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_sports[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x106e,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf04b,
+	0x0310,
+	0x4100,
+
+	0x0320,
+	0x8030,
+	0x126d,
+	0x2400,
+	0x2562,
+	0x26e0,
+	0x2780,
+
+	0x51f0,
+	0x5248,
+
+	0x03c4,
+	0x1948,
+	0x1a50,
+	0x1b5c,
+
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2741,
+	0x28eb,
+	0x2900,
+
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+
+	0x03c5,
+	0x11a4,
+	0x1213,
+	0x03c6,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba6,
+
+	0x03d1,
+
+	0x2b88,
+	0x2c88,
+	0x2d88,
+	0x2e88,
+	0x2f88,
+	0x308c,
+	0x3198,
+	0x3298,
+	0x3398,
+	0x3498,
+	0x3598,
+	0x3698,
+
+	0x3780,
+	0x3880,
+	0x3980,
+	0x3a78,
+	0x3b88,
+	0x3c84,
+	0x3d8c,
+	0x3e8c,
+	0x3f8c,
+	0x408c,
+	0x418c,
+	0x428c,
+
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+
+	0x03cf,
+	0x10a7,
+
+	0x03c3,
+	0xE149,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10ff,
+	0x0300,
+	0xff02,
+
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff1a,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_party[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x106e,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf040,
+	0x0310,
+	0x4100,
+
+	0x0320,
+	0x8030,
+	0x126d,
+	0x2400,
+	0x2562,
+	0x26e0,
+	0x2780,
+
+	0x518b,
+	0x525c,
+	0x03c4,
+	0x195c,
+	0x1a5c,
+	0x1b5c,
+
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2741,
+	0x28eb,
+	0x2900,
+
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+
+	0x03c5,
+	0x11a4,
+	0x1213,
+	0x03c6,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba6,
+
+	0x03d1,
+
+	0x2ba8,
+	0x2ca8,
+	0x2da8,
+	0x2ea8,
+	0x2fa8,
+	0x30ac,
+	0x31b8,
+	0x32b8,
+	0x33b8,
+	0x34b8,
+	0x35b8,
+	0x36b8,
+
+	0x37a0,
+	0x38a0,
+	0x39a0,
+	0x3a98,
+	0x3ba8,
+	0x3ca4,
+	0x3dac,
+	0x3eac,
+	0x3fac,
+	0x40ac,
+	0x41ac,
+	0x42ac,
+
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+
+	0x03cf,
+	0x10a7,
+
+	0x03c3,
+	0xE15d,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10ff,
+	0x0300,
+	0xff02,
+
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff1a,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_beach[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x106e,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1710,
+	0x0311,
+	0xf04b,
+	0x0310,
+	0x4100,
+
+	0x0320,
+	0x8030,
+	0x1269,
+	0x8030,
+	0x2400,
+	0x2562,
+	0x26e0,
+	0x2780,
+
+	0x5170,
+	0x5224,
+
+	0x03c4,
+	0x193c,
+	0x1a46,
+	0x1b5c,
+
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2741,
+	0x28eb,
+	0x2900,
+
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+
+	0x03c5,
+	0x11a4,
+	0x1213,
+	0x03c6,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba6,
+
+	0x03d1,
+
+	0x2ba8,
+	0x2ca8,
+	0x2da8,
+	0x2ea8,
+	0x2fa8,
+	0x30ac,
+	0x31b8,
+	0x32b8,
+	0x33b8,
+	0x34b8,
+	0x35b8,
+	0x36b8,
+
+	0x37a0,
+	0x38a0,
+	0x39a0,
+	0x3a98,
+	0x3ba8,
+	0x3ca4,
+	0x3dac,
+	0x3eac,
+	0x3fac,
+	0x40ac,
+	0x41ac,
+	0x42ac,
+
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+
+	0x03cf,
+	0x10a7,
+
+	0x03c3,
+	0xE125,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10ff,
+	0x0300,
+	0xff02,
+
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff1a,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_sunset[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x106e,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf040,
+
+	0x0320,
+	0x8030,
+	0x126d,
+	0x2400,
+	0x2562,
+	0x26e0,
+	0x2780,
+
+	0x51f0,
+	0x5224,
+
+	0x03c4,
+	0x193c,
+	0x1a46,
+	0x1b5c,
+
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2741,
+	0x28eb,
+	0x2900,
+
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+
+	0x03c5,
+	0x11a0,
+	0x1203,
+	0x03c6,
+	0x1875,
+	0x1976,
+	0x1a6a,
+	0x1b6b,
+
+	0x03d1,
+
+	0x2b88,
+	0x2c88,
+	0x2d88,
+	0x2e88,
+	0x2f88,
+	0x308c,
+	0x3198,
+	0x3298,
+	0x3398,
+	0x3498,
+	0x3598,
+	0x3698,
+
+	0x3780,
+	0x3880,
+	0x3980,
+	0x3a78,
+	0x3b88,
+	0x3c84,
+	0x3d8c,
+	0x3e8c,
+	0x3f8c,
+	0x408c,
+	0x418c,
+	0x428c,
+
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+
+	0x03cf,
+	0x10a7,
+
+	0x03c3,
+	0xE125,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10ff,
+	0x0300,
+	0xff02,
+
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff19,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_dawn[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x106e,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf040,
+
+	0x0320,
+	0x8030,
+	0x126d,
+	0x2400,
+	0x2562,
+	0x26e0,
+	0x2780,
+
+	0x51f0,
+	0x5224,
+
+	0x03c4,
+	0x193c,
+	0x1a46,
+	0x1b5c,
+
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2741,
+	0x28eb,
+	0x2900,
+
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+
+	0x03c5,
+	0x11a0,
+	0x1203,
+	0x03c6,
+	0x185d,
+	0x195e,
+	0x1a94,
+	0x1b95,
+
+	0x03d1,
+
+	0x2b88,
+	0x2c88,
+	0x2d88,
+	0x2e88,
+	0x2f88,
+	0x308c,
+	0x3198,
+	0x3298,
+	0x3398,
+	0x3498,
+	0x3598,
+	0x3698,
+
+	0x3780,
+	0x3880,
+	0x3980,
+	0x3a78,
+	0x3b88,
+	0x3c84,
+	0x3d8c,
+	0x3e8c,
+	0x3f8c,
+	0x408c,
+	0x418c,
+	0x428c,
+
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+
+	0x03cf,
+	0x10a7,
+
+	0x03c3,
+	0xE125,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10ff,
+	0x0300,
+	0xff02,
+
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff19,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_fall[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x106e,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf040,
+
+	0x0320,
+	0x8030,
+	0x126d,
+	0x2400,
+	0x2562,
+	0x26e0,
+	0x2780,
+
+	0x51f0,
+	0x5224,
+
+	0x03c4,
+	0x193c,
+	0x1a46,
+	0x1b5c,
+
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2741,
+	0x28eb,
+	0x2900,
+
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+
+	0x03c5,
+	0x11a4,
+	0x1213,
+	0x03c6,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba6,
+
+	0x03d1,
+
+	0x2bc8,
+	0x2cc8,
+	0x2dc8,
+	0x2ec8,
+	0x2fc8,
+	0x30cc,
+	0x31d8,
+	0x32d8,
+	0x33d8,
+	0x34d8,
+	0x35d8,
+	0x36d8,
+
+	0x37c0,
+	0x38c0,
+	0x39c0,
+	0x3ab8,
+	0x3bc8,
+	0x3cc4,
+	0x3dcc,
+	0x3ecc,
+	0x3fcc,
+	0x40cc,
+	0x41cc,
+	0x42cc,
+
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+
+	0x03cf,
+	0x10a7,
+
+	0x03c3,
+	0xE125,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10ff,
+	0x0300,
+	0xff02,
+
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff19,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_nightshot[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x1066,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf040,
+
+	0x0320,
+	0x8030,
+	0x126d,
+	0x2400,
+	0x25cd,
+	0x26fe,
+	0x2760,
+
+	0x51ff,
+	0x5224,
+
+	0x03c4,
+	0x193c,
+	0x1a46,
+	0x1b5c,
+
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2744,
+	0x28aa,
+	0x2920,
+
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+
+	0x03c5,
+	0x11a4,
+	0x1213,
+	0x03c6,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba6,
+
+	0x03d1,
+
+	0x2b88,
+	0x2c88,
+	0x2d88,
+	0x2e88,
+	0x2f88,
+	0x308c,
+	0x3198,
+	0x3298,
+	0x3398,
+	0x3498,
+	0x3598,
+	0x3698,
+
+	0x3780,
+	0x3880,
+	0x3980,
+	0x3a78,
+	0x3b88,
+	0x3c84,
+	0x3d8c,
+	0x3e8c,
+	0x3f8c,
+	0x408c,
+	0x418c,
+	0x428c,
+
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+
+	0x03cf,
+	0x10a7,
+
+	0x03c3,
+	0xE125,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10ff,
+	0x0300,
+	0xff02,
+
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff19,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_backlight[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x106e,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf040,
+
+	0x0320,
+	0x8030,
+	0x126d,
+	0x2400,
+	0x2562,
+	0x26e0,
+	0x2780,
+
+	0x51f0,
+	0x5224,
+
+	0x03c4,
+	0x193c,
+	0x1a46,
+	0x1b5c,
+
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2741,
+	0x28eb,
+	0x2900,
+
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C00,
+	0x7D10,
+	0x7E11,
+	0x7F11,
+	0x8001,
+	0x8100,
+	0x8200,
+	0x8310,
+	0x84ff,
+	0x85ff,
+	0x8601,
+	0x8700,
+	0x8800,
+	0x8910,
+	0x8Aff,
+	0x8Bff,
+	0x8C01,
+	0x8D00,
+	0x8E00,
+	0x8F10,
+	0x90ff,
+	0x91ff,
+	0x9201,
+	0x9300,
+	0x9400,
+	0x9510,
+	0x9611,
+	0x9711,
+	0x9801,
+	0x9900,
+	0x9A00,
+	0x9B00,
+	0x9C00,
+	0x9D00,
+	0x9E00,
+	0x9F00,
+	0xA000,
+	0xA100,
+	0xA200,
+	0xA300,
+	0xA400,
+	0xA500,
+
+	0x03c5,
+	0x11a4,
+	0x1213,
+	0x03c6,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba6,
+
+	0x03d1,
+
+	0x2b88,
+	0x2c88,
+	0x2d88,
+	0x2e88,
+	0x2f88,
+	0x308c,
+	0x3198,
+	0x3298,
+	0x3398,
+	0x3498,
+	0x3598,
+	0x3698,
+
+	0x3780,
+	0x3880,
+	0x3980,
+	0x3a78,
+	0x3b88,
+	0x3c84,
+	0x3d8c,
+	0x3e8c,
+	0x3f8c,
+	0x408c,
+	0x418c,
+	0x428c,
+
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+
+	0x03cf,
+	0x10a7,
+
+	0x03c3,
+	0xE125,
+	0x03c4,
+	0x10ff,
+	0x0300,
+	0xff02,
+
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff1a,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_firework[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x106e,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf04b,
+
+	0x0320,
+	0x8030,
+	0x1269,
+	0x2400,
+	0x25cd,
+	0x26fe,
+	0x2760,
+
+	0x5148,
+	0x5224,
+
+	0x03c4,
+	0x193c,
+	0x1a40,
+	0x1b46,
+
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2741,
+	0x28eb,
+	0x2900,
+	0x0300,
+	0x9247,
+	0x9340,
+	0xa385,
+	0xa785,
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+
+	0x03c5,
+	0x11a4,
+	0x1213,
+	0x03c6,
+	0x1846,
+	0x1990,
+	0x1a40,
+	0x1ba6,
+
+	0x03d1,
+
+	0x2b88,
+	0x2c88,
+	0x2d88,
+	0x2e88,
+	0x2f88,
+	0x308c,
+	0x3198,
+	0x3298,
+	0x3398,
+	0x3498,
+	0x3598,
+	0x3698,
+
+	0x3780,
+	0x3880,
+	0x3980,
+	0x3a78,
+	0x3b88,
+	0x3c84,
+	0x3d8c,
+	0x3e8c,
+	0x3f8c,
+	0x408c,
+	0x418c,
+	0x428c,
+
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+
+	0x03cf,
+	0x10a7,
+
+	0x03c3,
+	0xE125,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10ff,
+	0x0300,
+	0xff02,
+
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff19,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_scene_text[] = {
+	0xff00,
+};
+static const u16 sr300pc20_scene_candle[] = {
+	0x0300,
+	0x0cf1,
+	0x0330,
+	0x36A3,
+	0x03c4,
+	0x106e,
+	0x03c5,
+	0x1000,
+	0x03d9,
+	0x1700,
+	0x0311,
+	0xf040,
+
+	0x0320,
+	0x8030,
+	0x126d,
+	0x2400,
+	0x2562,
+	0x26e0,
+	0x2780,
+
+	0x51f0,
+	0x5224,
+
+	0x03c4,
+	0x193c,
+	0x1a46,
+	0x1b5c,
+
+	0x2200,
+	0x2329,
+	0x2432,
+	0x25E0,
+	0x2600,
+	0x2741,
+	0x28eb,
+	0x2900,
+
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+
+	0x03c5,
+	0x11a0,
+	0x1203,
+	0x03c6,
+	0x1875,
+	0x1976,
+	0x1a6a,
+	0x1b6b,
+
+	0x03d1,
+
+	0x2b88,
+	0x2c88,
+	0x2d88,
+	0x2e88,
+	0x2f88,
+	0x308c,
+	0x3198,
+	0x3298,
+	0x3398,
+	0x3498,
+	0x3598,
+	0x3698,
+
+	0x3780,
+	0x3880,
+	0x3980,
+	0x3a78,
+	0x3b88,
+	0x3c84,
+	0x3d8c,
+	0x3e8c,
+	0x3f8c,
+	0x408c,
+	0x418c,
+	0x428c,
+
+	0x03db,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc154,
+	0xc354,
+	0xc540,
+	0x03de,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc158,
+	0xc360,
+	0xc560,
+	0x03e1,
+	0xbb30,
+	0xbd30,
+	0xbf30,
+	0xc138,
+	0xc340,
+	0xc540,
+	0x03e4,
+	0xbb00,
+	0xbd00,
+	0xbf00,
+	0xc110,
+	0xc310,
+	0xc510,
+
+	0x03cf,
+	0x10a7,
+
+	0x03c3,
+	0xE125,
+	0x03c4,
+	0x6608,
+	0x6700,
+	0x10ff,
+	0x0300,
+	0xff02,
+
+	0x03c5,
+	0x10b1,
+	0x0300,
+	0x0cf0,
+	0xff19,
+	0x03c0,
+	0x3300,
+	0x3201,
+};
+static const u16 sr300pc20_metering_normal[] = {
+	0x03c3,
+	0x7011,
+	0x7111,
+	0x7211,
+	0x7311,
+	0x7411,
+	0x7511,
+	0x7611,
+	0x7711,
+	0x7811,
+	0x7911,
+	0x7A11,
+	0x7B11,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8311,
+	0x8411,
+	0x8511,
+	0x8611,
+	0x8711,
+	0x8811,
+	0x8911,
+	0x8A11,
+	0x8B11,
+	0x8C11,
+	0x8D11,
+	0x8E11,
+	0x8F11,
+	0x9011,
+	0x9111,
+	0x9211,
+	0x9311,
+	0x9411,
+	0x9511,
+	0x9611,
+	0x9711,
+	0x9811,
+	0x9911,
+	0x9A11,
+	0x9B11,
+	0x9C11,
+	0x9D11,
+	0x9E11,
+	0x9F11,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+};
+static const u16 sr300pc20_metering_spot[] = {
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C00,
+	0x7D10,
+	0x7E11,
+	0x7F11,
+	0x8001,
+	0x8100,
+	0x8200,
+	0x8310,
+	0x84ff,
+	0x85ff,
+	0x8601,
+	0x8700,
+	0x8800,
+	0x8910,
+	0x8Aff,
+	0x8Bff,
+	0x8C01,
+	0x8D00,
+	0x8E00,
+	0x8F10,
+	0x90ff,
+	0x91ff,
+	0x9201,
+	0x9300,
+	0x9400,
+	0x9510,
+	0x9611,
+	0x9711,
+	0x9801,
+	0x9900,
+	0x9A00,
+	0x9B00,
+	0x9C00,
+	0x9D00,
+	0x9E00,
+	0x9F00,
+	0xA000,
+	0xA100,
+	0xA200,
+	0xA300,
+	0xA400,
+	0xA500,
+};
+static const u16 sr300pc20_metering_center[] = {
+	0x03c3,
+	0x7000,
+	0x7100,
+	0x7200,
+	0x7300,
+	0x7400,
+	0x7500,
+	0x7600,
+	0x7700,
+	0x7800,
+	0x7900,
+	0x7A00,
+	0x7B00,
+	0x7C11,
+	0x7D11,
+	0x7E11,
+	0x7F11,
+	0x8011,
+	0x8111,
+	0x8211,
+	0x8321,
+	0x8444,
+	0x8544,
+	0x8612,
+	0x8711,
+	0x8811,
+	0x8922,
+	0x8A64,
+	0x8B46,
+	0x8C22,
+	0x8D11,
+	0x8E21,
+	0x8F33,
+	0x9064,
+	0x9146,
+	0x9233,
+	0x9312,
+	0x9421,
+	0x9533,
+	0x9644,
+	0x9744,
+	0x9833,
+	0x9912,
+	0x9A21,
+	0x9B33,
+	0x9C33,
+	0x9D33,
+	0x9E33,
+	0x9F12,
+	0xA011,
+	0xA111,
+	0xA211,
+	0xA311,
+	0xA411,
+	0xA511,
+};
+static const u16 sr300pc20_iso_auto[] = {
+	0xff00,
+};
+static const u16 sr300pc20_iso_50[] = {
+	0xff00,
+};
+static const u16 sr300pc20_iso_100[] = {
+	0xff00,
+};
+static const u16 sr300pc20_iso_200[] = {
+	0xff00,
+};
+static const u16 sr300pc20_iso_400[] = {
+	0xff00,
+};
+static const u16 sr300pc20_ae_lock[] = {
+	0xff00,
+};
+static const u16 sr300pc20_awb_lock[] = {
+	0xff00,
+};
+static const u16 sr300pc20_ae_unlock[] = {
+	0xff00,
+};
+static const u16 sr300pc20_awb_unlock[] = {
+	0xff00,
+};
+static const u16 sr300pc20_af_abort[] = {
+	0xff00,
+};
+static const u16 sr300pc20_af_off[] = {
+	0xff00,
+};
+static const u16 sr300pc20_af_normal_on[] = {
+	0xff00,
+};
+static const u16 sr300pc20_af_macro_on[] = {
+	0xff00,
+};
+static const u16 sr300pc20_af_do[] = {
+	0xff00,
+};
+static const u16 sr300pc20_1st_720P_af_do[] = {
+	0xff00,
+};
+static const u16 sr300pc20_contrast_m_2[] = {
+	0xff00,
+};
+static const u16 sr300pc20_contrast_m_1[] = {
+	0xff00,
+};
+static const u16 sr300pc20_contrast_0[] = {
+	0xff00,
+};
+static const u16 sr300pc20_contrast_p_1[] = {
+	0xff00,
+};
+static const u16 sr300pc20_contrast_p_2[] = {
+	0xff00,
+};
+static const u16 sr300pc20_saturation_m_2[] = {
+	0xff00,
+};
+static const u16 sr300pc20_saturation_m_1[] = {
+	0xff00,
+};
+static const u16 sr300pc20_saturation_0[] = {
+	0xff00,
+};
+static const u16 sr300pc20_saturation_p_1[] = {
+	0xff00,
+};
+static const u16 sr300pc20_saturation_p_2[] = {
+	0xff00,
+};
+static const u16 sr300pc20_sharpness_m_2[] = {
+	0xff00,
+};
+static const u16 sr300pc20_sharpness_m_1[] = {
+	0xff00,
+};
+static const u16 sr300pc20_sharpness_0[] = {
+	0xff00,
+};
+static const u16 sr300pc20_sharpness_p_1[] = {
+	0xff00,
+};
+static const u16 sr300pc20_sharpness_p_2[] = {
+	0xff00,
+};
+static const u16 sr300pc20_dtp_on[] = {
+	0x0300,
+	0x6005,
+};
+static const u16 sr300pc20_dtp_off[] = {
+	0x0300,
+	0x6000,
+};
+static const u16 sr300pc20_pll_on[] = {
+	0xff00,
+};
+static const u16 sr300pc20_pll_off[] = {
+	0xff00,
+};
+static const u16 sr300pc20_preflash_start[] = {
+	0xff00,
+};
+static const u16 sr300pc20_preflash_end[] = {
+	0xff00,
+};
+static const u16 sr300pc20_mainflash_start[] = {
+	0xff00,
+};
+static const u16 sr300pc20_mainflash_end[] = {
+	0xff00,
+};
+static const u16 sr300pc20_flash_ae_set[] = {
+	0xff00,
+};
+static const u16 sr300pc20_flash_ae_clear[] = {
+	0xff00,
+};
+static const u16 sr300pc20_get_ae_stable_reg[] = {
+	0xff00,
+};
+static const u16 sr300pc20_DTP_init0[] = {
+	0x0300,
+	0x6005,
+};
+#endif
diff --git a/include/media/msm_camera.h b/include/media/msm_camera.h
index 03bb9ec..e5389e5 100755
--- a/include/media/msm_camera.h
+++ b/include/media/msm_camera.h
@@ -1,3 +1,6 @@
+#ifdef CONFIG_MSM_CAMERA_LEGACY
+#include "media/msm_camera_legacy.h"
+#else
 /* Copyright (c) 2009-2012, Code Aurora Forum. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -2167,3 +2170,4 @@ struct msm_camera_v4l2_ioctl_t {
 };
 
 #endif /* __LINUX_MSM_CAMERA_H */
+#endif /* CONFIG_MSM_CAMERA_LEGACY */
diff --git a/include/media/msm_camera_legacy.h b/include/media/msm_camera_legacy.h
new file mode 100644
index 0000000..bf445952
--- /dev/null
+++ b/include/media/msm_camera_legacy.h
@@ -0,0 +1,1400 @@
+/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __LINUX_MSM_CAMERA_H
+#define __LINUX_MSM_CAMERA_H
+
+#ifdef MSM_CAMERA_BIONIC
+#include <sys/types.h>
+#endif
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#include <linux/cdev.h>
+#ifdef MSM_CAMERA_GCC
+#include <time.h>
+#else
+#include <linux/time.h>
+#endif
+
+#define MSM_CAM_IOCTL_MAGIC 'm'
+
+#define MSM_CAM_IOCTL_GET_SENSOR_INFO \
+	_IOR(MSM_CAM_IOCTL_MAGIC, 1, struct msm_camsensor_info *)
+
+#define MSM_CAM_IOCTL_REGISTER_PMEM \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 2, struct msm_pmem_info *)
+
+#define MSM_CAM_IOCTL_UNREGISTER_PMEM \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 3, unsigned)
+
+#define MSM_CAM_IOCTL_CTRL_COMMAND \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 4, struct msm_ctrl_cmd *)
+
+#define MSM_CAM_IOCTL_CONFIG_VFE  \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 5, struct msm_camera_vfe_cfg_cmd *)
+
+#define MSM_CAM_IOCTL_GET_STATS \
+	_IOR(MSM_CAM_IOCTL_MAGIC, 6, struct msm_camera_stats_event_ctrl *)
+
+#define MSM_CAM_IOCTL_GETFRAME \
+	_IOR(MSM_CAM_IOCTL_MAGIC, 7, struct msm_camera_get_frame *)
+
+#define MSM_CAM_IOCTL_ENABLE_VFE \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 8, struct camera_enable_cmd *)
+
+#define MSM_CAM_IOCTL_CTRL_CMD_DONE \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 9, struct camera_cmd *)
+
+#define MSM_CAM_IOCTL_CONFIG_CMD \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 10, struct camera_cmd *)
+
+#define MSM_CAM_IOCTL_DISABLE_VFE \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 11, struct camera_enable_cmd *)
+
+#define MSM_CAM_IOCTL_PAD_REG_RESET2 \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 12, struct camera_enable_cmd *)
+
+#define MSM_CAM_IOCTL_VFE_APPS_RESET \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 13, struct camera_enable_cmd *)
+
+#define MSM_CAM_IOCTL_RELEASE_FRAME_BUFFER \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 14, struct camera_enable_cmd *)
+
+#define MSM_CAM_IOCTL_RELEASE_STATS_BUFFER \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 15, struct msm_stats_buf *)
+
+#define MSM_CAM_IOCTL_AXI_CONFIG \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 16, struct msm_camera_vfe_cfg_cmd *)
+
+#define MSM_CAM_IOCTL_GET_PICTURE \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 17, struct msm_frame *)
+
+#define MSM_CAM_IOCTL_SET_CROP \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 18, struct crop_info *)
+
+#define MSM_CAM_IOCTL_PICT_PP \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 19, uint8_t *)
+
+#define MSM_CAM_IOCTL_PICT_PP_DONE \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 20, struct msm_snapshot_pp_status *)
+
+#define MSM_CAM_IOCTL_SENSOR_IO_CFG \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 21, struct sensor_cfg_data *)
+
+#define MSM_CAM_IOCTL_FLASH_LED_CFG \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 22, unsigned *)
+
+#define MSM_CAM_IOCTL_UNBLOCK_POLL_FRAME \
+	_IO(MSM_CAM_IOCTL_MAGIC, 23)
+
+#define MSM_CAM_IOCTL_CTRL_COMMAND_2 \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 24, struct msm_ctrl_cmd *)
+
+#define MSM_CAM_IOCTL_AF_CTRL \
+	_IOR(MSM_CAM_IOCTL_MAGIC, 25, struct msm_ctrl_cmt_t *)
+
+#define MSM_CAM_IOCTL_AF_CTRL_DONE \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 26, struct msm_ctrl_cmt_t *)
+
+#define MSM_CAM_IOCTL_CONFIG_VPE \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 27, struct msm_camera_vpe_cfg_cmd *)
+
+#define MSM_CAM_IOCTL_AXI_VPE_CONFIG \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 28, struct msm_camera_vpe_cfg_cmd *)
+
+#define MSM_CAM_IOCTL_STROBE_FLASH_CFG \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 29, uint32_t *)
+
+#define MSM_CAM_IOCTL_STROBE_FLASH_CHARGE \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 30, uint32_t *)
+
+#define MSM_CAM_IOCTL_STROBE_FLASH_RELEASE \
+	_IO(MSM_CAM_IOCTL_MAGIC, 31)
+
+#define MSM_CAM_IOCTL_FLASH_CTRL \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 32, struct flash_ctrl_data *)
+
+#define MSM_CAM_IOCTL_ERROR_CONFIG \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 33, uint32_t *)
+
+#define MSM_CAM_IOCTL_ABORT_CAPTURE \
+	_IO(MSM_CAM_IOCTL_MAGIC, 34)
+
+#define MSM_CAM_IOCTL_SET_FD_ROI \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 35, struct fd_roi_info *)
+
+#define MSM_CAM_IOCTL_GET_CAMERA_INFO \
+	_IOR(MSM_CAM_IOCTL_MAGIC, 36, struct msm_camera_info *)
+
+#define MSM_CAM_IOCTL_UNBLOCK_POLL_PIC_FRAME \
+	_IO(MSM_CAM_IOCTL_MAGIC, 37)
+
+#define MSM_CAM_IOCTL_RELEASE_PIC_BUFFER \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 38, struct camera_enable_cmd *)
+
+#define MSM_CAM_IOCTL_PUT_ST_FRAME \
+	_IOW(MSM_CAM_IOCTL_MAGIC, 39, struct msm_camera_st_frame *)
+
+#define MSM_CAM_IOCTL_GET_CONFIG_INFO \
+	_IOR(MSM_CAM_IOCTL_MAGIC, 40, struct msm_cam_config_dev_info *)
+
+#define MSM_CAMERA_LED_OFF  0
+#define MSM_CAMERA_LED_LOW  1
+#define MSM_CAMERA_LED_HIGH 2
+
+#define MSM_CAMERA_STROBE_FLASH_NONE 0
+#define MSM_CAMERA_STROBE_FLASH_XENON 1
+
+#define MSM_MAX_CAMERA_SENSORS  5
+#define MAX_SENSOR_NAME 32
+
+#define MSM_MAX_CAMERA_CONFIGS 2
+
+#define PP_SNAP  0x01
+#define PP_RAW_SNAP ((0x01)<<1)
+#define PP_PREV  ((0x01)<<2)
+#define PP_MASK		(PP_SNAP|PP_RAW_SNAP|PP_PREV)
+
+#define MSM_CAM_CTRL_CMD_DONE  0
+#define MSM_CAM_SENSOR_VFE_CMD 1
+
+#if 1//PCAM
+typedef struct{
+	unsigned short mode;
+	unsigned short address;
+	unsigned short value_1;
+	unsigned short value_2;
+	unsigned short value_3;
+} ioctl_pcam_info_8bit;
+
+#define MSM_CAM_IOCTL_PCAM_CTRL_8BIT   _IOWR(MSM_CAM_IOCTL_MAGIC, 40, ioctl_pcam_info_8bit)
+#endif//PCAM
+
+/*****************************************************
+ *  structure
+ *****************************************************/
+
+/* define five type of structures for userspace <==> kernel
+ * space communication:
+ * command 1 - 2 are from userspace ==> kernel
+ * command 3 - 4 are from kernel ==> userspace
+ *
+ * 1. control command: control command(from control thread),
+ *                     control status (from config thread);
+ */
+struct msm_ctrl_cmd {
+	uint16_t type;
+	uint16_t length;
+	void *value;
+	uint16_t status;
+	uint32_t timeout_ms;
+	int resp_fd; /* FIXME: to be used by the kernel, pass-through for now */
+	int vnode_id;  /* video dev id. Can we overload resp_fd? */
+	uint32_t stream_type; /* used to pass value to qcamera server */
+};
+
+struct msm_cam_evt_msg {
+	unsigned short type;	/* 1 == event (RPC), 0 == message (adsp) */
+	unsigned short msg_id;
+	unsigned int len;	/* size in, number of bytes out */
+	uint32_t frame_id;
+	void *data;
+};
+
+struct msm_isp_stats_event_ctrl {
+	unsigned short resptype;
+	union {
+		struct msm_cam_evt_msg isp_msg;
+		struct msm_ctrl_cmd ctrl;
+	} isp_data;
+};
+
+#define MSM_CAM_RESP_CTRL         0
+#define MSM_CAM_RESP_STAT_EVT_MSG 1
+#define MSM_CAM_RESP_STEREO_OP_1  2
+#define MSM_CAM_RESP_STEREO_OP_2  3
+#define MSM_CAM_RESP_V4L2         4
+#define MSM_CAM_RESP_MAX          5
+
+/* driver event types */
+#define MSM_CAM_EVT_HISTOGRAM_NOTIFY	(V4L2_EVENT_PRIVATE_START+1)
+#define MSM_CAM_EVT_STREAMING_NOTIFY	(V4L2_EVENT_PRIVATE_START+2)
+#define MSM_CAM_EVT_ASYNC_CMD_NOTIFY	(V4L2_EVENT_PRIVATE_START+3)
+#define MSM_CAM_EVT_CNT_MAX						3
+
+struct msm_event_histogram {
+	int32_t fd;
+	uint32_t size;
+	uint32_t offset;
+};
+struct msm_event_async_cmd_status {
+	uint32_t cmd;
+	int32_t status;
+};
+struct msm_event_streaming_status {
+	uint32_t ext_mode;
+	int32_t	streamon;
+	int32_t status;
+};
+struct msm_event_payload {
+	uint32_t type;
+	union {
+		struct msm_event_histogram hist;
+		struct msm_event_async_cmd_status cmd_status;
+		struct msm_event_streaming_status stream_status;
+	};
+};
+/* this one is used to send ctrl/status up to config thread */
+struct msm_stats_event_ctrl {
+	/* 0 - ctrl_cmd from control thread,
+	 * 1 - stats/event kernel,
+	 * 2 - V4L control or read request */
+	int resptype;
+	int timeout_ms;
+	struct msm_ctrl_cmd ctrl_cmd;
+	/* struct  vfe_event_t  stats_event; */
+	struct msm_cam_evt_msg stats_event;
+};
+
+/* 2. config command: config command(from config thread); */
+struct msm_camera_cfg_cmd {
+	/* what to config:
+	 * 1 - sensor config, 2 - vfe config */
+	uint16_t cfg_type;
+
+	/* sensor config type */
+	uint16_t cmd_type;
+	uint16_t queue;
+	uint16_t length;
+	void *value;
+};
+
+#define CMD_GENERAL			0
+#define CMD_AXI_CFG_OUT1		1
+#define CMD_AXI_CFG_SNAP_O1_AND_O2	2
+#define CMD_AXI_CFG_OUT2		3
+#define CMD_PICT_T_AXI_CFG		4
+#define CMD_PICT_M_AXI_CFG		5
+#define CMD_RAW_PICT_AXI_CFG		6
+
+#define CMD_FRAME_BUF_RELEASE		7
+#define CMD_PREV_BUF_CFG		8
+#define CMD_SNAP_BUF_RELEASE		9
+#define CMD_SNAP_BUF_CFG		10
+#define CMD_STATS_DISABLE		11
+#define CMD_STATS_AEC_AWB_ENABLE	12
+#define CMD_STATS_AF_ENABLE		13
+#define CMD_STATS_AEC_ENABLE		14
+#define CMD_STATS_AWB_ENABLE		15
+#define CMD_STATS_ENABLE  		16
+
+#define CMD_STATS_AXI_CFG		17
+#define CMD_STATS_AEC_AXI_CFG		18
+#define CMD_STATS_AF_AXI_CFG 		19
+#define CMD_STATS_AWB_AXI_CFG		20
+#define CMD_STATS_RS_AXI_CFG		21
+#define CMD_STATS_CS_AXI_CFG		22
+#define CMD_STATS_IHIST_AXI_CFG		23
+#define CMD_STATS_SKIN_AXI_CFG		24
+
+#define CMD_STATS_BUF_RELEASE		25
+#define CMD_STATS_AEC_BUF_RELEASE	26
+#define CMD_STATS_AF_BUF_RELEASE	27
+#define CMD_STATS_AWB_BUF_RELEASE	28
+#define CMD_STATS_RS_BUF_RELEASE	29
+#define CMD_STATS_CS_BUF_RELEASE	30
+#define CMD_STATS_IHIST_BUF_RELEASE	31
+#define CMD_STATS_SKIN_BUF_RELEASE	32
+
+#define UPDATE_STATS_INVALID		33
+#define CMD_AXI_CFG_SNAP_GEMINI		34
+#define CMD_AXI_CFG_SNAP		35
+#define CMD_AXI_CFG_PREVIEW		36
+#define CMD_AXI_CFG_VIDEO		37
+
+#define CMD_STATS_IHIST_ENABLE 38
+#define CMD_STATS_RS_ENABLE 39
+#define CMD_STATS_CS_ENABLE 40
+#define CMD_VPE 41
+#define CMD_AXI_CFG_VPE 42
+#define CMD_AXI_CFG_ZSL 43
+#define CMD_AXI_CFG_SNAP_VPE 44
+#define CMD_AXI_CFG_SNAP_THUMB_VPE 45
+
+/* vfe config command: config command(from config thread)*/
+struct msm_vfe_cfg_cmd {
+	int cmd_type;
+	uint16_t length;
+	void *value;
+};
+
+struct msm_vpe_cfg_cmd {
+	int cmd_type;
+	uint16_t length;
+	void *value;
+};
+
+#define MAX_CAMERA_ENABLE_NAME_LEN 32
+struct camera_enable_cmd {
+	char name[MAX_CAMERA_ENABLE_NAME_LEN];
+};
+
+#define MSM_PMEM_OUTPUT1		0
+#define MSM_PMEM_OUTPUT2		1
+#define MSM_PMEM_OUTPUT1_OUTPUT2	2
+#define MSM_PMEM_THUMBNAIL		3
+#define MSM_PMEM_MAINIMG		4
+#define MSM_PMEM_RAW_MAINIMG		5
+#define MSM_PMEM_AEC_AWB		6
+#define MSM_PMEM_AF			7
+#define MSM_PMEM_AEC			8
+#define MSM_PMEM_AWB			9
+#define MSM_PMEM_RS			10
+#define MSM_PMEM_CS			11
+#define MSM_PMEM_IHIST			12
+#define MSM_PMEM_SKIN			13
+#define MSM_PMEM_VIDEO			14
+#define MSM_PMEM_PREVIEW		15
+#define MSM_PMEM_VIDEO_VPE		16
+#define MSM_PMEM_C2D			17
+#define MSM_PMEM_MAINIMG_VPE    18
+#define MSM_PMEM_THUMBNAIL_VPE  19
+#define MSM_PMEM_MAX            20
+
+#define STAT_AEAW			0
+#define STAT_AEC			1
+#define STAT_AF				2
+#define STAT_AWB			3
+#define STAT_RS				4
+#define STAT_CS				5
+#define STAT_IHIST			6
+#define STAT_SKIN			7
+#define STAT_MAX			8
+
+#define FRAME_PREVIEW_OUTPUT1		0
+#define FRAME_PREVIEW_OUTPUT2		1
+#define FRAME_SNAPSHOT			2
+#define FRAME_THUMBNAIL			3
+#define FRAME_RAW_SNAPSHOT		4
+#define FRAME_MAX			5
+
+struct msm_pmem_info {
+	int type;
+	int fd;
+	void *vaddr;
+	uint32_t offset;
+	uint32_t len;
+	uint32_t y_off;
+	uint32_t cbcr_off;
+	uint8_t active;
+};
+
+struct outputCfg {
+	uint32_t height;
+	uint32_t width;
+
+	uint32_t window_height_firstline;
+	uint32_t window_height_lastline;
+};
+
+#define OUTPUT_1	0
+#define OUTPUT_2	1
+#define OUTPUT_1_AND_2            2   /* snapshot only */
+#define OUTPUT_1_AND_3            3   /* video */
+#define CAMIF_TO_AXI_VIA_OUTPUT_2 4
+#define OUTPUT_1_AND_CAMIF_TO_AXI_VIA_OUTPUT_2 5
+#define OUTPUT_2_AND_CAMIF_TO_AXI_VIA_OUTPUT_1 6
+#define OUTPUT_1_2_AND_3 7
+#define LAST_AXI_OUTPUT_MODE_ENUM = OUTPUT_1_2_AND_3 7
+
+#define MSM_FRAME_PREV_1	0
+#define MSM_FRAME_PREV_2	1
+#define MSM_FRAME_ENC		2
+
+#define OUTPUT_TYPE_P    (1<<0)
+#define OUTPUT_TYPE_T    (1<<1)
+#define OUTPUT_TYPE_S    (1<<2)
+#define OUTPUT_TYPE_V    (1<<3)
+#define OUTPUT_TYPE_L    (1<<4)
+#define OUTPUT_TYPE_ST_L (1<<5)
+#define OUTPUT_TYPE_ST_R (1<<6)
+#define OUTPUT_TYPE_ST_D (1<<7)
+
+struct fd_roi_info {
+	void *info;
+	int info_len;
+};
+
+struct msm_frame {
+	struct timespec ts;
+	int path;
+	int type;
+	unsigned long buffer;
+	uint32_t phy_offset;
+	uint32_t y_off;
+	uint32_t cbcr_off;
+	int fd;
+
+	void *cropinfo;
+	int croplen;
+	uint32_t error_code;
+	struct fd_roi_info roi_info;
+	uint32_t frame_id;
+	int stcam_quality_ind;
+	uint32_t stcam_conv_value;
+};
+
+enum msm_st_frame_packing {
+	SIDE_BY_SIDE_HALF,
+	SIDE_BY_SIDE_FULL,
+	TOP_DOWN_HALF,
+	TOP_DOWN_FULL,
+};
+
+struct msm_st_crop {
+	uint32_t in_w;
+	uint32_t in_h;
+	uint32_t out_w;
+	uint32_t out_h;
+};
+
+struct msm_st_half {
+	uint32_t buf_y_off;
+	uint32_t buf_cbcr_off;
+	uint32_t buf_y_stride;
+	uint32_t buf_cbcr_stride;
+	uint32_t pix_x_off;
+	uint32_t pix_y_off;
+	struct msm_st_crop stCropInfo;
+};
+
+struct msm_st_frame {
+	struct msm_frame buf_info;
+	int type;
+	enum msm_st_frame_packing packing;
+	struct msm_st_half L;
+	struct msm_st_half R;
+	int frame_id;
+};
+
+#define MSM_CAMERA_ERR_MASK (0xFFFFFFFF & 1)
+
+struct stats_buff {
+	unsigned long buff;
+	int fd;
+};
+
+struct msm_stats_buf {
+	struct stats_buff aec;
+	struct stats_buff awb;
+	struct stats_buff af;
+	struct stats_buff ihist;
+	struct stats_buff rs;
+	struct stats_buff cs;
+	struct stats_buff skin;
+	int type;
+	uint32_t status_bits;
+	unsigned long buffer;
+	int fd;
+	uint32_t frame_id;
+};
+#define MSM_V4L2_EXT_CAPTURE_MODE_DEFAULT 0
+/* video capture mode in VIDIOC_S_PARM */
+#define MSM_V4L2_EXT_CAPTURE_MODE_PREVIEW \
+	(MSM_V4L2_EXT_CAPTURE_MODE_DEFAULT+1)
+/* extendedmode for video recording in VIDIOC_S_PARM */
+#define MSM_V4L2_EXT_CAPTURE_MODE_VIDEO \
+	(MSM_V4L2_EXT_CAPTURE_MODE_DEFAULT+2)
+/* extendedmode for the full size main image in VIDIOC_S_PARM */
+#define MSM_V4L2_EXT_CAPTURE_MODE_MAIN (MSM_V4L2_EXT_CAPTURE_MODE_DEFAULT+3)
+/* extendedmode for the thumb nail image in VIDIOC_S_PARM */
+#define MSM_V4L2_EXT_CAPTURE_MODE_THUMBNAIL \
+	(MSM_V4L2_EXT_CAPTURE_MODE_DEFAULT+4)
+#define MSM_V4L2_EXT_CAPTURE_MODE_RAW \
+	(MSM_V4L2_EXT_CAPTURE_MODE_DEFAULT+5)
+#define MSM_V4L2_EXT_CAPTURE_MODE_MAX (MSM_V4L2_EXT_CAPTURE_MODE_DEFAULT+6)
+
+
+#define MSM_V4L2_PID_MOTION_ISO              V4L2_CID_PRIVATE_BASE
+#define MSM_V4L2_PID_EFFECT                 (V4L2_CID_PRIVATE_BASE+1)
+#define MSM_V4L2_PID_HJR                    (V4L2_CID_PRIVATE_BASE+2)
+#define MSM_V4L2_PID_LED_MODE               (V4L2_CID_PRIVATE_BASE+3)
+#define MSM_V4L2_PID_PREP_SNAPSHOT          (V4L2_CID_PRIVATE_BASE+4)
+#define MSM_V4L2_PID_EXP_METERING           (V4L2_CID_PRIVATE_BASE+5)
+#define MSM_V4L2_PID_ISO                    (V4L2_CID_PRIVATE_BASE+6)
+#define MSM_V4L2_PID_CAM_MODE               (V4L2_CID_PRIVATE_BASE+7)
+#define MSM_V4L2_PID_LUMA_ADAPTATION	    (V4L2_CID_PRIVATE_BASE+8)
+#define MSM_V4L2_PID_BEST_SHOT              (V4L2_CID_PRIVATE_BASE+9)
+#define MSM_V4L2_PID_FOCUS_MODE	            (V4L2_CID_PRIVATE_BASE+10)
+#define MSM_V4L2_PID_BL_DETECTION           (V4L2_CID_PRIVATE_BASE+11)
+#define MSM_V4L2_PID_SNOW_DETECTION         (V4L2_CID_PRIVATE_BASE+12)
+#define MSM_V4L2_PID_CTRL_CMD               (V4L2_CID_PRIVATE_BASE+13)
+#define MSM_V4L2_PID_EVT_SUB_INFO           (V4L2_CID_PRIVATE_BASE+14)
+#define MSM_V4L2_PID_STROBE_FLASH	    (V4L2_CID_PRIVATE_BASE+15)
+#define MSM_V4L2_PID_MAX                    MSM_V4L2_PID_STROBE_FLASH
+
+/* camera operation mode for video recording - two frame output queues */
+#define MSM_V4L2_CAM_OP_DEFAULT         0
+/* camera operation mode for video recording - two frame output queues */
+#define MSM_V4L2_CAM_OP_PREVIEW         (MSM_V4L2_CAM_OP_DEFAULT+1)
+/* camera operation mode for video recording - two frame output queues */
+#define MSM_V4L2_CAM_OP_VIDEO           (MSM_V4L2_CAM_OP_DEFAULT+2)
+/* camera operation mode for standard shapshot - two frame output queues */
+#define MSM_V4L2_CAM_OP_CAPTURE         (MSM_V4L2_CAM_OP_DEFAULT+3)
+/* camera operation mode for zsl shapshot - three output queues */
+#define MSM_V4L2_CAM_OP_ZSL             (MSM_V4L2_CAM_OP_DEFAULT+4)
+/* camera operation mode for raw snapshot - one frame output queue */
+#define MSM_V4L2_CAM_OP_RAW             (MSM_V4L2_CAM_OP_DEFAULT+5)
+
+#define MSM_V4L2_VID_CAP_TYPE	0
+#define MSM_V4L2_STREAM_ON		1
+#define MSM_V4L2_STREAM_OFF		2
+#define MSM_V4L2_SNAPSHOT		3
+#define MSM_V4L2_QUERY_CTRL		4
+#define MSM_V4L2_GET_CTRL		5
+#define MSM_V4L2_SET_CTRL		6
+#define MSM_V4L2_QUERY			7
+#define MSM_V4L2_GET_CROP		8
+#define MSM_V4L2_SET_CROP		9
+#define MSM_V4L2_OPEN			10
+#define MSM_V4L2_CLOSE			11
+#define MSM_V4L2_SET_CTRL_CMD	12
+#define MSM_V4L2_EVT_SUB_MASK	13
+#define MSM_V4L2_MAX			14
+#define V4L2_CAMERA_EXIT		43
+
+struct crop_info {
+	void *info;
+	int len;
+};
+
+struct msm_postproc {
+	int ftnum;
+	struct msm_frame fthumnail;
+	int fmnum;
+	struct msm_frame fmain;
+};
+
+struct msm_snapshot_pp_status {
+	void *status;
+};
+
+#define CFG_SET_MODE			0
+#define CFG_SET_EFFECT			1
+#define CFG_START			2
+#define CFG_PWR_UP			3
+#define CFG_PWR_DOWN			4
+#define CFG_WRITE_EXPOSURE_GAIN		5
+#define CFG_SET_DEFAULT_FOCUS		6
+#define CFG_MOVE_FOCUS			7
+#define CFG_REGISTER_TO_REAL_GAIN	8
+#define CFG_REAL_TO_REGISTER_GAIN	9
+#define CFG_SET_FPS			10
+#define CFG_SET_PICT_FPS		11
+#define CFG_SET_BRIGHTNESS		12
+#define CFG_SET_CONTRAST		13
+#define CFG_SET_ZOOM			14
+#define CFG_SET_EXPOSURE_MODE		15
+#define CFG_SET_WB			16
+#define CFG_SET_ANTIBANDING		17
+#define CFG_SET_EXP_GAIN		18
+#define CFG_SET_PICT_EXP_GAIN		19
+#define CFG_SET_LENS_SHADING		20
+#define CFG_GET_PICT_FPS		21
+#define CFG_GET_PREV_L_PF		22
+#define CFG_GET_PREV_P_PL		23
+#define CFG_GET_PICT_L_PF		24
+#define CFG_GET_PICT_P_PL		25
+#define CFG_GET_AF_MAX_STEPS		26
+#define CFG_GET_PICT_MAX_EXP_LC		27
+#define CFG_SEND_WB_INFO    28
+#define CFG_SENSOR_INIT    29
+#define CFG_GET_3D_CALI_DATA 30
+#define CFG_GET_CALIB_DATA		31
+#define CFG_MAX			32
+
+
+#define MOVE_NEAR	0
+#define MOVE_FAR	1
+
+#define SENSOR_PREVIEW_MODE		0
+#define SENSOR_SNAPSHOT_MODE		1
+#define SENSOR_RAW_SNAPSHOT_MODE	2
+#define SENSOR_HFR_60FPS_MODE 3
+#define SENSOR_HFR_90FPS_MODE 4
+#define SENSOR_HFR_120FPS_MODE 5
+
+#define SENSOR_QTR_SIZE			0
+#define SENSOR_FULL_SIZE		1
+#define SENSOR_QVGA_SIZE		2
+#define SENSOR_INVALID_SIZE		3
+
+#define CAMERA_EFFECT_OFF		0
+#define CAMERA_EFFECT_MONO		1
+#define CAMERA_EFFECT_NEGATIVE		2
+#define CAMERA_EFFECT_SOLARIZE		3
+#define CAMERA_EFFECT_SEPIA		4
+#define CAMERA_EFFECT_POSTERIZE		5
+#define CAMERA_EFFECT_WHITEBOARD	6
+#define CAMERA_EFFECT_BLACKBOARD	7
+#define CAMERA_EFFECT_AQUA		8
+#define CAMERA_EFFECT_MAX		9
+
+/* QRD */
+#define CAMERA_EFFECT_BW		10
+#define CAMERA_EFFECT_BLUISH	12
+#define CAMERA_EFFECT_REDDISH	13
+#define CAMERA_EFFECT_GREENISH	14
+
+/* QRD */
+#define CAMERA_ANTIBANDING_OFF		0
+#define CAMERA_ANTIBANDING_50HZ		2
+#define CAMERA_ANTIBANDING_60HZ		1
+#define CAMERA_ANTIBANDING_AUTO		3
+
+#define CAMERA_CONTRAST_LV0			0
+#define CAMERA_CONTRAST_LV1			1
+#define CAMERA_CONTRAST_LV2			2
+#define CAMERA_CONTRAST_LV3			3
+#define CAMERA_CONTRAST_LV4			4
+#define CAMERA_CONTRAST_LV5			5
+#define CAMERA_CONTRAST_LV6			6
+#define CAMERA_CONTRAST_LV7			7
+#define CAMERA_CONTRAST_LV8			8
+#define CAMERA_CONTRAST_LV9			9
+
+#define CAMERA_BRIGHTNESS_LV0			0
+#define CAMERA_BRIGHTNESS_LV1			1
+#define CAMERA_BRIGHTNESS_LV2			2
+#define CAMERA_BRIGHTNESS_LV3			3
+#define CAMERA_BRIGHTNESS_LV4			4
+#define CAMERA_BRIGHTNESS_LV5			5
+#define CAMERA_BRIGHTNESS_LV6			6
+#define CAMERA_BRIGHTNESS_LV7			7
+#define CAMERA_BRIGHTNESS_LV8			8
+
+
+#define CAMERA_SATURATION_LV0			0
+#define CAMERA_SATURATION_LV1			1
+#define CAMERA_SATURATION_LV2			2
+#define CAMERA_SATURATION_LV3			3
+#define CAMERA_SATURATION_LV4			4
+#define CAMERA_SATURATION_LV5			5
+#define CAMERA_SATURATION_LV6			6
+#define CAMERA_SATURATION_LV7			7
+#define CAMERA_SATURATION_LV8			8
+
+#define CAMERA_SHARPNESS_LV0		0
+#define CAMERA_SHARPNESS_LV1		3
+#define CAMERA_SHARPNESS_LV2		6
+#define CAMERA_SHARPNESS_LV3		9
+#define CAMERA_SHARPNESS_LV4		12
+#define CAMERA_SHARPNESS_LV5		15
+#define CAMERA_SHARPNESS_LV6		18
+#define CAMERA_SHARPNESS_LV7		21
+#define CAMERA_SHARPNESS_LV8		24
+#define CAMERA_SHARPNESS_LV9		27
+#define CAMERA_SHARPNESS_LV10		30
+
+#define CAMERA_SETAE_AVERAGE		0
+#define CAMERA_SETAE_CENWEIGHT	1
+
+#define CFG_SET_SATURATION		30
+#define CFG_SET_SHARPNESS			31
+#define CFG_SET_TOUCHAEC            32
+#define CFG_SET_AUTO_FOCUS          33
+#define CFG_SET_AUTOFLASH 34
+/* QRD */
+#define CFG_SET_EXPOSURE_COMPENSATION 35
+
+#define  CAMERA_WB_AUTO               1 /* This list must match aeecamera.h */
+#define  CAMERA_WB_CUSTOM             2
+#define  CAMERA_WB_INCANDESCENT       3
+#define  CAMERA_WB_FLUORESCENT        4
+#define  CAMERA_WB_DAYLIGHT           5
+#define  CAMERA_WB_CLOUDY_DAYLIGHT    6
+#define  CAMERA_WB_TWILIGHT           7
+#define  CAMERA_WB_SHADE              8
+
+#define CAMERA_EXPOSURE_COMPENSATION_LV0			12
+#define CAMERA_EXPOSURE_COMPENSATION_LV1			6
+#define CAMERA_EXPOSURE_COMPENSATION_LV2			0
+#define CAMERA_EXPOSURE_COMPENSATION_LV3			-6
+#define CAMERA_EXPOSURE_COMPENSATION_LV4			-12
+
+
+struct sensor_pict_fps {
+	uint16_t prevfps;
+	uint16_t pictfps;
+};
+
+struct exp_gain_cfg {
+	uint16_t gain;
+	uint32_t line;
+};
+
+struct focus_cfg {
+	int32_t steps;
+	int dir;
+};
+
+struct fps_cfg {
+	uint16_t f_mult;
+	uint16_t fps_div;
+	uint32_t pict_fps_div;
+};
+struct wb_info_cfg {
+	uint16_t red_gain;
+	uint16_t green_gain;
+	uint16_t blue_gain;
+};
+struct sensor_3d_exp_cfg {
+	uint16_t gain;
+	uint32_t line;
+	uint16_t r_gain;
+	uint16_t b_gain;
+	uint16_t gr_gain;
+	uint16_t gb_gain;
+	uint16_t gain_adjust;
+};
+struct sensor_3d_cali_data_t{
+	unsigned char left_p_matrix[3][4][8];
+	unsigned char right_p_matrix[3][4][8];
+	unsigned char square_len[8];
+	unsigned char focal_len[8];
+	unsigned char pixel_pitch[8];
+	uint16_t left_r;
+	uint16_t left_b;
+	uint16_t left_gb;
+	uint16_t left_af_far;
+	uint16_t left_af_mid;
+	uint16_t left_af_short;
+	uint16_t left_af_5um;
+	uint16_t left_af_50up;
+	uint16_t left_af_50down;
+	uint16_t right_r;
+	uint16_t right_b;
+	uint16_t right_gb;
+	uint16_t right_af_far;
+	uint16_t right_af_mid;
+	uint16_t right_af_short;
+	uint16_t right_af_5um;
+	uint16_t right_af_50up;
+	uint16_t right_af_50down;
+};
+struct sensor_init_cfg {
+	uint8_t prev_res;
+	uint8_t pict_res;
+};
+
+struct sensor_calib_data {
+	/* Color Related Measurements */
+	uint16_t r_over_g;
+	uint16_t b_over_g;
+	uint16_t gr_over_gb;
+
+	/* Lens Related Measurements */
+	uint16_t macro_2_inf;
+	uint16_t inf_2_macro;
+	uint16_t stroke_amt;
+	uint16_t af_pos_1m;
+	uint16_t af_pos_inf;
+};
+
+enum msm_sensor_resolution_t {
+	MSM_SENSOR_RES_FULL,
+	MSM_SENSOR_RES_QTR,
+	MSM_SENSOR_RES_2,
+	MSM_SENSOR_RES_3,
+	MSM_SENSOR_RES_4,
+	MSM_SENSOR_RES_5,
+	MSM_SENSOR_RES_6,
+	MSM_SENSOR_RES_7,
+	MSM_SENSOR_INVALID_RES,
+};
+
+struct msm_sensor_output_info_t {
+	uint16_t x_output;
+	uint16_t y_output;
+	uint16_t line_length_pclk;
+	uint16_t frame_length_lines;
+	uint32_t vt_pixel_clk;
+	uint32_t op_pixel_clk;
+	uint16_t binning_factor;
+};
+
+struct sensor_output_info_t {
+	struct msm_sensor_output_info_t *output_info;
+	uint16_t num_info;
+};
+
+struct sensor_eeprom_data_t {
+	void *eeprom_data;
+	uint16_t index;
+};
+
+struct mirror_flip {
+	int32_t x_mirror;
+	int32_t y_flip;
+};
+
+struct cord {
+	uint32_t x;
+	uint32_t y;
+};
+
+struct sensor_cfg_data {
+	int cfgtype;
+	int mode;
+	int rs;
+	uint8_t max_steps;
+
+	union {
+		int8_t effect;
+		uint8_t lens_shading;
+		uint16_t prevl_pf;
+		uint16_t prevp_pl;
+		uint16_t pictl_pf;
+		uint16_t pictp_pl;
+		uint32_t pict_max_exp_lc;
+		uint16_t p_fps;
+		struct sensor_init_cfg init_info;
+		struct sensor_pict_fps gfps;
+		struct exp_gain_cfg exp_gain;
+		struct focus_cfg focus;
+		struct fps_cfg fps;
+		struct wb_info_cfg wb_info;
+		struct sensor_3d_exp_cfg sensor_3d_exp;
+		struct sensor_calib_data calib_info;
+		struct sensor_output_info_t output_info;
+		struct sensor_eeprom_data_t eeprom_data;
+		/* QRD */
+		uint16_t antibanding;
+		uint8_t contrast;
+		uint8_t saturation;
+		uint8_t sharpness;
+		int8_t brightness;
+		int ae_mode;
+		uint8_t wb_val;
+		int8_t exp_compensation;
+		struct cord aec_cord;
+		int is_autoflash;
+		struct mirror_flip mirror_flip;
+	} cfg;
+};
+
+struct msm_actuator_move_params_t {
+	int8_t dir;
+	int32_t num_steps;
+};
+
+struct msm_actuator_set_info_t {
+	uint32_t total_steps;
+	uint16_t gross_steps;
+	uint16_t fine_steps;
+};
+
+struct msm_actuator_get_info_t {
+	uint32_t focal_length_num;
+	uint32_t focal_length_den;
+	uint32_t f_number_num;
+	uint32_t f_number_den;
+	uint32_t f_pix_num;
+	uint32_t f_pix_den;
+	uint32_t total_f_dist_num;
+	uint32_t total_f_dist_den;
+};
+
+struct msm_actuator_cfg_data {
+	int cfgtype;
+	uint8_t is_af_supported;
+	union {
+		struct msm_actuator_move_params_t move;
+		struct msm_actuator_set_info_t set_info;
+		struct msm_actuator_get_info_t get_info;
+	} cfg;
+};
+
+struct sensor_large_data {
+	int cfgtype;
+	union {
+		struct sensor_3d_cali_data_t sensor_3d_cali_data;
+	} data;
+};
+
+enum sensor_type_t {
+	BAYER,
+	YUV,
+	JPEG_SOC,
+};
+
+enum flash_type {
+	LED_FLASH,
+	STROBE_FLASH,
+};
+
+enum strobe_flash_ctrl_type {
+	STROBE_FLASH_CTRL_INIT,
+	STROBE_FLASH_CTRL_CHARGE,
+	STROBE_FLASH_CTRL_RELEASE
+};
+
+struct strobe_flash_ctrl_data {
+	enum strobe_flash_ctrl_type type;
+	int charge_en;
+};
+
+struct msm_camera_info {
+	int num_cameras;
+	uint8_t has_3d_support[MSM_MAX_CAMERA_SENSORS];
+	uint8_t is_internal_cam[MSM_MAX_CAMERA_SENSORS];
+	uint32_t s_mount_angle[MSM_MAX_CAMERA_SENSORS];
+	const char *video_dev_name[MSM_MAX_CAMERA_SENSORS];
+	enum sensor_type_t sensor_type[MSM_MAX_CAMERA_SENSORS];
+
+};
+
+struct msm_cam_config_dev_info {
+	int num_config_nodes;
+	const char *config_dev_name[MSM_MAX_CAMERA_CONFIGS];
+};
+
+struct flash_ctrl_data {
+	int flashtype;
+	union {
+		int led_state;
+		struct strobe_flash_ctrl_data strobe_ctrl;
+	} ctrl_data;
+};
+
+#define GET_NAME			0
+#define GET_PREVIEW_LINE_PER_FRAME	1
+#define GET_PREVIEW_PIXELS_PER_LINE	2
+#define GET_SNAPSHOT_LINE_PER_FRAME	3
+#define GET_SNAPSHOT_PIXELS_PER_LINE	4
+#define GET_SNAPSHOT_FPS		5
+#define GET_SNAPSHOT_MAX_EP_LINE_CNT	6
+
+struct msm_camsensor_info {
+	char name[MAX_SENSOR_NAME];
+	uint8_t flash_enabled;
+	int8_t total_steps;
+	uint8_t support_3d;
+};
+#if 1 //defined (CONFIG_OEM_CAMERA)
+typedef struct{
+	uint32_t device_id;
+	uint32_t cmd;
+	uint32_t  value_1;
+	uint32_t  value_2;
+	void* p;
+} sensor_ext_cfg_data;
+
+typedef struct {
+	char company;
+	char module_vesion;
+	char year;
+	char month;
+	char update_times[2];
+} sensor_version_info;
+
+typedef struct {
+	uint32_t dev_num;
+	char module_name[10];
+} sensor_name_info;
+
+struct sensor_version {
+	unsigned int major;
+	unsigned int minor;
+};
+
+struct sensor_date_info {
+	unsigned int year;
+	unsigned int month;
+	unsigned int date;
+};
+
+struct sensor_sensor_maker{
+	unsigned int maker;
+	unsigned int optical;
+};
+
+struct sensor_version_af{
+	unsigned int low;
+	unsigned int high;
+};
+
+struct sensor_gamma{
+	unsigned int rg_low;
+	unsigned int rg_high;
+	unsigned int bg_low;
+	unsigned int bg_high;
+};
+
+struct sensor_firmware_info
+{
+    struct sensor_version fw;
+    struct sensor_version prm;
+    struct sensor_date_info dateinfo;
+    struct sensor_sensor_maker sensor_info;
+    struct sensor_version_af af_info;
+    struct sensor_gamma gamma;
+    unsigned int fw_dump_size;
+	unsigned  int sensor_version;
+};
+
+struct gps_info_common {
+	unsigned int 	direction;
+	unsigned int 	dgree;
+	unsigned int	minute;
+	unsigned int	second;
+};
+
+enum v4l2_blur
+{
+	BLUR_LEVEL_0 = 0,
+	BLUR_LEVEL_1,
+	BLUR_LEVEL_2,
+	BLUR_LEVEL_3,
+	BLUR_LEVEL_MAX,
+};
+
+#define MSM_CAM_IOCTL_EXT_CONFIG  _IOWR(MSM_CAM_IOCTL_MAGIC, 50, sensor_ext_cfg_data)
+#define MSM_CAM_IOCTL_FIRMWARE_UPDATE  _IOWR(MSM_CAM_IOCTL_MAGIC, 51, sensor_ext_cfg_data)
+#define MSM_CAM_IOCTL_READ_VERSION_INFO  _IOWR(MSM_CAM_IOCTL_MAGIC, 52, struct sensor_firmware_info)
+#define MSM_CAM_IOCTL_READ_MODULE_NAME  _IOWR(MSM_CAM_IOCTL_MAGIC, 53, sensor_name_info)
+
+#define	EXIF_EXPOSURE_TIME		        0
+#define	EXIF_TV					1
+#define	EXIF_AV					2
+#define	EXIF_BV					3
+#define	EXIF_EBV				4
+#define	EXIF_ISO				5
+#define	EXIF_FLASH				6
+
+enum ext_cfg_command
+{
+    EXT_CFG_SET_FLASH = 0,
+    EXT_CFG_SET_FLASH_MODE,
+    EXT_CFG_SET_AUTO_CONTRAST,
+    EXT_CFG_SET_SCENE,
+    EXT_CFG_SET_SHARPNESS,
+    EXT_CFG_SET_EFFECT,
+    EXT_CFG_SET_SATURATION,
+    EXT_CFG_SET_ISO,
+    EXT_CFG_SET_WB,
+    EXT_CFG_SET_CONTRAST,
+    EXT_CFG_SET_BRIGHTNESS,
+    EXT_CFG_SET_ZOOM,
+    EXT_CFG_SET_FPS,
+    EXT_CFG_SET_FPS_MODE,
+    EXT_CFG_SET_AF_MODE,
+    EXT_CFG_SET_AF_START,
+    EXT_CFG_SET_AF_STOP,
+    EXT_CFG_SET_AF_OPERATION,
+    EXT_CFG_GET_AF_STATUS,
+    EXT_CFG_SET_TOUCHAF_POS,
+    EXT_CFG_SET_FACE_DETECT,
+    EXT_CFG_SET_METERING,
+    EXT_CFG_SET_CONTINUOUS_AF,
+    EXT_CFG_SET_PREVIEW_SIZE,
+    EXT_CFG_SET_PICTURE_SIZE,
+    EXT_CFG_SET_JPEG_QUALITY,
+    EXT_CFG_SET_ANTISHAKE,
+    EXT_CFG_SET_WDR,
+    EXT_CFG_SET_EXIF,
+    EXT_CFG_SET_DTP,
+    EXT_CFG_SET_AE_AWB,
+    EXT_CFG_SET_FRONT_CAMERA_MODE,
+    EXT_CFG_SET_BEAUTY,
+    EXT_CFG_SET_VINTAGEMODE,
+    EXT_CFG_SET_BATCH_REFLECTION,
+    EXT_CFG_GET_JPEG_SIZE,
+    EXT_CFG_UPDATE_FIRMWARE,
+    EXT_CFG_DUMP_FIRMWARE,
+    EXT_CFG_SET_GPS_LATITUDE,
+    EXT_CFG_SET_GPS_LONGITUDE,
+    EXT_CFG_SET_GPS_ALTITUDE,
+    EXT_CFG_SET_GPS_TIMESTAMP,
+    EXT_CFG_SET_EXIF_TIME_INFO,
+    EXT_CFG_SET_GPS_PROCESSINGMETHOD,
+    EXT_CFG_SET_EXIF_ORIENTATION_INFO,
+    EXT_CFG_SET_BLUR,
+    EXT_CFG_SET_THUMB_NULL,
+    EXT_CFG_SET_CAM_MODE,
+    EXT_CFG_GET_EXIF_INFO,
+    EXT_CFG_GET_FLASH_INFO,
+    EXT_CFG_GET_VGACAM_ROTATED, // kurtlee
+    EXT_CFG_TEST_ESD,
+    EXT_CFG_GET_INFO,
+    EXT_CFG_FRAME_CONTROL,
+    EXT_CFG_AF_CONTROL,
+    EXT_CFG_EFFECT_CONTROL,
+    EXT_CFG_WB_CONTROL,
+    EXT_CFG_BR_CONTROL,
+    EXT_CFG_ISO_CONTROL,
+    EXT_CFG_METERING_CONTROL,
+    EXT_CFG_SCENE_CONTROL,
+    EXT_CFG_AE_AWB_CONTROL,
+    EXT_CFG_CR_CONTROL,
+    EXT_CFG_SA_CONTROL,
+    EXT_CFG_SP_CONTROL,
+    EXT_CFG_CPU_CONTROL,
+    EXT_CFG_DTP_CONTROL,
+    EXT_CFG_PRETTY_CONTROL,
+    EXT_CFG_VT_MODE_CONTROL,
+    EXT_CFG_GET_MODULE_STATUS,
+
+    EXT_CFG_MAX,
+};
+
+enum ext_cfg_command_cammode
+{
+	EXT_CFG_CAM_MODE_CAMERA,
+	EXT_CFG_CAM_MODE_CAMCORDER,
+	EXT_CFG_CAM_MODE_FACTORY_TEST,
+};
+
+enum ext_cfg_command_jpeq_quality
+{
+	EXT_CFG_JPEG_QUALITY_SUPERFINE,
+	EXT_CFG_JPEG_QUALITY_FINE,
+	EXT_CFG_JPEG_QUALITY_NORMAL,
+};
+
+enum ext_cfg_command_auto_contrast
+{
+	EXT_CFG_AUTO_CONTRAST_ON,
+	EXT_CFG_AUTO_CONTRAST_OFF,
+};
+
+enum ext_cfg_command_framerate {
+	EXT_CFG_FRAME_AUTO = 0,
+	EXT_CFG_FRAME_FIX_7 = 7,
+	EXT_CFG_FRAME_FIX_15 = 15,
+	EXT_CFG_FRAME_FIX_20 = 20,
+	EXT_CFG_FRAME_FIX_24 = 24,
+	EXT_CFG_FRAME_FIX_25 = 25,
+	EXT_CFG_FRAME_FIX_30 = 30,
+};
+
+enum ext_cfg_command_effect
+{
+	EXT_CFG_EFFECT_NORMAL,
+	EXT_CFG_EFFECT_NEGATIVE,
+	EXT_CFG_EFFECT_MONO,
+	EXT_CFG_EFFECT_SEPIA,
+};
+
+enum ext_cfg_command_whitebalance
+{
+	EXT_CFG_WB_AUTO,
+	EXT_CFG_WB_DAYLIGHT,
+	EXT_CFG_WB_CLOUDY,
+	EXT_CFG_WB_FLUORESCENT,
+	EXT_CFG_WB_INCANDESCENT,
+};
+
+enum ext_cfg_command_brightness
+{
+	EXT_CFG_BR_STEP_M_4,
+	EXT_CFG_BR_STEP_M_3,
+	EXT_CFG_BR_STEP_M_2,
+	EXT_CFG_BR_STEP_M_1,
+	EXT_CFG_BR_STEP_0,
+	EXT_CFG_BR_STEP_P_1,
+	EXT_CFG_BR_STEP_P_2,
+	EXT_CFG_BR_STEP_P_3,
+	EXT_CFG_BR_STEP_P_4,
+};
+
+enum ext_cfg_command_contrast
+{
+	EXT_CFG_CR_STEP_M_2,
+	EXT_CFG_CR_STEP_M_1,
+	EXT_CFG_CR_STEP_0,
+	EXT_CFG_CR_STEP_P_1,
+	EXT_CFG_CR_STEP_P_2,
+};
+
+enum ext_cfg_command_saturation
+{
+	EXT_CFG_SA_STEP_M_2,
+	EXT_CFG_SA_STEP_M_1,
+	EXT_CFG_SA_STEP_0,
+	EXT_CFG_SA_STEP_P_1,
+	EXT_CFG_SA_STEP_P_2,
+};
+
+enum ext_cfg_command_sharpness
+{
+	EXT_CFG_SP_STEP_M_2,
+	EXT_CFG_SP_STEP_M_1,
+	EXT_CFG_SP_STEP_0,
+	EXT_CFG_SP_STEP_P_1,
+	EXT_CFG_SP_STEP_P_2,
+};
+
+enum ext_cfg_command_iso
+{
+	EXT_CFG_ISO_AUTO,
+	EXT_CFG_ISO_50,
+	EXT_CFG_ISO_100,
+	EXT_CFG_ISO_200,
+	EXT_CFG_ISO_400,
+};
+
+enum ext_cfg_command_metering
+{
+	EXT_CFG_METERING_NORMAL, //matrix
+	EXT_CFG_METERING_SPOT,
+	EXT_CFG_METERING_CENTER,
+};
+
+enum ext_cfg_command_scene
+{
+	EXT_CFG_SCENE_OFF,
+	EXT_CFG_SCENE_PORTRAIT,
+	EXT_CFG_SCENE_LANDSCAPE,
+	EXT_CFG_SCENE_SPORTS,
+	EXT_CFG_SCENE_PARTY,
+	EXT_CFG_SCENE_BEACH,
+	EXT_CFG_SCENE_SUNSET,
+	EXT_CFG_SCENE_DAWN,
+	EXT_CFG_SCENE_FALL,
+	EXT_CFG_SCENE_NIGHTSHOT,
+	EXT_CFG_SCENE_BACKLIGHT,
+	EXT_CFG_SCENE_FIREWORK,
+	EXT_CFG_SCENE_TEXT,
+	EXT_CFG_SCENE_CANDLE,
+};
+
+enum ext_cfg_command_af_operation
+{
+	EXT_CFG_AF_CHECK_STATUS,
+	EXT_CFG_AF_OFF,
+	EXT_CFG_AF_SET_NORMAL,
+	EXT_CFG_AF_SET_MACRO,
+	EXT_CFG_AF_DO,
+	EXT_CFG_AF_SET_MANUAL,
+	EXT_CFG_AF_ABORT,
+	EXT_CFG_AF_CHECK_2nd_STATUS,
+	EXT_CFG_AF_SET_AE_FOR_FLASH,
+	EXT_CFG_AF_BACK_AE_FOR_FLASH,
+	EXT_CFG_AF_CHECK_AE_STATUS,
+	EXT_CFG_AF_POWEROFF,
+};
+
+enum ext_cfg_command_af_status
+{
+	EXT_CFG_AF_PROGRESS = 1,
+	EXT_CFG_AF_SUCCESS,
+	EXT_CFG_AF_LOWCONF,//Fail
+	EXT_CFG_AF_CANCELED,
+	EXT_CFG_AF_TIMEOUT,
+	EXT_CFG_AE_STABLE,
+	EXT_CFG_AE_UNSTABLE,
+};
+
+enum ext_cfg_command_af_2nd_status
+{
+    EXT_CFG_AF_2ND_DONE=0,
+    EXT_CFG_AF_2ND_PROGRESS=256,
+};
+
+enum ext_cfg_command_ae_awb
+{
+	EXT_CFG_AE_LOCK,
+	EXT_CFG_AE_UNLOCK,
+	EXT_CFG_AWB_LOCK,
+	EXT_CFG_AWB_UNLOCK,
+	EXT_CFG_AE_AWB_LOCK,
+	EXT_CFG_AE_AWB_UNLOCK,
+};
+
+enum ext_cfg_command_cpu_policy
+{
+	EXT_CFG_CPU_CONSERVATIVE,
+	EXT_CFG_CPU_ONDEMAND,
+	EXT_CFG_CPU_PERFORMANCE,
+};
+
+enum ext_cfg_command_dtp
+{
+	EXT_CFG_DTP_OFF,
+	EXT_CFG_DTP_ON,
+};
+
+enum ext_cfg_command_zoom
+{
+	EXT_CFG_ZOOM_STEP_0,
+	EXT_CFG_ZOOM_STEP_1,
+	EXT_CFG_ZOOM_STEP_2,
+	EXT_CFG_ZOOM_STEP_3,
+	EXT_CFG_ZOOM_STEP_4,
+	EXT_CFG_ZOOM_STEP_5,
+	EXT_CFG_ZOOM_STEP_6,
+	EXT_CFG_ZOOM_STEP_7,
+	EXT_CFG_ZOOM_STEP_8,
+};
+
+enum ext_cfg_command_picture_size
+{
+	EXT_CFG_SNAPSHOT_SIZE_2560x1920_5M,
+	EXT_CFG_SNAPSHOT_SIZE_2560x1536_4M_WIDE,
+	EXT_CFG_SNAPSHOT_SIZE_2048x1536_3M,
+	EXT_CFG_SNAPSHOT_SIZE_2048x1232_2_4M_WIDE,
+	EXT_CFG_SNAPSHOT_SIZE_1600x1200_2M,
+	EXT_CFG_SNAPSHOT_SIZE_1600x960_1_5M_WIDE,
+	EXT_CFG_SNAPSHOT_SIZE_1280x960_1M,
+	EXT_CFG_SNAPSHOT_SIZE_800x480_4K_WIDE,
+	EXT_CFG_SNAPSHOT_SIZE_640x480_VGA,
+	EXT_CFG_SNAPSHOT_SIZE_320x240_QVGA,
+};
+
+enum ext_cfg_command_preview_size
+{
+    EXT_CFG_PREVIEW_SIZE_1280x720_D1,
+	EXT_CFG_PREVIEW_SIZE_800x480_WVGA,
+	EXT_CFG_PREVIEW_SIZE_720x480_D1,
+	EXT_CFG_PREVIEW_SIZE_640x480_VGA,
+	EXT_CFG_PREVIEW_SIZE_320x240_QVGA,
+	EXT_CFG_PREVIEW_SIZE_176x144_QCIF,
+};
+
+enum ext_cfg_command_flash
+{
+	EXT_CFG_FLASH_ON,
+	EXT_CFG_FLASH_OFF,
+	EXT_CFG_FLASH_AUTO,
+	EXT_CFG_FLASH_TURN_ON,
+	EXT_CFG_FLASH_TURN_OFF,
+	EXT_CFG_FLASH_TORCH,
+};
+
+enum ext_cfg_command_pretty
+{
+	EXT_CFG_PRETTY_LEVEL_0,
+	EXT_CFG_PRETTY_LEVEL_1,
+	EXT_CFG_PRETTY_LEVEL_2,
+	EXT_CFG_PRETTY_LEVEL_3,
+};
+
+enum ext_cfg_command_mode
+{
+	EXT_CFG_CAMERA_MODE,
+	EXT_CFG_CAMCORDER_MODE,
+};
+
+#endif /* CONFIG_OEM_CAMERA */
+#endif /* __LINUX_MSM_CAMERA_H */
